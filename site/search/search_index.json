{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. README.md # Other markdown pages, images and other files. about.md concepts.md releasenotes.md getstarted/ build.md clitools.md jumpstart.md quickstart.md webconsole.md","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. README.md # Other markdown pages, images and other files. about.md concepts.md releasenotes.md getstarted/ build.md clitools.md jumpstart.md quickstart.md webconsole.md","title":"Project layout"},{"location":"about/","text":"immudb explained What is immudb? immudb is database with built-in cryptographic proof and verification. It can track changes in sensitive data and the integrity of the history will be protected by the clients, without the need to trust the server. immudb can operate both as a key-value or relational (SQL) database. You can add new transactions, but deletion or modification of older transactions isn\u2019t allowed, thus making your data immutable. When a key record's value changes over time (such as a bank balance), you can get multiple instances with different timestamps to give you the complete history of that record's changes. You can store a variety of common data types, verification checksums, or JSON. What makes immudb special? Keep track of changes and audit them. Traditional database transactions and logs are hard to scale and are mutable, so there is no way to know for sure if your data has been compromised. immudb is immutable. You can add new versions of existing records, but never change or delete records. This lets you store critical data without fear of it being changed silently. Verify your data without sacrificing performance. Data stored in immudb is cryptographically coherent and verifiable, just like blockchains, but without all the complexity. Unlike blockchains, immudb can handle millions of transactions per second, and can be used both as a lightweight service or embedded in your application as a library. Protect yourself from supply-chain attacks. While Cyber Security is an important part of your organization\u2019s business plan, immudb provides another layer of security to ensure data integrity even in the event your perimeter is breached during an attack. Data cannot be deleted or modified once stored into immudb. Additions of new data are logged and auditable, enabling you to view any suspect additions made during the intrusion. How can I use immudb? Depending on your use case, immudb might function as your application's primary or as a secondary database. As a secondary, complimentary database, use immudb to cross-check the integrity of your important data (by verifying checksums or comparing stored data values). A secondary database enables you to quickly use immudb without completely re-engineering your existing application. Use cases Integration with your DevOps ensures code security throughout the development and deployment process. Embed immudb into your Azure DevOps with Jenkins and Kubernetes. Use just Jenkins . Alternatively, integrate with GitLab or GitHub . Guarantee File Integrity of your critical data. Examples include storing your organization's sensitive financial, credit card transactional, invoices, contracts, educational transcripts, and other important data. Ensure integrity of your legal Documents and Invoices, contracts, forms, and your downloads and emails. Save your Internet of Things (IoT) sensor data as a failsafe plan for loss of data. Keep your investment guidelines or stock market data tamperproof for your investment bank or client financial portfolios. Store important log files to keep them tamperproof to meet regulations like PCI compliance. Protect medical data, test results, or recipes from alteration. Companies use immudb to protect credit card transactions and to secure processes by storing digital certificates and checksums.","title":"immudb explained"},{"location":"about/#immudb-explained","text":"","title":"immudb explained"},{"location":"about/#what-is-immudb","text":"immudb is database with built-in cryptographic proof and verification. It can track changes in sensitive data and the integrity of the history will be protected by the clients, without the need to trust the server. immudb can operate both as a key-value or relational (SQL) database. You can add new transactions, but deletion or modification of older transactions isn\u2019t allowed, thus making your data immutable. When a key record's value changes over time (such as a bank balance), you can get multiple instances with different timestamps to give you the complete history of that record's changes. You can store a variety of common data types, verification checksums, or JSON.","title":"What is immudb?"},{"location":"about/#what-makes-immudb-special","text":"Keep track of changes and audit them. Traditional database transactions and logs are hard to scale and are mutable, so there is no way to know for sure if your data has been compromised. immudb is immutable. You can add new versions of existing records, but never change or delete records. This lets you store critical data without fear of it being changed silently. Verify your data without sacrificing performance. Data stored in immudb is cryptographically coherent and verifiable, just like blockchains, but without all the complexity. Unlike blockchains, immudb can handle millions of transactions per second, and can be used both as a lightweight service or embedded in your application as a library. Protect yourself from supply-chain attacks. While Cyber Security is an important part of your organization\u2019s business plan, immudb provides another layer of security to ensure data integrity even in the event your perimeter is breached during an attack. Data cannot be deleted or modified once stored into immudb. Additions of new data are logged and auditable, enabling you to view any suspect additions made during the intrusion.","title":"What makes immudb special?"},{"location":"about/#how-can-i-use-immudb","text":"Depending on your use case, immudb might function as your application's primary or as a secondary database. As a secondary, complimentary database, use immudb to cross-check the integrity of your important data (by verifying checksums or comparing stored data values). A secondary database enables you to quickly use immudb without completely re-engineering your existing application.","title":"How can I use immudb?"},{"location":"about/#use-cases","text":"Integration with your DevOps ensures code security throughout the development and deployment process. Embed immudb into your Azure DevOps with Jenkins and Kubernetes. Use just Jenkins . Alternatively, integrate with GitLab or GitHub . Guarantee File Integrity of your critical data. Examples include storing your organization's sensitive financial, credit card transactional, invoices, contracts, educational transcripts, and other important data. Ensure integrity of your legal Documents and Invoices, contracts, forms, and your downloads and emails. Save your Internet of Things (IoT) sensor data as a failsafe plan for loss of data. Keep your investment guidelines or stock market data tamperproof for your investment bank or client financial portfolios. Store important log files to keep them tamperproof to meet regulations like PCI compliance. Protect medical data, test results, or recipes from alteration. Companies use immudb to protect credit card transactions and to secure processes by storing digital certificates and checksums.","title":"Use cases"},{"location":"concepts/","text":"Concepts Download the immudb short research paper to learn about the technical foundations of immudb. Consistency and state signature immudb consistency can be verified by any external client or auditor by calculating transaction state and comparing it with one returned from immudb. The state is represented by a digest, which is calculated as part of the transaction commit phase. Calculating such a value in an accumulative manner ensures that any change already made cannot be reversed. To increase security, immudb can be provisioned with a signing key to ensure non-repudiation of database states. The immudb server will subsequently sign the state on request from a client application. That means that an auditor or a third party client, for instance, could verify the authenticity of the returned current state. immuclient and immugw are shipped with auditor capabilities. To get the (signed) state in combination with the immuclient with auditor capabilities: immuclient audit-mode --audit-username {immudb-username} --audit-password {immudb-pw} --server-signing-pub-key {state-public-key} Check tamper-proof operations and running an auditor with immuclient paragraphs for additional details. Key value and SQL immudb can be used as a tamper-proof key value store or SQL database, with audit history capabilities. Within single immudb instance a user can have multiple databases of both types, it is even possible to have KV and SQL withing single database. Key value is a foundation layer for SQL, meaning that SQL is using key value store capabilities underneath. Check user quickstart for instructions on how to start working with KV or SQL. Operation modes immudb can be run as full database server with replicas or easily embedded as a lightweight database into application.","title":"Concepts"},{"location":"concepts/#concepts","text":"Download the immudb short research paper to learn about the technical foundations of immudb.","title":"Concepts"},{"location":"concepts/#consistency-and-state-signature","text":"immudb consistency can be verified by any external client or auditor by calculating transaction state and comparing it with one returned from immudb. The state is represented by a digest, which is calculated as part of the transaction commit phase. Calculating such a value in an accumulative manner ensures that any change already made cannot be reversed. To increase security, immudb can be provisioned with a signing key to ensure non-repudiation of database states. The immudb server will subsequently sign the state on request from a client application. That means that an auditor or a third party client, for instance, could verify the authenticity of the returned current state. immuclient and immugw are shipped with auditor capabilities. To get the (signed) state in combination with the immuclient with auditor capabilities: immuclient audit-mode --audit-username {immudb-username} --audit-password {immudb-pw} --server-signing-pub-key {state-public-key} Check tamper-proof operations and running an auditor with immuclient paragraphs for additional details.","title":"Consistency and state signature"},{"location":"concepts/#key-value-and-sql","text":"immudb can be used as a tamper-proof key value store or SQL database, with audit history capabilities. Within single immudb instance a user can have multiple databases of both types, it is even possible to have KV and SQL withing single database. Key value is a foundation layer for SQL, meaning that SQL is using key value store capabilities underneath. Check user quickstart for instructions on how to start working with KV or SQL.","title":"Key value and SQL"},{"location":"concepts/#operation-modes","text":"immudb can be run as full database server with replicas or easily embedded as a lightweight database into application.","title":"Operation modes"},{"location":"releasenotes/","text":"Release Notes immudb release notes immugw release notes","title":"Release Notes"},{"location":"releasenotes/#release-notes","text":"immudb release notes immugw release notes","title":"Release Notes"},{"location":"develop/additional/","text":"Additional Resources immudb SDKs examples Examples in multiple languages can be found at following links: immudb SDKs examples","title":"Additional Resources"},{"location":"develop/additional/#additional-resources","text":"","title":"Additional Resources"},{"location":"develop/additional/#immudb-sdks-examples","text":"Examples in multiple languages can be found at following links: immudb SDKs examples","title":"immudb SDKs examples"},{"location":"develop/apis/","text":"gRPC API If you would like to connect to immudb without using available SKDs, or SDK for your programming language is not yet available, here is the gRPC protobuffer protocol definition.","title":"gRPC API"},{"location":"develop/apis/#grpc-api","text":"If you would like to connect to immudb without using available SKDs, or SDK for your programming language is not yet available, here is the gRPC protobuffer protocol definition.","title":"gRPC API"},{"location":"develop/connection/","text":"Connecting With credentials The immudb server runs on port 3322 as the default. The code examples below illustrate how to connect your client to the server and authenticate using default options and the default username and password. You can modify defaults on the immudb server in immudb.toml in the config folder. :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions(). WithAddress(\"localhost\"). WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) // do amazing stuff } ::: ::: tab Python from grpc import RpcError from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) # database parameter is optional client.login(LOGIN, PASSWORD, database=DB) client.logout() # Bad login try: client.login(\"verybadlogin\", \"verybadpassword\") except RpcError as exception: print(exception.debug_error_string()) print(exception.details()) if __name__ == \"__main__\": main() ::: ::: tab Java Under the hood, during login , a token is being retrieved from the server, stored in memory and reused for subsequent operations. The state is internally used for doing verified operations (such as verifiedSet or verifiedGet). // Setting the \"store\" where the internal states are being persisted. FileImmuStateHolder stateHolder = FileImmuStateHolder.newBuilder() .withStatesFolder(\"immu_states\") .build(); // Creating an new ImmuClient instance. ImmuClient immuClient = ImmuClient.newBuilder() .withStateHolder(stateHolder) .withServerUrl(\"localhost\") .withServerPort(3322) .build(); // Login with default credentials. immuClient.login(\"immudb\", \"immudb\"); ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: With Mutual TLS To enable mutual authentication, a certificate chain must be provided to both the server and client. That will cause each to authenticate with the other simultaneously. In order to generate certs, use the generate.sh tool from immudb repository. It generates a list of folders containing certificates and private keys to set up a mTLS connection. ./generate.sh localhost mysecretpassword :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { // Folder cotaining MTLS certificates pathToMTLSFolder := \"./mtls\" opts := immudb.DefaultOptions(). WithAddress(\"localhost\"). WithPort(3322). WithMTLs(true). WithMTLsOptions( immudb.MTLsOptions{}. WithCertificate(pathToMTLSFolder + \"/4_client/certs/localhost.cert.pem\"). WithPkey(pathToMTLSFolder + \"/4_client/private/localhost.key.pem\"). WithClientCAs(pathToMTLSFolder + \"/2_intermediate/certs/ca-chain.cert.pem\"). WithServername(\"localhost\"), ) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) // do amazing stuff } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { const loginReq: Parameters.Login = { user: IMMUDB_USER, password: IMMUDB_PWD } const loginRes = await cl.login(loginReq) console.log('success: login:', loginRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: No Auth You also have the option to run immudb with authentication disabled. This method is depreciated and not recommended. $ ./immudb --auth=false However, without authentication enabled, it's not possible to connect to a server already configured with databases and user permissions. If a valid token is present, authentication is enabled by default. :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { client, err := immudb.NewImmuClient( immudb.DefaultOptions(). WithAddress(\"localhost\"). WithPort(3322). WithAuth(false), ) if err != nil { log.Fatal(err) } _, err = client.VerifiedSet(context.TODO(), []byte(`immudb`), []byte(`hello world`)) if err != nil { log.Fatal(err) } } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java FileImmuStateHolder stateHolder = FileImmuStateHolder.newBuilder() .withStatesFolder(\"immu_states\") .build(); ImmuClient immuClient = ImmuClient.newBuilder() .withStateHolder(stateHolder) .withServerUrl(\"localhost\") .withServerPort(3322) .withAuth(false) // No authentication is needed. .build(); try { immuClient.set(key, val); } catch (CorruptedDataException e) { // ... } ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Connecting"},{"location":"develop/connection/#connecting","text":"","title":"Connecting"},{"location":"develop/connection/#with-credentials","text":"The immudb server runs on port 3322 as the default. The code examples below illustrate how to connect your client to the server and authenticate using default options and the default username and password. You can modify defaults on the immudb server in immudb.toml in the config folder. :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions(). WithAddress(\"localhost\"). WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) // do amazing stuff } ::: ::: tab Python from grpc import RpcError from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) # database parameter is optional client.login(LOGIN, PASSWORD, database=DB) client.logout() # Bad login try: client.login(\"verybadlogin\", \"verybadpassword\") except RpcError as exception: print(exception.debug_error_string()) print(exception.details()) if __name__ == \"__main__\": main() ::: ::: tab Java Under the hood, during login , a token is being retrieved from the server, stored in memory and reused for subsequent operations. The state is internally used for doing verified operations (such as verifiedSet or verifiedGet). // Setting the \"store\" where the internal states are being persisted. FileImmuStateHolder stateHolder = FileImmuStateHolder.newBuilder() .withStatesFolder(\"immu_states\") .build(); // Creating an new ImmuClient instance. ImmuClient immuClient = ImmuClient.newBuilder() .withStateHolder(stateHolder) .withServerUrl(\"localhost\") .withServerPort(3322) .build(); // Login with default credentials. immuClient.login(\"immudb\", \"immudb\"); ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"With credentials"},{"location":"develop/connection/#with-mutual-tls","text":"To enable mutual authentication, a certificate chain must be provided to both the server and client. That will cause each to authenticate with the other simultaneously. In order to generate certs, use the generate.sh tool from immudb repository. It generates a list of folders containing certificates and private keys to set up a mTLS connection. ./generate.sh localhost mysecretpassword :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { // Folder cotaining MTLS certificates pathToMTLSFolder := \"./mtls\" opts := immudb.DefaultOptions(). WithAddress(\"localhost\"). WithPort(3322). WithMTLs(true). WithMTLsOptions( immudb.MTLsOptions{}. WithCertificate(pathToMTLSFolder + \"/4_client/certs/localhost.cert.pem\"). WithPkey(pathToMTLSFolder + \"/4_client/private/localhost.key.pem\"). WithClientCAs(pathToMTLSFolder + \"/2_intermediate/certs/ca-chain.cert.pem\"). WithServername(\"localhost\"), ) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) // do amazing stuff } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { const loginReq: Parameters.Login = { user: IMMUDB_USER, password: IMMUDB_PWD } const loginRes = await cl.login(loginReq) console.log('success: login:', loginRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"With Mutual TLS"},{"location":"develop/connection/#no-auth","text":"You also have the option to run immudb with authentication disabled. This method is depreciated and not recommended. $ ./immudb --auth=false However, without authentication enabled, it's not possible to connect to a server already configured with databases and user permissions. If a valid token is present, authentication is enabled by default. :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { client, err := immudb.NewImmuClient( immudb.DefaultOptions(). WithAddress(\"localhost\"). WithPort(3322). WithAuth(false), ) if err != nil { log.Fatal(err) } _, err = client.VerifiedSet(context.TODO(), []byte(`immudb`), []byte(`hello world`)) if err != nil { log.Fatal(err) } } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java FileImmuStateHolder stateHolder = FileImmuStateHolder.newBuilder() .withStatesFolder(\"immu_states\") .build(); ImmuClient immuClient = ImmuClient.newBuilder() .withStateHolder(stateHolder) .withServerUrl(\"localhost\") .withServerPort(3322) .withAuth(false) // No authentication is needed. .build(); try { immuClient.set(key, val); } catch (CorruptedDataException e) { // ... } ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"No Auth"},{"location":"develop/deleting/","text":"Deleting It's possible to achieve deletion by using the Delete function. It provides logical deletion, it means that it is not phisically deleted from db, but it's not possible to query it anymore after deletion. When immudb is used as an embedded store, it's possible to retrieve deleted entries. It's also possible to see deleted entries from the sdks using History endpoint, it will display if the entry was deleted. :::: tabs ::: tab Go tx, err = client.Set(ctx, []byte(\"1,2,3\"), []byte(\"3,2,1\")) if err != nil { log.Fatal(err) } fmt.Printf(\"Successfully committed tx %d\\n\", tx.Id) entry, err := client.Get(ctx, []byte(\"1,2,3\")) if err != nil { log.Fatal(err) } fmt.Printf(\"Successfully retrieved entry: %v\\n\", entry) _, err = client.Delete(ctx, []byte(\"1,2,3\")) if err != nil { log.Fatal(err) } //the following will raise an error with key not found _, err = client.Get(ctx, []byte(\"1,2,3\")) if err != nil { log.Fatal(err) } ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python from immudb import ImmudbClient from immudb.datatypes import DeleteKeysRequest URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.set(b\"immu\", b\"immudb-not-rulezz\") print(client.get(b\"immu\")) # b\"immudb-not-rulezz\" deleteRequest = DeleteKeysRequest(keys = [b\"immu\"]) client.delete(deleteRequest) print(client.get(b\"immu\")) # None if __name__ == \"__main__\": main() ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Deleting"},{"location":"develop/deleting/#deleting","text":"It's possible to achieve deletion by using the Delete function. It provides logical deletion, it means that it is not phisically deleted from db, but it's not possible to query it anymore after deletion. When immudb is used as an embedded store, it's possible to retrieve deleted entries. It's also possible to see deleted entries from the sdks using History endpoint, it will display if the entry was deleted. :::: tabs ::: tab Go tx, err = client.Set(ctx, []byte(\"1,2,3\"), []byte(\"3,2,1\")) if err != nil { log.Fatal(err) } fmt.Printf(\"Successfully committed tx %d\\n\", tx.Id) entry, err := client.Get(ctx, []byte(\"1,2,3\")) if err != nil { log.Fatal(err) } fmt.Printf(\"Successfully retrieved entry: %v\\n\", entry) _, err = client.Delete(ctx, []byte(\"1,2,3\")) if err != nil { log.Fatal(err) } //the following will raise an error with key not found _, err = client.Get(ctx, []byte(\"1,2,3\")) if err != nil { log.Fatal(err) } ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python from immudb import ImmudbClient from immudb.datatypes import DeleteKeysRequest URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.set(b\"immu\", b\"immudb-not-rulezz\") print(client.get(b\"immu\")) # b\"immudb-not-rulezz\" deleteRequest = DeleteKeysRequest(keys = [b\"immu\"]) client.delete(deleteRequest) print(client.get(b\"immu\")) # None if __name__ == \"__main__\": main() ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Deleting"},{"location":"develop/embedding/","text":"Embedding immudb in your application Using the Go client SDK means you are connecting to a immudb database server. There are cases where you don't want a separate server but embed immudb directly in the same application process, as a library. immudb already provides an embeddable key-value store in the embedded package. The following example shows how to create or open a store, write some data and read it back. package main import ( \"fmt\" \"log\" \"github.com/codenotary/immudb/embedded/store\" ) func handleErr(err error) { if err != nil { log.Fatal(err) } } func main() { // create/open immudb store at specified path st, err := store.Open(\"data\", store.DefaultOptions()) handleErr(err) // close the store to free resources defer st.Close() // create a transaction tx, err := st.NewTx() handleErr(err) // ensure tx is closed (it won't affect committed tx) defer tx.Cancel() // write key-value pair into the tx context, no change will be applied yet err = tx.Set([]byte(\"hello\"), nil, []byte(\"immutable-world!\")) handleErr(err) // transaction is committed and changes are applied hdr, err := tx.Commit() handleErr(err) fmt.Printf(\"tx %d successfully committed\\n\", hdr.ID) // fetch the latest entry of a key // dsue to performance considerations, only metadata, hash, and size are returned at first valRef, err := st.Get([]byte(\"hello\")) handleErr(err) // read the actual value val, err := valRef.Resolve() handleErr(err) fmt.Printf(\"key '%s' = '%s' found at tx %d (%d key-updates)\\n\", []byte(\"hello\"), val, valRef.Tx(), valRef.HC()) }","title":"Embedding immudb in your application"},{"location":"develop/embedding/#embedding-immudb-in-your-application","text":"Using the Go client SDK means you are connecting to a immudb database server. There are cases where you don't want a separate server but embed immudb directly in the same application process, as a library. immudb already provides an embeddable key-value store in the embedded package. The following example shows how to create or open a store, write some data and read it back. package main import ( \"fmt\" \"log\" \"github.com/codenotary/immudb/embedded/store\" ) func handleErr(err error) { if err != nil { log.Fatal(err) } } func main() { // create/open immudb store at specified path st, err := store.Open(\"data\", store.DefaultOptions()) handleErr(err) // close the store to free resources defer st.Close() // create a transaction tx, err := st.NewTx() handleErr(err) // ensure tx is closed (it won't affect committed tx) defer tx.Cancel() // write key-value pair into the tx context, no change will be applied yet err = tx.Set([]byte(\"hello\"), nil, []byte(\"immutable-world!\")) handleErr(err) // transaction is committed and changes are applied hdr, err := tx.Commit() handleErr(err) fmt.Printf(\"tx %d successfully committed\\n\", hdr.ID) // fetch the latest entry of a key // dsue to performance considerations, only metadata, hash, and size are returned at first valRef, err := st.Get([]byte(\"hello\")) handleErr(err) // read the actual value val, err := valRef.Resolve() handleErr(err) fmt.Printf(\"key '%s' = '%s' found at tx %d (%d key-updates)\\n\", []byte(\"hello\"), val, valRef.Tx(), valRef.HC()) }","title":"Embedding immudb in your application"},{"location":"develop/expiration/","text":"Data Expiration It's possible to achieve data expiration by using the ExpirableSet function. It provides logical deletion, it means that it is not phisically deleted from db, but it's not possible to query it anymore after deletion. :::: tabs ::: tab Go _, err = client.ExpirableSet(ctx, []byte(\"expirableKey\"), []byte(\"expirableValue\"), time.Now()) if err != nil { log.Fatal(err) } //the following will raise an error with key not found _, err = client.Get(ctx, []byte(\"expirableKey\")) if err == nil || !strings.Contains(err.Error(), \"key not found\") { log.Fatalf(\"expecting key not found error: %v\", err) } ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python from immudb import ImmudbClient from datetime import datetime, timedelta import time URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.expireableSet(b\"TEST\", b\"test\", datetime.now() + timedelta(seconds=3)) print(client.get(b\"TEST\")) # b\"test\" time.sleep(4) try: print(client.get(b\"TEST\")) except: pass # Key not found, because it expires, raises Exception if __name__ == \"__main__\": main() ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Data Expiration"},{"location":"develop/expiration/#data-expiration","text":"It's possible to achieve data expiration by using the ExpirableSet function. It provides logical deletion, it means that it is not phisically deleted from db, but it's not possible to query it anymore after deletion. :::: tabs ::: tab Go _, err = client.ExpirableSet(ctx, []byte(\"expirableKey\"), []byte(\"expirableValue\"), time.Now()) if err != nil { log.Fatal(err) } //the following will raise an error with key not found _, err = client.Get(ctx, []byte(\"expirableKey\")) if err == nil || !strings.Contains(err.Error(), \"key not found\") { log.Fatalf(\"expecting key not found error: %v\", err) } ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python from immudb import ImmudbClient from datetime import datetime, timedelta import time URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.expireableSet(b\"TEST\", b\"test\", datetime.now() + timedelta(seconds=3)) print(client.get(b\"TEST\")) # b\"test\" time.sleep(4) try: print(client.get(b\"TEST\")) except: pass # Key not found, because it expires, raises Exception if __name__ == \"__main__\": main() ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Data Expiration"},{"location":"develop/history/","text":"Queries and history The fundamental property of immudb is that it's an append-only database. This means that an update does not change an existing record. Instead, it is a new insert of the same key with a new value . It's possible to retrieve all the values for a particular key with the history command. History accepts the following parameters: * Key : a key of an item * Offset : the starting index (excluded from the search). Optional * Limit : maximum returned items. Optional * Desc : items are returned in reverse order. Optional * SinceTx : immudb will wait that the transaction specified by SinceTx is processed. Optional :::: tabs ::: tab Go client.Set(ctx, []byte(`hello`), []byte(`immutable world`)) client.Set(ctx, []byte(`hello`), []byte(`immudb`)) req := &schema.HistoryRequest{ Key: []byte(`hello`), } entries, err := client.History(ctx, req) if err != nil { log.Fatal(err) } fmt.Printf(\"Successfully retrieved %d entries for key %s\\n\", len(entries), req.Key) ::: ::: tab Java try { immuClient.set(\"hello\", value1); immuClient.set(\"hello\", value2); } catch (CorruptedDataException e) { // ... } List<KV> historyResponse1 = immuClient.history(\"hello\", 10, 0, false, 1); Note that, similar with many other methods, history method is overloaded to allow different kinds/set of parameters. ::: ::: tab Python Python immudb sdk currently doesn't support SinceTx parameter from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.set(b'test', b'1') client.set(b'test', b'2') client.set(b'test', b'3') history = client.history(b'test', 0, 100, True) # List[immudb.datatypes.historyResponseItem] responseItemFirst = history[0] print(responseItemFirst.key) # Entry key (b'test') print(responseItemFirst.value) # Entry value (b'3') print(responseItemFirst.tx) # Transaction id responseItemThird = history[2] print(responseItemThird.key) # Entry key (b'test') print(responseItemThird.value) # Entry value (b'1') print(responseItemThird.tx) # Transaction id if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const key = 'hello' await cl.set({ key, value: 'immutable world' }) await cl.set({ key, value: 'immudb' }) const historyReq: Parameters.History = { key } const historyRes = cl.history(historyReq) console.log('success: history', historyRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Counting Counting entries is not supported at the moment. :::: tabs ::: tab Go This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Go sdk github project ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Scan The scan command is used to iterate over the collection of elements present in the currently selected database. Scan accepts the following parameters: Prefix : prefix. If not provided all keys will be involved. Optional SeekKey : initial key for the first entry in the iteration. Optional Desc : DESC or ASC sorting order. Optional Limit : maximum returned items. Optional SinceTx : immudb will wait that the transaction provided by SinceTx be processed. Optional NoWait : Default false. When true scan doesn't wait for the index to be fully generated and returns the last indexed value. Optional To gain speed it's possible to specify noWait=true . The control will be returned to the caller immediately, without waiting for the indexing to complete. When noWait is used, keep in mind that the returned data may not be yet up to date with the inserted data, as the indexing might not have completed. :::: tabs ::: tab Go An ordinary scan command and a reversed one. client.Set(ctx, []byte(`aaa`), []byte(`item1`)) client.Set(ctx, []byte(`bbb`), []byte(`item2`)) client.Set(ctx, []byte(`abc`),[]byte(`item3`)) scanReq := &schema.ScanRequest{ Prefix: []byte(`a`), } list, err := client.Scan(ctx, scanReq) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", list) scanReq1 := &schema.ScanRequest{ SeekKey: []byte{0xFF}, Prefix: []byte(`a`), Desc: true, } list, err = client.Scan(ctx, scanReq1) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", list) // scan on all key values on the current database, with a fresh snapshot scanReq2 := &schema.ScanRequest{ SeekKey: []byte{0xFF}, Desc: true, SinceTx: math.MaxUint64, } list, err = client.Scan(ctx, scanReq2) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", list) ::: ::: tab Java byte[] value1 = {0, 1, 2, 3}; byte[] value2 = {4, 5, 6, 7}; try { immuClient.set(\"scan1\", value1); immuClient.set(\"scan2\", value2); } catch (CorruptedDataException e) { // ... } // Example of using scan(prefix, sinceTxId, limit, desc). List<KV> scanResult = immuClient.scan(\"scan\", 1, 5, false); // We expect two entries in the result. scan is an overloaded method, therefore multiple flavours of it with different parameter options exist. ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) toSet = { b\"aaa\": b'1', b'bbb': b'2', b'ccc': b'3', b'acc': b'1', b'aac': b'2', b'aac:test1': b'3', b'aac:test2': b'1', b'aac:xxx:test': b'2' } client.setAll(toSet) result = client.scan(b'', b'', True, 100) # All entries print(result) result = client.scan(b'', b'aac', True, 100) # All entries with prefix 'aac' including 'aac' print(result) # Seek key example (allows retrieve entries in proper chunks): result = client.scan(b'', b'', False, 3) while result: for item, value in result.items(): print(\"SEEK\", item, value) lastKey = list(result.keys())[-1] result = client.scan(lastKey, b'', False, 3) if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) await cl.set({ key: 'aaa', value: 'item1' }) await cl.set({ key: 'bbb', value: 'item2' }) await cl.set({ key: 'abc', value: 'item3' }) const scanReq: Parameters.Scan = { prefix: 'a', desc: false, limit: 0, sincetx: 0 } const scanRes = await cl.scan(scanReq) console.log('success: scan', scanRes) const scanReq1: Parameters.Scan = { prefix: 'a', desc: true, limit: 0, sincetx: 0 } const scanRes1 = await cl.scan(scanReq1) console.log('success: scan', scanRes1) })() Example with an offset: import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) await cl.set({ key: 'aaa', value: 'item1' }) await cl.set({ key: 'bbb', value: 'item2' }) await cl.set({ key: 'abc', value: 'item3' }) const scanReq: Parameters.Scan = { seekkey: '', prefix: '', desc: true, limit: 0, sincetx: 0 } const scanRes = await cl.scan(scanReq) console.log('success: scan', scanRes) const scanReq1: Parameters.Scan = { seekkey: 'bbb', prefix: '', desc: true, limit: 0, sincetx: 0 } const scanRes1 = await cl.scan(scanReq1) console.log('success: scan', scanRes1) const scanReq2: Parameters.Scan = { seekkey: 'b', prefix: 'b', desc: true, limit: 0, sincetx: 0 } const scanRes2 = await cl.scan(scanReq2) console.log('success: scan', scanRes2) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: References SetReference is like a \"tag\" operation. It appends a reference on a key/value element. As a consequence, when we retrieve that reference with a Get or VerifiedGet the value retrieved will be the original value associated with the original key. Its VerifiedReference counterpart is the same except that it also produces the inclusion and consistency proofs. SetReference and VerifiedSetReference :::: tabs ::: tab Go _, err = client.Set(ctx, []byte(`firstKey`),[]byte(`firstValue`)) if err != nil { log.Fatal(err) } reference, err := client.SetReference(ctx, []byte(`myTag`), []byte(`firstKey`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", reference) firstItem, err := client.Get(ctx, []byte(`myTag`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", firstItem) Example with verifications _, err = client.Set(ctx, []byte(`secondKey`),[]byte(`secondValue`)) if err != nil { log.Fatal(err) } reference, err = client.VerifiedSetReference(ctx, []byte(`mySecondTag`), []byte(`secondKey`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", reference) secondItem, err := client.Get(ctx, []byte(`mySecondTag`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", secondItem) ::: ::: tab Java byte[] key = \"testRef\".getBytes(StandardCharsets.UTF_8); byte[] val = \"abc\".getBytes(StandardCharsets.UTF_8); TxMetadata txMd = null; try { txMd = immuClient.set(key, val); } catch (CorruptedDataException e) { // ... } byte[] ref1Key = \"ref1_to_testRef\".getBytes(StandardCharsets.UTF_8); byte[] ref2Key = \"ref2_to_testRef\".getBytes(StandardCharsets.UTF_8); try { txMd = immuClient.setReference(ref1Key, key); } catch (CorruptedDataException e) { // ... } try { txMd = immuClient.verifiedSetReference(ref2Key, key); } catch (VerificationException e) { // ... } ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.verifiedSet(b'x', b'1') client.verifiedSet(b'y', b'1') retrieved = client.verifiedGet(b'x') print(retrieved.refkey) # Entry reference key (None) client.verifiedSetReference(b'x', b'reference1') client.setReference(b'x', b'reference2') client.setReference(b'y', b'reference2') client.verifiedSet(b'y', b'2') retrieved = client.verifiedGet(b'reference1') print(retrieved.key) # Entry key (b'x') print(retrieved.refkey) # Entry reference key (b'reference1') print(retrieved.verified) # Entry verification status (True) retrieved = client.verifiedGet(b'reference2') print(retrieved.key) # Entry key (b'y') print(retrieved.refkey) # Entry reference key (b'reference2') print(retrieved.verified) # Entry verification status (True) print(retrieved.value) # Entry value (b'3') retrieved = client.verifiedGet(b'x') print(retrieved.key) # Entry key (b'x') print(retrieved.refkey) # Entry reference key (None) print(retrieved.verified) # Entry verification status (True) retrieved = client.get(b'reference2') print(retrieved.key) # Entry key (b'y') if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const setReq: Parameters.Set = { key: 'firstKey', value: 'firstValue' } await cl.set(setReq) const referenceReq: Parameters.SetReference = { key: 'myTag', referencedKey: 'firstKey' } const referenceRes = await cl.setReference(referenceReq) console.log('success: setReference', referenceRes) const getReq: Parameters.Get = { key: 'myTag' } const getRes = await cl.get(getReq) console.log('success: get by reference', getRes) })() Example with verifications import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const setReq: Parameters.Set = { key: 'firstKey', value: 'firstValue' } await cl.set(setReq) const verifiedReferenceReq: Parameters.SetReference = { key: 'myTag', referencedKey: 'firstKey' } const verifiedReferenceRes = await cl.verifiedSetReference(verifiedReferenceReq) console.log('success: verifiedSetReference', verifiedReferenceRes) const getReq: Parameters.Get = { key: 'myTag' } const getRes = await cl.get(getReq) console.log('success: get by reference', getRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: GetReference and VerifiedGetReference When reference is resolved with get or verifiedGet in case of multiples equals references the last reference is returned. :::: tabs ::: tab Go _, err = client.Set(ctx, []byte(`secondKey`),[]byte(`secondValue`)) if err != nil { log.Fatal(err) } _, err = client.Set(ctx, []byte(`secondKey`),[]byte(`thirdValue`)) if err != nil { log.Fatal(err) } reference, err = client.VerifiedSetReference(ctx, []byte(`myThirdTag`), []byte(`secondKey`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", reference) thirdItem, err := client.Get(ctx, []byte(`myThirdTag`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", thirdItem) ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.verifiedSet(b'x', b'1') client.verifiedSet(b'y', b'1') retrieved = client.verifiedGet(b'x') print(retrieved.refkey) # Entry reference key (None) client.verifiedSetReference(b'x', b'reference1') client.setReference(b'x', b'reference2') client.setReference(b'y', b'reference2') client.verifiedSet(b'y', b'2') retrieved = client.verifiedGet(b'reference1') print(retrieved.key) # Entry key (b'x') print(retrieved.refkey) # Entry reference key (b'reference1') print(retrieved.verified) # Entry verification status (True) retrieved = client.verifiedGet(b'reference2') print(retrieved.key) # Entry key (b'y') print(retrieved.refkey) # Entry reference key (b'reference2') print(retrieved.verified) # Entry verification status (True) print(retrieved.value) # Entry value (b'3') retrieved = client.verifiedGet(b'x') print(retrieved.key) # Entry key (b'x') print(retrieved.refkey) # Entry reference key (None) print(retrieved.verified) # Entry verification status (True) retrieved = client.get(b'reference2') print(retrieved.key) # Entry key (b'y') if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const setReq: Parameters.Set = { key: 'firstKey', value: 'firstValue' } await cl.set(setReq) const setReq1: Parameters.Set = { key: 'secondKey', value: 'secondValue' } await cl.set(setReq1) const verifiedReferenceReq: Parameters.SetReference = { key: 'myTag', referencedKey: 'firstKey' } await cl.verifiedSetReference(verifiedReferenceReq) const verifiedReferenceReq1: Parameters.SetReference = { key: 'myTag', referencedKey: 'secondKey' } await cl.verifiedSetReference(verifiedReferenceReq1) const getReq: Parameters.Get = { key: 'myTag' } const getSecondItemRes = await cl.get(getReq) console.log('success: get by second reference', getSecondItemRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Resolving reference with transaction id It's possible to bind a reference to a key on a specific transaction using SetReferenceAt and VerifiedSetReferenceAt :::: tabs ::: tab Go meta, err := client.Set(ctx, []byte(`secondKey`),[]byte(`secondValue`)) if err != nil { log.Fatal(err) } _ , err = client.Set(ctx, []byte(`secondKey`),[]byte(`thirdValue`)) if err != nil { log.Fatal(err) } reference, err = client.VerifiedSetReferenceAt(ctx, []byte(`myThirdTag`), []byte(`secondKey`), meta.Id ) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", reference) thirdItem, err := client.Get(ctx, []byte(`myThirdTag`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", thirdItem) ::: ::: tab Java byte[] key = \"testRef\".getBytes(StandardCharsets.UTF_8); byte[] val = \"abc\".getBytes(StandardCharsets.UTF_8); byte[] refKey = \"ref1_to_testRef\".getBytes(StandardCharsets.UTF_8); TxMetadata setTxMd = null; try { txMd = immuClient.set(key, val); } catch (CorruptedDataException e) { // ... } try { immuClient.setReferenceAt(refKey, key, txMd.id); } catch (CorruptedDataException e) { // ... } try { txMd = immuClient.verifiedSetReferenceAt(refKey, key, txMd.id); } catch (VerificationException e) { // ... } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const { id } = await cl.set({ key: 'firstKey', value: 'firstValue' }) await cl.set({ key: 'firstKey', value: 'secondValue' }) const verifiedSetReferenceAtReq: Parameters.VerifiedSetReferenceAt = { key: 'myFirstTag', referencedKey: 'firstKey', attx: id } const verifiedSetReferenceAtRes = await cl.verifiedSetReferenceAt(verifiedSetReferenceAtReq) console.log('success: verifiedSetReferenceAt', verifiedSetReferenceAtRes) const getSecondItemRes = await cl.get({ key: 'myFirstTag' }) console.log('success: get second item by reference', getSecondItemRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Queries and history"},{"location":"develop/history/#queries-and-history","text":"The fundamental property of immudb is that it's an append-only database. This means that an update does not change an existing record. Instead, it is a new insert of the same key with a new value . It's possible to retrieve all the values for a particular key with the history command. History accepts the following parameters: * Key : a key of an item * Offset : the starting index (excluded from the search). Optional * Limit : maximum returned items. Optional * Desc : items are returned in reverse order. Optional * SinceTx : immudb will wait that the transaction specified by SinceTx is processed. Optional :::: tabs ::: tab Go client.Set(ctx, []byte(`hello`), []byte(`immutable world`)) client.Set(ctx, []byte(`hello`), []byte(`immudb`)) req := &schema.HistoryRequest{ Key: []byte(`hello`), } entries, err := client.History(ctx, req) if err != nil { log.Fatal(err) } fmt.Printf(\"Successfully retrieved %d entries for key %s\\n\", len(entries), req.Key) ::: ::: tab Java try { immuClient.set(\"hello\", value1); immuClient.set(\"hello\", value2); } catch (CorruptedDataException e) { // ... } List<KV> historyResponse1 = immuClient.history(\"hello\", 10, 0, false, 1); Note that, similar with many other methods, history method is overloaded to allow different kinds/set of parameters. ::: ::: tab Python Python immudb sdk currently doesn't support SinceTx parameter from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.set(b'test', b'1') client.set(b'test', b'2') client.set(b'test', b'3') history = client.history(b'test', 0, 100, True) # List[immudb.datatypes.historyResponseItem] responseItemFirst = history[0] print(responseItemFirst.key) # Entry key (b'test') print(responseItemFirst.value) # Entry value (b'3') print(responseItemFirst.tx) # Transaction id responseItemThird = history[2] print(responseItemThird.key) # Entry key (b'test') print(responseItemThird.value) # Entry value (b'1') print(responseItemThird.tx) # Transaction id if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const key = 'hello' await cl.set({ key, value: 'immutable world' }) await cl.set({ key, value: 'immudb' }) const historyReq: Parameters.History = { key } const historyRes = cl.history(historyReq) console.log('success: history', historyRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Queries and history"},{"location":"develop/history/#counting","text":"Counting entries is not supported at the moment. :::: tabs ::: tab Go This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Go sdk github project ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Counting"},{"location":"develop/history/#scan","text":"The scan command is used to iterate over the collection of elements present in the currently selected database. Scan accepts the following parameters: Prefix : prefix. If not provided all keys will be involved. Optional SeekKey : initial key for the first entry in the iteration. Optional Desc : DESC or ASC sorting order. Optional Limit : maximum returned items. Optional SinceTx : immudb will wait that the transaction provided by SinceTx be processed. Optional NoWait : Default false. When true scan doesn't wait for the index to be fully generated and returns the last indexed value. Optional To gain speed it's possible to specify noWait=true . The control will be returned to the caller immediately, without waiting for the indexing to complete. When noWait is used, keep in mind that the returned data may not be yet up to date with the inserted data, as the indexing might not have completed. :::: tabs ::: tab Go An ordinary scan command and a reversed one. client.Set(ctx, []byte(`aaa`), []byte(`item1`)) client.Set(ctx, []byte(`bbb`), []byte(`item2`)) client.Set(ctx, []byte(`abc`),[]byte(`item3`)) scanReq := &schema.ScanRequest{ Prefix: []byte(`a`), } list, err := client.Scan(ctx, scanReq) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", list) scanReq1 := &schema.ScanRequest{ SeekKey: []byte{0xFF}, Prefix: []byte(`a`), Desc: true, } list, err = client.Scan(ctx, scanReq1) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", list) // scan on all key values on the current database, with a fresh snapshot scanReq2 := &schema.ScanRequest{ SeekKey: []byte{0xFF}, Desc: true, SinceTx: math.MaxUint64, } list, err = client.Scan(ctx, scanReq2) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", list) ::: ::: tab Java byte[] value1 = {0, 1, 2, 3}; byte[] value2 = {4, 5, 6, 7}; try { immuClient.set(\"scan1\", value1); immuClient.set(\"scan2\", value2); } catch (CorruptedDataException e) { // ... } // Example of using scan(prefix, sinceTxId, limit, desc). List<KV> scanResult = immuClient.scan(\"scan\", 1, 5, false); // We expect two entries in the result. scan is an overloaded method, therefore multiple flavours of it with different parameter options exist. ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) toSet = { b\"aaa\": b'1', b'bbb': b'2', b'ccc': b'3', b'acc': b'1', b'aac': b'2', b'aac:test1': b'3', b'aac:test2': b'1', b'aac:xxx:test': b'2' } client.setAll(toSet) result = client.scan(b'', b'', True, 100) # All entries print(result) result = client.scan(b'', b'aac', True, 100) # All entries with prefix 'aac' including 'aac' print(result) # Seek key example (allows retrieve entries in proper chunks): result = client.scan(b'', b'', False, 3) while result: for item, value in result.items(): print(\"SEEK\", item, value) lastKey = list(result.keys())[-1] result = client.scan(lastKey, b'', False, 3) if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) await cl.set({ key: 'aaa', value: 'item1' }) await cl.set({ key: 'bbb', value: 'item2' }) await cl.set({ key: 'abc', value: 'item3' }) const scanReq: Parameters.Scan = { prefix: 'a', desc: false, limit: 0, sincetx: 0 } const scanRes = await cl.scan(scanReq) console.log('success: scan', scanRes) const scanReq1: Parameters.Scan = { prefix: 'a', desc: true, limit: 0, sincetx: 0 } const scanRes1 = await cl.scan(scanReq1) console.log('success: scan', scanRes1) })() Example with an offset: import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) await cl.set({ key: 'aaa', value: 'item1' }) await cl.set({ key: 'bbb', value: 'item2' }) await cl.set({ key: 'abc', value: 'item3' }) const scanReq: Parameters.Scan = { seekkey: '', prefix: '', desc: true, limit: 0, sincetx: 0 } const scanRes = await cl.scan(scanReq) console.log('success: scan', scanRes) const scanReq1: Parameters.Scan = { seekkey: 'bbb', prefix: '', desc: true, limit: 0, sincetx: 0 } const scanRes1 = await cl.scan(scanReq1) console.log('success: scan', scanRes1) const scanReq2: Parameters.Scan = { seekkey: 'b', prefix: 'b', desc: true, limit: 0, sincetx: 0 } const scanRes2 = await cl.scan(scanReq2) console.log('success: scan', scanRes2) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Scan"},{"location":"develop/history/#references","text":"SetReference is like a \"tag\" operation. It appends a reference on a key/value element. As a consequence, when we retrieve that reference with a Get or VerifiedGet the value retrieved will be the original value associated with the original key. Its VerifiedReference counterpart is the same except that it also produces the inclusion and consistency proofs.","title":"References"},{"location":"develop/history/#setreference-and-verifiedsetreference","text":":::: tabs ::: tab Go _, err = client.Set(ctx, []byte(`firstKey`),[]byte(`firstValue`)) if err != nil { log.Fatal(err) } reference, err := client.SetReference(ctx, []byte(`myTag`), []byte(`firstKey`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", reference) firstItem, err := client.Get(ctx, []byte(`myTag`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", firstItem) Example with verifications _, err = client.Set(ctx, []byte(`secondKey`),[]byte(`secondValue`)) if err != nil { log.Fatal(err) } reference, err = client.VerifiedSetReference(ctx, []byte(`mySecondTag`), []byte(`secondKey`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", reference) secondItem, err := client.Get(ctx, []byte(`mySecondTag`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", secondItem) ::: ::: tab Java byte[] key = \"testRef\".getBytes(StandardCharsets.UTF_8); byte[] val = \"abc\".getBytes(StandardCharsets.UTF_8); TxMetadata txMd = null; try { txMd = immuClient.set(key, val); } catch (CorruptedDataException e) { // ... } byte[] ref1Key = \"ref1_to_testRef\".getBytes(StandardCharsets.UTF_8); byte[] ref2Key = \"ref2_to_testRef\".getBytes(StandardCharsets.UTF_8); try { txMd = immuClient.setReference(ref1Key, key); } catch (CorruptedDataException e) { // ... } try { txMd = immuClient.verifiedSetReference(ref2Key, key); } catch (VerificationException e) { // ... } ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.verifiedSet(b'x', b'1') client.verifiedSet(b'y', b'1') retrieved = client.verifiedGet(b'x') print(retrieved.refkey) # Entry reference key (None) client.verifiedSetReference(b'x', b'reference1') client.setReference(b'x', b'reference2') client.setReference(b'y', b'reference2') client.verifiedSet(b'y', b'2') retrieved = client.verifiedGet(b'reference1') print(retrieved.key) # Entry key (b'x') print(retrieved.refkey) # Entry reference key (b'reference1') print(retrieved.verified) # Entry verification status (True) retrieved = client.verifiedGet(b'reference2') print(retrieved.key) # Entry key (b'y') print(retrieved.refkey) # Entry reference key (b'reference2') print(retrieved.verified) # Entry verification status (True) print(retrieved.value) # Entry value (b'3') retrieved = client.verifiedGet(b'x') print(retrieved.key) # Entry key (b'x') print(retrieved.refkey) # Entry reference key (None) print(retrieved.verified) # Entry verification status (True) retrieved = client.get(b'reference2') print(retrieved.key) # Entry key (b'y') if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const setReq: Parameters.Set = { key: 'firstKey', value: 'firstValue' } await cl.set(setReq) const referenceReq: Parameters.SetReference = { key: 'myTag', referencedKey: 'firstKey' } const referenceRes = await cl.setReference(referenceReq) console.log('success: setReference', referenceRes) const getReq: Parameters.Get = { key: 'myTag' } const getRes = await cl.get(getReq) console.log('success: get by reference', getRes) })() Example with verifications import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const setReq: Parameters.Set = { key: 'firstKey', value: 'firstValue' } await cl.set(setReq) const verifiedReferenceReq: Parameters.SetReference = { key: 'myTag', referencedKey: 'firstKey' } const verifiedReferenceRes = await cl.verifiedSetReference(verifiedReferenceReq) console.log('success: verifiedSetReference', verifiedReferenceRes) const getReq: Parameters.Get = { key: 'myTag' } const getRes = await cl.get(getReq) console.log('success: get by reference', getRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"SetReference and VerifiedSetReference"},{"location":"develop/history/#getreference-and-verifiedgetreference","text":"When reference is resolved with get or verifiedGet in case of multiples equals references the last reference is returned. :::: tabs ::: tab Go _, err = client.Set(ctx, []byte(`secondKey`),[]byte(`secondValue`)) if err != nil { log.Fatal(err) } _, err = client.Set(ctx, []byte(`secondKey`),[]byte(`thirdValue`)) if err != nil { log.Fatal(err) } reference, err = client.VerifiedSetReference(ctx, []byte(`myThirdTag`), []byte(`secondKey`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", reference) thirdItem, err := client.Get(ctx, []byte(`myThirdTag`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", thirdItem) ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.verifiedSet(b'x', b'1') client.verifiedSet(b'y', b'1') retrieved = client.verifiedGet(b'x') print(retrieved.refkey) # Entry reference key (None) client.verifiedSetReference(b'x', b'reference1') client.setReference(b'x', b'reference2') client.setReference(b'y', b'reference2') client.verifiedSet(b'y', b'2') retrieved = client.verifiedGet(b'reference1') print(retrieved.key) # Entry key (b'x') print(retrieved.refkey) # Entry reference key (b'reference1') print(retrieved.verified) # Entry verification status (True) retrieved = client.verifiedGet(b'reference2') print(retrieved.key) # Entry key (b'y') print(retrieved.refkey) # Entry reference key (b'reference2') print(retrieved.verified) # Entry verification status (True) print(retrieved.value) # Entry value (b'3') retrieved = client.verifiedGet(b'x') print(retrieved.key) # Entry key (b'x') print(retrieved.refkey) # Entry reference key (None) print(retrieved.verified) # Entry verification status (True) retrieved = client.get(b'reference2') print(retrieved.key) # Entry key (b'y') if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const setReq: Parameters.Set = { key: 'firstKey', value: 'firstValue' } await cl.set(setReq) const setReq1: Parameters.Set = { key: 'secondKey', value: 'secondValue' } await cl.set(setReq1) const verifiedReferenceReq: Parameters.SetReference = { key: 'myTag', referencedKey: 'firstKey' } await cl.verifiedSetReference(verifiedReferenceReq) const verifiedReferenceReq1: Parameters.SetReference = { key: 'myTag', referencedKey: 'secondKey' } await cl.verifiedSetReference(verifiedReferenceReq1) const getReq: Parameters.Get = { key: 'myTag' } const getSecondItemRes = await cl.get(getReq) console.log('success: get by second reference', getSecondItemRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"GetReference and VerifiedGetReference"},{"location":"develop/history/#resolving-reference-with-transaction-id","text":"It's possible to bind a reference to a key on a specific transaction using SetReferenceAt and VerifiedSetReferenceAt :::: tabs ::: tab Go meta, err := client.Set(ctx, []byte(`secondKey`),[]byte(`secondValue`)) if err != nil { log.Fatal(err) } _ , err = client.Set(ctx, []byte(`secondKey`),[]byte(`thirdValue`)) if err != nil { log.Fatal(err) } reference, err = client.VerifiedSetReferenceAt(ctx, []byte(`myThirdTag`), []byte(`secondKey`), meta.Id ) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", reference) thirdItem, err := client.Get(ctx, []byte(`myThirdTag`)) if err != nil { log.Fatal(err) } fmt.Printf(\"%v\\n\", thirdItem) ::: ::: tab Java byte[] key = \"testRef\".getBytes(StandardCharsets.UTF_8); byte[] val = \"abc\".getBytes(StandardCharsets.UTF_8); byte[] refKey = \"ref1_to_testRef\".getBytes(StandardCharsets.UTF_8); TxMetadata setTxMd = null; try { txMd = immuClient.set(key, val); } catch (CorruptedDataException e) { // ... } try { immuClient.setReferenceAt(refKey, key, txMd.id); } catch (CorruptedDataException e) { // ... } try { txMd = immuClient.verifiedSetReferenceAt(refKey, key, txMd.id); } catch (VerificationException e) { // ... } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const { id } = await cl.set({ key: 'firstKey', value: 'firstValue' }) await cl.set({ key: 'firstKey', value: 'secondValue' }) const verifiedSetReferenceAtReq: Parameters.VerifiedSetReferenceAt = { key: 'myFirstTag', referencedKey: 'firstKey', attx: id } const verifiedSetReferenceAtRes = await cl.verifiedSetReferenceAt(verifiedSetReferenceAtReq) console.log('success: verifiedSetReferenceAt', verifiedSetReferenceAtRes) const getSecondItemRes = await cl.get({ key: 'myFirstTag' }) console.log('success: get second item by reference', getSecondItemRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Resolving reference with transaction id"},{"location":"develop/immugw/","text":"immugw immugw is the intelligent REST proxy that connects to immudb and provides a RESTful interface for applications. We recommend running immudb and immugw on separate machines to enhance security. You may download the immug binary from the latest releases on Github . Once you have downloaded immugw, rename it to immugw , make sure to mark it as executable, then run it. The following example shows how to obtain v1.1.0 for linux amd64: $ wget https://github.com/codenotary/immugw/releases/download/v1.1.0/immugw-v1.1.0-linux-amd64 $ mv immugw-v1.1.0-linux-amd64 immugw $ chmod +x immugw # run help to find out about possible arguments $ ./immugw help # and run immugw in the background $ ./immugw -d --immudb-address {immudb-server-address} Alternatively, you may pull immudb docker image from DockerHub and run it in a ready-to-use container: $ docker run -it -d -p 3323:3323 --name immugw --env IMMUGW_IMMUDB_ADDRESS={immudb-server-address} codenotary/immugw:latest Build from sources Building binaries requires a Linux operating system. To build the binaries yourself, simply clone immugw repository and run: $ make all immugw can be cross compiled for different systems and architectures by setting GOOS and GOARCH variables, i.e.: GOOS=windows GOARCH=amd64 make all To build immugw docker container locally: docker build -t myown/immugw:latest -f Dockerfile . Installing with immuadmin # install immugw service $ ./immugw service install # check current immugw service status $ ./immugw service status # stop immugw service $ ./immugw service stop # start immugw service $ ./immugw service start The Linux service is using the following defaults: File or configuration location all configuration files /etc/immudb pid file /var/lib/immudb/immugw.pid log files /var/log/immudb Configuration immugw can be configured using environment variables, flags or a config file. immugw --help shows you all available flags and environment variables. /etc/immudb/immugw.toml is used as a default configuration file RESTful API reference You can find the swagger schema here: swagger immugw If you want to run the Swagger UI, simply run the following Docker command after you cloned this repo: $ wget https://github.com/codenotary/immudb/blob/master/pkg/api/schema/schema.swagger.json $ docker run -d -it -p 8081:8080 --name swagger-immugw -v ${PWD}/schema.swagger.json:/openapi.json -e SWAGGER_JSON=/openapi.json swaggerapi/swagger-ui immugw as auditor immugw can be also run as auditor. $ ./immugw --audit If you are running immugw as a service, you need to edit /etc/immudb/immugw.toml and add the following section: audit = true # false is default audit-interval = \"5m\" # suffixes: \"s\", \"m\", \"h\", examples: 10s, 5m 1h audit-username = \"\" # when immudb authentication is enabled, use read-only user credentials here audit-password = \"\" # and the password","title":"immugw"},{"location":"develop/immugw/#immugw","text":"immugw is the intelligent REST proxy that connects to immudb and provides a RESTful interface for applications. We recommend running immudb and immugw on separate machines to enhance security. You may download the immug binary from the latest releases on Github . Once you have downloaded immugw, rename it to immugw , make sure to mark it as executable, then run it. The following example shows how to obtain v1.1.0 for linux amd64: $ wget https://github.com/codenotary/immugw/releases/download/v1.1.0/immugw-v1.1.0-linux-amd64 $ mv immugw-v1.1.0-linux-amd64 immugw $ chmod +x immugw # run help to find out about possible arguments $ ./immugw help # and run immugw in the background $ ./immugw -d --immudb-address {immudb-server-address} Alternatively, you may pull immudb docker image from DockerHub and run it in a ready-to-use container: $ docker run -it -d -p 3323:3323 --name immugw --env IMMUGW_IMMUDB_ADDRESS={immudb-server-address} codenotary/immugw:latest","title":"immugw"},{"location":"develop/immugw/#build-from-sources","text":"Building binaries requires a Linux operating system. To build the binaries yourself, simply clone immugw repository and run: $ make all immugw can be cross compiled for different systems and architectures by setting GOOS and GOARCH variables, i.e.: GOOS=windows GOARCH=amd64 make all To build immugw docker container locally: docker build -t myown/immugw:latest -f Dockerfile .","title":"Build from sources"},{"location":"develop/immugw/#installing-with-immuadmin","text":"# install immugw service $ ./immugw service install # check current immugw service status $ ./immugw service status # stop immugw service $ ./immugw service stop # start immugw service $ ./immugw service start The Linux service is using the following defaults: File or configuration location all configuration files /etc/immudb pid file /var/lib/immudb/immugw.pid log files /var/log/immudb","title":"Installing with immuadmin"},{"location":"develop/immugw/#configuration","text":"immugw can be configured using environment variables, flags or a config file. immugw --help shows you all available flags and environment variables. /etc/immudb/immugw.toml is used as a default configuration file","title":"Configuration"},{"location":"develop/immugw/#restful-api-reference","text":"You can find the swagger schema here: swagger immugw If you want to run the Swagger UI, simply run the following Docker command after you cloned this repo: $ wget https://github.com/codenotary/immudb/blob/master/pkg/api/schema/schema.swagger.json $ docker run -d -it -p 8081:8080 --name swagger-immugw -v ${PWD}/schema.swagger.json:/openapi.json -e SWAGGER_JSON=/openapi.json swaggerapi/swagger-ui","title":"RESTful API reference"},{"location":"develop/immugw/#immugw-as-auditor","text":"immugw can be also run as auditor. $ ./immugw --audit If you are running immugw as a service, you need to edit /etc/immudb/immugw.toml and add the following section: audit = true # false is default audit-interval = \"5m\" # suffixes: \"s\", \"m\", \"h\", examples: 10s, 5m 1h audit-username = \"\" # when immudb authentication is enabled, use read-only user credentials here audit-password = \"\" # and the password","title":"immugw as auditor"},{"location":"develop/indexes/","text":"Secondary indexes On top of the key value store immudb provides secondary indexes to help developers to handle complex queries. Sorted sets The sorted set data type provides a simple secondary index that can be created with immudb. This data structure contains a set of references to other key-value entries. Elements of this set are ordered using a floating-point score specified for each element upon insertion. Entries having equal score will have the order in which they were inserted into the set. Note: The score type is a 64-bit floating point number to support a large number of uses cases. 64-bit floating point gives a lot of flexibility and dynamic range, at the expense of having only 53-bits of integer. When a 64-bit integer is cast to a float value there could be a loss of precision, in which case the order of entries having same float64 score value will be determined by the insertion order. The KV entry referenced in the set can be bound to a specific transaction id - such entry is called a bound reference. A bound reference will always get the value for the key at a specific transaction instead of the most recent value, including a case where one set contains multiple values for the same key but for different transactions. That way, sets allow optimal access to historical data using a single immudb read operation. Note: If a compound operation is executed with the ExecAll call, a bound entry added to the set can reference a key created/updated in the same ExecAll call. To make such an operation, set the BoundRef value to true and the AtTx value to 0 . Inserting entries into sets can be done using the following operations: ZAdd , VerifiedZAdd , ZAddAt , VerifiedZAddAt , ExecAll . Those operations accept the following parameters: Set : the name of the collection Score : entry score used to order items within the set Key : the key of entry to be added to the set AtTx : for bound references, a transaction id at which the value will be read, if set to 0 for ExecAll operation, current transaction id will be used. Optional BoundRef : if set to true, this will be a reference bound to a specific transaction. Optional NoWait : if set to true, don't wait for indexing to be finished after adding this entry Reading data from the set can be done using the following operations: ZScan , StreamZScan . Those operations accept the following parameters: Set : the name of the collection SeekKey : initial key for the first entry in the iteration. Optional SeekScore : the min or max score for the first entry in the iteration, depending on Desc value. Optional SeekAtTx : the tx id for the first entry in the iteration. Optional InclusiveSeek : the element resulting from the combination of the SeekKey SeekScore and SeekAtTx is returned with the result. Optional Desc : If set to true, entries will be returned in an descending (reversed) order. Optional SinceTx : immudb will wait that the transaction provided by SinceTx be processed. Optional NoWait : when true scan doesn't wait that txSinceTx is processed. Optional MinScore : minimum score filter. Optional MaxScore : maximum score filter. Optional Limit : maximum number of returned items. Optional Note: issuing a ZScan or StreamZScan operation will by default wait for the index to be up-to-date. To avoid waiting for the index (and thus to allow reading the data from some older state), set the SinceTx to a very high value exceeding the most recent transaction id (e.g. maximum int value) and set NoWait to true . :::: tabs ::: tab Go i1, err := client.Set(ctx, []byte(`user1`), []byte(`user1@mail.com`), ) if err != nil{ log.Fatal(err) } i2, err := client.Set(ctx, []byte(`user2`), []byte(`user2@mail.com`), ) if err != nil{ log.Fatal(err) } i3, err := client.Set(ctx, []byte(`user3`), []byte(`user3@mail.com`), ) if err != nil{ log.Fatal(err) } i4, err := client.Set(ctx, []byte(`user3`), []byte(`another-user3@mail.com`), ) if err != nil{ log.Fatal(err) } if _ , err = client.ZAddAt(ctx, []byte(`age`), 25, []byte(`user1`), i1.Id, ); err != nil { log.Fatal(err) } if _ , err = client.ZAddAt(ctx, []byte(`age`), 36, []byte(`user2`), i2.Id, ); err != nil { log.Fatal(err) } if _ , err = client.ZAddAt(ctx, []byte(`age`), 36, []byte(`user3`), i3.Id, ); err != nil { log.Fatal(err) } if _ , err = client.ZAddAt(ctx, []byte(`age`), 54, []byte(`user3`), i4.Id, ); err != nil { log.Fatal(err) } zscanOpts1 := &schema.ZScanRequest{ Set: []byte(`age`), SinceTx: math.MaxUint64, NoWait: true, MinScore: &schema.Score{Score: 36}, } the36YearsOldList, err := client.ZScan(ctx, zscanOpts1) if err != nil{ log.Fatal(err) } s, _ := json.MarshalIndent(the36YearsOldList, \"\", \"\\t\") fmt.Print(string(s)) oldestReq := &schema.ZScanRequest{ Set: []byte(`age`), SeekKey: []byte{0xFF}, SeekScore: math.MaxFloat64, SeekAtTx: math.MaxUint64, Limit: 1, Desc: true, SinceTx: math.MaxUint64, NoWait: true, } oldest, err := client.ZScan(ctx, oldestReq) if err != nil{ log.Fatal(err) } s, _ = json.MarshalIndent(oldest, \"\", \"\\t\") fmt.Print(string(s)) ::: ::: tab Java byte[] value1 = {0, 1, 2, 3}; byte[] value2 = {4, 5, 6, 7}; try { immuClient.set(\"zadd1\", value1); immuClient.set(\"zadd2\", value2); } catch (CorruptedDataException e) { // ... } TxMetadata set1TxMd = null; try { immuClient.zAdd(\"set1\", 1, \"zadd1\"); set1TxMd = immuClient.zAdd(\"set1\", 2, \"zadd2\"); immuClient.zAddAt(\"set1\", 3, \"zadd3\", set1TxMd.id); immuClient.zAdd(\"set2\", 2, \"zadd1\"); immuClient.zAdd(\"set2\", 1, \"zadd2\"); } catch (CorruptedDataException e) { // ... } List<KV> zScan1 = immuClient.zScan(\"set1\", set1TxMd.id, 5, false); // We expect two KVs with key names \"zadd1\" and \"zadd2\". List<KV> zScan2 = immuClient.zScan(\"set2\", 5, false); // Same as before, we expect two KVs with key names \"zadd2\" and \"zadd1\". ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.set(b\"user1\", b\"user1@mail.com\") client.set(b\"user2\", b\"user2@mail.com\") client.set(b\"user3\", b\"user3@mail.com\") client.set(b\"user4\", b\"user3@mail.com\") client.zAdd(b\"age\", 100, b\"user1\") client.zAdd(b\"age\", 101, b\"user2\") client.zAdd(b\"age\", 99, b\"user3\") client.zAdd(b\"age\", 100, b\"user4\") scanResult = client.zScan(b\"age\", b\"\", 0, 0, True, 50, False, 100, 101) print(scanResult) # Shows records with 'age' 100 <= score < 101 # with descending order and limit = 50 if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const { id: id1 } = await cl.set({ key: 'user1', value: 'user1@mail.com' }) const { id: id2 } = await cl.set({ key: 'user2', value: 'user2@mail.com' }) const { id: id3 } = await cl.set({ key: 'user3', value: 'user3@mail.com' }) const { id: id4 } = await cl.set({ key: 'user3', value: 'another-user3@mail.com' }) const zAddAtReq1: Parameters.ZAddAt = { set: 'age', score: 25, key: 'user1', attx: id1 } const zAddAtRes1 = await cl.zAddAt(zAddAtReq1) const zAddAtReq2: Parameters.ZAddAt = { set: 'age', score: 36, key: 'user2', attx: id2 } const zAddAtRes2 = await cl.zAddAt(zAddAtReq2) const zAddAtReq3: Parameters.ZAddAt = { set: 'age', score: 36, key: 'user3', attx: id3 } const zAddAtRes3 = await cl.zAddAt(zAddAtReq3) const zAddAtReq4: Parameters.ZAddAt = { set: 'age', score: 54, key: 'user4', attx: id4 } const zAddAtRes4 = await cl.zAddAt(zAddAtReq4) const zScanReq: Parameters.ZScan = { set: 'age', sincetx: 0, nowait: true, minscore: { score: 36 } } const zScanRes = await cl.zScan(zScanReq) console.log('success: zScan all 36-years-old users', zScanRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Secondary indexes"},{"location":"develop/indexes/#secondary-indexes","text":"On top of the key value store immudb provides secondary indexes to help developers to handle complex queries.","title":"Secondary indexes"},{"location":"develop/indexes/#sorted-sets","text":"The sorted set data type provides a simple secondary index that can be created with immudb. This data structure contains a set of references to other key-value entries. Elements of this set are ordered using a floating-point score specified for each element upon insertion. Entries having equal score will have the order in which they were inserted into the set. Note: The score type is a 64-bit floating point number to support a large number of uses cases. 64-bit floating point gives a lot of flexibility and dynamic range, at the expense of having only 53-bits of integer. When a 64-bit integer is cast to a float value there could be a loss of precision, in which case the order of entries having same float64 score value will be determined by the insertion order. The KV entry referenced in the set can be bound to a specific transaction id - such entry is called a bound reference. A bound reference will always get the value for the key at a specific transaction instead of the most recent value, including a case where one set contains multiple values for the same key but for different transactions. That way, sets allow optimal access to historical data using a single immudb read operation. Note: If a compound operation is executed with the ExecAll call, a bound entry added to the set can reference a key created/updated in the same ExecAll call. To make such an operation, set the BoundRef value to true and the AtTx value to 0 . Inserting entries into sets can be done using the following operations: ZAdd , VerifiedZAdd , ZAddAt , VerifiedZAddAt , ExecAll . Those operations accept the following parameters: Set : the name of the collection Score : entry score used to order items within the set Key : the key of entry to be added to the set AtTx : for bound references, a transaction id at which the value will be read, if set to 0 for ExecAll operation, current transaction id will be used. Optional BoundRef : if set to true, this will be a reference bound to a specific transaction. Optional NoWait : if set to true, don't wait for indexing to be finished after adding this entry Reading data from the set can be done using the following operations: ZScan , StreamZScan . Those operations accept the following parameters: Set : the name of the collection SeekKey : initial key for the first entry in the iteration. Optional SeekScore : the min or max score for the first entry in the iteration, depending on Desc value. Optional SeekAtTx : the tx id for the first entry in the iteration. Optional InclusiveSeek : the element resulting from the combination of the SeekKey SeekScore and SeekAtTx is returned with the result. Optional Desc : If set to true, entries will be returned in an descending (reversed) order. Optional SinceTx : immudb will wait that the transaction provided by SinceTx be processed. Optional NoWait : when true scan doesn't wait that txSinceTx is processed. Optional MinScore : minimum score filter. Optional MaxScore : maximum score filter. Optional Limit : maximum number of returned items. Optional Note: issuing a ZScan or StreamZScan operation will by default wait for the index to be up-to-date. To avoid waiting for the index (and thus to allow reading the data from some older state), set the SinceTx to a very high value exceeding the most recent transaction id (e.g. maximum int value) and set NoWait to true . :::: tabs ::: tab Go i1, err := client.Set(ctx, []byte(`user1`), []byte(`user1@mail.com`), ) if err != nil{ log.Fatal(err) } i2, err := client.Set(ctx, []byte(`user2`), []byte(`user2@mail.com`), ) if err != nil{ log.Fatal(err) } i3, err := client.Set(ctx, []byte(`user3`), []byte(`user3@mail.com`), ) if err != nil{ log.Fatal(err) } i4, err := client.Set(ctx, []byte(`user3`), []byte(`another-user3@mail.com`), ) if err != nil{ log.Fatal(err) } if _ , err = client.ZAddAt(ctx, []byte(`age`), 25, []byte(`user1`), i1.Id, ); err != nil { log.Fatal(err) } if _ , err = client.ZAddAt(ctx, []byte(`age`), 36, []byte(`user2`), i2.Id, ); err != nil { log.Fatal(err) } if _ , err = client.ZAddAt(ctx, []byte(`age`), 36, []byte(`user3`), i3.Id, ); err != nil { log.Fatal(err) } if _ , err = client.ZAddAt(ctx, []byte(`age`), 54, []byte(`user3`), i4.Id, ); err != nil { log.Fatal(err) } zscanOpts1 := &schema.ZScanRequest{ Set: []byte(`age`), SinceTx: math.MaxUint64, NoWait: true, MinScore: &schema.Score{Score: 36}, } the36YearsOldList, err := client.ZScan(ctx, zscanOpts1) if err != nil{ log.Fatal(err) } s, _ := json.MarshalIndent(the36YearsOldList, \"\", \"\\t\") fmt.Print(string(s)) oldestReq := &schema.ZScanRequest{ Set: []byte(`age`), SeekKey: []byte{0xFF}, SeekScore: math.MaxFloat64, SeekAtTx: math.MaxUint64, Limit: 1, Desc: true, SinceTx: math.MaxUint64, NoWait: true, } oldest, err := client.ZScan(ctx, oldestReq) if err != nil{ log.Fatal(err) } s, _ = json.MarshalIndent(oldest, \"\", \"\\t\") fmt.Print(string(s)) ::: ::: tab Java byte[] value1 = {0, 1, 2, 3}; byte[] value2 = {4, 5, 6, 7}; try { immuClient.set(\"zadd1\", value1); immuClient.set(\"zadd2\", value2); } catch (CorruptedDataException e) { // ... } TxMetadata set1TxMd = null; try { immuClient.zAdd(\"set1\", 1, \"zadd1\"); set1TxMd = immuClient.zAdd(\"set1\", 2, \"zadd2\"); immuClient.zAddAt(\"set1\", 3, \"zadd3\", set1TxMd.id); immuClient.zAdd(\"set2\", 2, \"zadd1\"); immuClient.zAdd(\"set2\", 1, \"zadd2\"); } catch (CorruptedDataException e) { // ... } List<KV> zScan1 = immuClient.zScan(\"set1\", set1TxMd.id, 5, false); // We expect two KVs with key names \"zadd1\" and \"zadd2\". List<KV> zScan2 = immuClient.zScan(\"set2\", 5, false); // Same as before, we expect two KVs with key names \"zadd2\" and \"zadd1\". ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.set(b\"user1\", b\"user1@mail.com\") client.set(b\"user2\", b\"user2@mail.com\") client.set(b\"user3\", b\"user3@mail.com\") client.set(b\"user4\", b\"user3@mail.com\") client.zAdd(b\"age\", 100, b\"user1\") client.zAdd(b\"age\", 101, b\"user2\") client.zAdd(b\"age\", 99, b\"user3\") client.zAdd(b\"age\", 100, b\"user4\") scanResult = client.zScan(b\"age\", b\"\", 0, 0, True, 50, False, 100, 101) print(scanResult) # Shows records with 'age' 100 <= score < 101 # with descending order and limit = 50 if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const { id: id1 } = await cl.set({ key: 'user1', value: 'user1@mail.com' }) const { id: id2 } = await cl.set({ key: 'user2', value: 'user2@mail.com' }) const { id: id3 } = await cl.set({ key: 'user3', value: 'user3@mail.com' }) const { id: id4 } = await cl.set({ key: 'user3', value: 'another-user3@mail.com' }) const zAddAtReq1: Parameters.ZAddAt = { set: 'age', score: 25, key: 'user1', attx: id1 } const zAddAtRes1 = await cl.zAddAt(zAddAtReq1) const zAddAtReq2: Parameters.ZAddAt = { set: 'age', score: 36, key: 'user2', attx: id2 } const zAddAtRes2 = await cl.zAddAt(zAddAtReq2) const zAddAtReq3: Parameters.ZAddAt = { set: 'age', score: 36, key: 'user3', attx: id3 } const zAddAtRes3 = await cl.zAddAt(zAddAtReq3) const zAddAtReq4: Parameters.ZAddAt = { set: 'age', score: 54, key: 'user4', attx: id4 } const zAddAtRes4 = await cl.zAddAt(zAddAtReq4) const zScanReq: Parameters.ZScan = { set: 'age', sincetx: 0, nowait: true, minscore: { score: 36 } } const zScanRes = await cl.zScan(zScanReq) console.log('success: zScan all 36-years-old users', zScanRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Sorted sets"},{"location":"develop/management/","text":"Management operations User management User management is exposed with following methods: * CreateUser * ChangePermission * ChangePassword Password must have between 8 and 32 letters, digits and special characters of which at least 1 uppercase letter, 1 digit and 1 special character. Admin permissions are: * PermissionSysAdmin = 255 * PermissionAdmin = 254 Non-admin permissions are: * PermissionNone = 0 * PermissionR = 1 * PermissionRW = 2 :::: tabs ::: tab Go client, err := immudb.NewClient() if err != nil { log.Fatal(err) } ctx := context.Background() err = client.OpenSession(ctx, []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(ctx) err = client.CreateUser(ctx, []byte(`myNewUser1`), []byte(`myS3cretPassword!`), auth.PermissionR, \"defaultdb\") if err != nil { log.Fatal(err) } err = client.ChangePermission(ctx, schema.PermissionAction_GRANT, \"myNewUser1\", \"defaultDB\", auth.PermissionRW) if err != nil { log.Fatal(err) } err = client.ChangePassword(ctx, []byte(`myNewUser1`), []byte(`myS3cretPassword!`), []byte(`myNewS3cretPassword!`)) if err != nil { log.Fatal(err) } ::: ::: tab Java String database = \"defaultdb\"; String username = \"testCreateUser\"; String password = \"testTest123!\"; Permission permission = Permission.PERMISSION_RW; immuClient.login(\"immudb\", \"immudb\"); immuClient.useDatabase(database); try { immuClient.createUser(username, password, permission, database); } catch (StatusRuntimeException e) { System.out.println(\"createUser exception: \" + e.getMessage()); } // We expect getting back the previously created \"testCreateUser\" user. System.out.println(\"listUsers:\"); List<User> users = immuClient.listUsers(); users.forEach(user -> System.out.println(\"\\t- \" + user)); // Changing the user password. immuClient.changePassword(username, password, \"newTestTest123!\"); ::: ::: tab Python from grpc import RpcError from immudb import ImmudbClient from immudb.constants import PERMISSION_ADMIN, PERMISSION_R, PERMISSION_RW from immudb.grpc.schema_pb2 import GRANT, REVOKE from enum import IntEnum URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) passwordForNewUsers = \"Te1st!@#Test\" try: client.createUser(\"tester1\", passwordForNewUsers, PERMISSION_R, DB) client.createUser(\"tester2\", passwordForNewUsers, PERMISSION_RW, DB) client.createUser(\"tester3\", passwordForNewUsers, PERMISSION_ADMIN, DB) except RpcError as exception: print(exception.details()) users = client.listUsers().userlist.users # immudb.handler.listUsers.listUsersResponse for user in users: print(\"User\", user.user) print(\"Created by\", user.createdby) print(\"Creation date\", user.createdat) print(\"Is active\", user.active) for permission in user.permissions: print(\"Permission\", permission.database, permission.permission) print(\"---\") client.login(\"tester3\", passwordForNewUsers, DB) client.changePermission(GRANT, \"tester2\", DB, PERMISSION_ADMIN) client.changePermission(REVOKE, \"tester2\", DB, PERMISSION_ADMIN) client.login(LOGIN, PASSWORD, database = DB) # Changing password client.changePassword(\"tester1\", \"N1ewpassword!\", passwordForNewUsers) # User logs with new password client.login(\"tester1\", \"N1ewpassword!\") client.login(LOGIN, PASSWORD, database = DB) client.changePassword(\"tester1\", passwordForNewUsers, \"N1ewpassword!\") client.login(\"tester1\", passwordForNewUsers, DB) # No permissions to write try: client.set(b\"test\", b\"test\") except RpcError as exception: print(exception.details()) # But has permissions to read result = client.get(b\"test\") client.login(\"tester3\", passwordForNewUsers, DB) # Now will have permissions to write client.changePermission(GRANT, \"tester1\", DB, PERMISSION_RW) client.login(\"tester1\", passwordForNewUsers, DB) client.set(b\"test\", b\"test\") result = client.get(b\"test\") client.login(\"tester3\", passwordForNewUsers, DB) # Now will have permissions to nothing client.changePermission(REVOKE, \"tester1\", DB, PERMISSION_RW) try: client.login(\"tester1\", passwordForNewUsers, DB) except RpcError as exception: print(exception.details()) client.login(\"tester3\", passwordForNewUsers, DB) client.changePermission(GRANT, \"tester1\", DB, PERMISSION_RW) if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' import { USER_ACTION, USER_PERMISSION } from 'immudb-node/dist/types/user' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const createUserRequest: Parameters.CreateUser = { user: 'myNewUser1', password: 'myS3cretPassword!', permission: USER_PERMISSION.READ_ONLY, database: 'defaultdb', }; const createUserRes = cl.createUser(createUserRequest) console.log('success: createUser', createUserRes) const changePermissionReq: Parameters.ChangePermission = { action: USER_ACTION.GRANT, username: 'myNewUser1', database: 'defaultDB', permission: USER_PERMISSION.READ_WRITE } const changePermissionRes = await cl.changePermission(changePermissionReq) console.log('success: changePermission', changePermissionRes) const changePasswordReq: Parameters.ChangePassword = { user: 'myNewUser1', oldpassword: 'myS3cretPassword!', newpassword: 'myNewS3cretPassword!' } const changePasswordRes = await cl.changePassword(changePasswordReq) console.log('success: changePassword', changePermissionRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Database management Multi-database support is included in immudb server. immudb automatically creates an initial database named defaultdb . Managing users and databases requires the appropriate privileges. A user with PermissionAdmin rights can manage everything. Non-admin users have restricted access and can only read or write databases to which they have been granted permission. Each database can be configured with a variety of settings. While some values can be changed at any time (though it may require a database reload to take effect), following ones are fixed and cannot be changed: FileSize, MaxKeyLen, MaxValueLen, MaxTxEntries and IndexOptions.MaxNodeSize. Configuration options Following main database options are available: Name Type Description replicationSettings Replication Setings Repliation settings are described below indexSettings Index Settings Index settings are described below fileSize Uint32 maximum file size of files on disk generated by immudb maxKeyLen Uint32 maximum length of keys for entries stored in the database maxValueLen Uint32 maximum length of values for entries stored in the database maxTxEntries Uint32 maximum number of entries inside one transaction excludeCommitTime Bool if set to true, commit time is not added to transaction headers allowing reproducible database state maxConcurrency Uint32 max number of concurrent operations on the db maxIOConcurrency Uint32 max number of concurrent IO operations on the db txLogCacheSize Uint32 size of transaction log cache vLogMaxOpenedFiles Uint32 maximum number of open files for payload data txLogMaxOpenedFiles Uint32 maximum number of open files for transaction log commitLogMaxOpenedFiles Uint32 maximum number of open files for commit log writeTxHeaderVersion Uint32 transaction header version, used for backwards compatibility autoload Bool if set to false, do not load database on startup Replication settings: Name Type Description replica Bool if true, the database is a replica of another one masterDatabase String name of the database to replicate masterAddress String hostname of the master immudb instance masterPort Uint32 tcp port of the master immudb instance followerUsername String username used to connect to the master immudb instance followerPassword String password used to connect to the master immudb instance Additional index options: Name Type Description flushThreshold Uint32 threshold in number of entries between automatic flushes syncThreshold Uint32 threshold in number of entries between flushes with sync cacheSize Uint32 size of btree node cache maxNodeSize Uint32 max size of btree node in bytes maxActiveSnapshots Uint32 max number of active in-memory btree snapshots renewSnapRootAfter Uint64 threshold in time for automated snapshot renewal during data scans compactionThld Uint32 minimum number of flushed snapshots to enable full compaction of the index delayDuringCompaction Uint32 extra delay added during indexing when full compaction is in progress nodesLogMaxOpenedFiles Uint32 maximum number of files opened for nodes data historyLogMaxOpenedFiles Uint32 maximum number of files opened for nodes history commitLogMaxOpenedFiles Uint32 maximum number of files opened for commit log flushBufferSize Uint32 in-memory buffer size when doing flush operation cleanupPercentage Float % of data to be cleaned up from during next automatic flush operation Database creation and selection This example shows how to create a new database and how to write records to it. To create a new database, use CreateDatabaseV2 method then UseDatabase to select the newly created one. :::: tabs ::: tab Go client, err := immudb.NewClient() if err != nil { log.Fatal(err) } ctx := context.Background() err = client.OpenSession(ctx, []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(ctx) err = client.CreateDatabaseV2(ctx, \"myimmutabledb\", &schema.DatabaseNullableSettings{ MaxConcurrency: 10, // this setting determines how many transactions can be handled concurrently }) if err != nil { log.Fatal(err) } _, err = client.UseDatabase(ctx, &schema.Database{ Databasename: \"myimmutabledb\", }) if err != nil { log.Fatal(err) } // writing in myimmutabledb _, err = client.Set(ctx, []byte(`key`), []byte(`val`)) if err != nil { log.Fatal(err) } ::: ::: tab Java immuClient.createDatabase(\"db1\"); immuClient.createDatabase(\"db2\"); immuClient.useDatabase(\"db1\"); try { immuClient.set(\"k0\", new byte[]{0, 1, 2, 3}); } catch (CorruptedDataException e) { // ... } ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) testDatabase = \"test\" databases = client.databaseList() if(testDatabase not in databases): client.createDatabase(testDatabase) client.useDatabase(\"test\") client.set(b\"test\", b\"test\") print(client.get(b\"test\")) if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const createDatabaseReq: Parameters.CreateDatabase = { databasename: 'myimmutabledb' } const createDatabaseRes = await cl.createDatabase(createDatabaseReq) console.log('success: createDatabase', createDatabaseRes) const useDatabaseReq: Parameters.UseDatabase = { databasename: 'myimmutabledb' } const useDatabaseRes = await cl.useDatabase(useDatabaseReq) console.log('success: useDatabase', useDatabaseRes) await cl.set('key', 'val') })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Database listing This example shows how to list existent databases using DatabaseListV2 method. :::: tabs ::: tab Go client, err := immudb.NewClient() if err != nil { log.Fatal(err) } ctx := context.Background() err = client.OpenSession(ctx, []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(ctx) res, err := client.DatabaseListV2(ctx) if err != nil { log.Fatal(err) } for _, db := range res.Databases { fmt.Printf(\"database: %s, loaded: %v\\r\\n\", db.Name, db.Loaded) } ::: ::: tab Java List<String> dbs = immuClient.databases(); // List of database names ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Database loading/unloading Databases can be dynamically loaded and unloaded without having to restart the server. After the database is unloaded, all its resources are released. Unloaded databases cannot be queried or written to, but their settings can still be changed. Upon startup, the immudb server will automatically load databases with the attribute Autoload set to true. If a user-created database cannot be loaded successfully, it remains closed, but the server continues to run normally. As a default, autoloading is enabled when creating a database, but it can be disabled during creation or turned on/off at any time thereafter. Following example shows how to load and unload a database using LoadDatabase and UnloadDatabase methods. :::: tabs ::: tab Go client, err := immudb.NewClient() if err != nil { log.Fatal(err) } ctx := context.Background() err = client.OpenSession(ctx, []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(ctx) _, err = client.LoadDatabase(ctx, &schema.LoadDatabaseRequest{Database: \"mydb\"}) if err != nil { log.Fatal(err) } _, err = client.UseDatabase(ctx, &schema.Database{ Databasename: \"mydb\", }) if err != nil { log.Fatal(err) } // do amazing stuff _, err = client.UnloadDatabase(ctx, &schema.UnloadDatabaseRequest{Database: \"mydb\"}) if err != nil { log.Fatal(err) } ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Database settings Database settings can be individually changed using UpdateDatabaseV2 method. Each database can be configured with a variety of settings. While some values can be changed at any time (though it may require a database reload to take effect), following ones are fixed and cannot be changed: FileSize, MaxKeyLen, MaxValueLen, MaxTxEntries and IndexOptions.MaxNodeSize. Note: Replication settings take effect without the need of reloading the database. Following example shows how to update database using UpdateDatabaseV2 method. :::: tabs ::: tab Go client, err := immudb.NewClient() if err != nil { log.Fatal(err) } ctx := context.Background() err = client.OpenSession(ctx, []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(ctx) res, err := client.UpdateDatabaseV2(ctx, \"mydb\", &schema.DatabaseNullableSettings{ TxLogCacheSize: &schema.NullableUint32{Value: 1000}, }) if err != nil { log.Fatal(err) } ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Index cleaning Maintaining a healthy disk usage is crucial. immudb has two operations operations aiming to remove unreferenced data from the index. A full index clean-up is achieved by calling CompactIndex , which is a routine that creates a fresh index based on the current state, removing all intermediate data generated over time. The index is generated asynchronously, so new transactions may take place while it is created. As a result, if the server is constantly overloaded, there will likely be blocking times when the newly compacted index replaces the current one. In the case of continuous load on the server, the FlushIndex operation may be used instead. It will dump the current index into disk while partly removing unreferenced data. The cleanupPercentage attribute indicates how much space will be scanned for unreferenced data. Even though this operation blocks transaction processing, choosing a small percentage e.g. 0.1 may not significantly hinder normal operations while reducing used storage space. Partially compaction may be triggered automatically by immudb. Database settings can be modified to set the cleanupPercentage attribute to non-zero in order to accomplish this. immudb uses a btree to index key-value entries. While the key is the same submitted by the client, the value stored in the btree is an offset to the file where the actual value as stored, its size and hash value. The btree is keep in memory as new data is inserted, getting a key or even the historical values of a key can directly be made by using a mutex lock on the btree but scanning by prefix requires the tree to be stored into disk, this is referred as a snapshot. The persistence is implemented in append-only mode, thus whenever a snapshot is created (btree flushed to disk), updated and new nodes are appended to the file, while new or updated nodes may be linked to unmodified nodes (already written into disk) and those unmodified nodes are not rewritten. The snapshot creation does not necessarily take place upon each scan by prefix, it's possible to reuse an already created one, client can provide his requirements on how new the snapshot should be by providing a transaction ID which at least must be indexed (sinceTx). After some time, several snapshots may be created (specified by flushAfter properties of the btree and the scan requests), the file backing the btree will hold several old snapshots. Thus the clean index process will dump to a different location only the latest snapshot but in this case also writing the unmodified nodes. Once that dump is done, the index folder is replaced by the new one. While the clean process is made, no data is indexed and there will be an extra disk space requirement due to the new dump. Once completed, a considerable disk space will be reduced by removing the previously indexed data (older snapshots). The btree and clean up process is something specific to indexing. And will not lock transaction processing as indexing is asynchronously generated. :::: tabs ::: tab Go // full async index cleanup err = client.CompactIndex(ctx, &emptypb.Empty{}) // error handling // partial index cleanup err = client.FlushIndex(ctx, &schema.FlushIndexRequest{ CleanupPercentage: 0.1, Synced: false, // if true, fsync after writing data to avoid index regeneration in the case of an unexpected crash // error handling ::: ::: tab Java immuClient.cleanIndex(); ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: HealthCheck HealthCheck return an error if immudb status is not ok. :::: tabs ::: tab Go err = client.HealthCheck(ctx) ::: ::: tab Java boolean isHealthy = immuClient.healthCheck(); ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) check = client.healthCheck() # Returns bool print(check) # True if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) await cl.health() })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Management operations"},{"location":"develop/management/#management-operations","text":"","title":"Management operations"},{"location":"develop/management/#user-management","text":"User management is exposed with following methods: * CreateUser * ChangePermission * ChangePassword Password must have between 8 and 32 letters, digits and special characters of which at least 1 uppercase letter, 1 digit and 1 special character. Admin permissions are: * PermissionSysAdmin = 255 * PermissionAdmin = 254 Non-admin permissions are: * PermissionNone = 0 * PermissionR = 1 * PermissionRW = 2 :::: tabs ::: tab Go client, err := immudb.NewClient() if err != nil { log.Fatal(err) } ctx := context.Background() err = client.OpenSession(ctx, []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(ctx) err = client.CreateUser(ctx, []byte(`myNewUser1`), []byte(`myS3cretPassword!`), auth.PermissionR, \"defaultdb\") if err != nil { log.Fatal(err) } err = client.ChangePermission(ctx, schema.PermissionAction_GRANT, \"myNewUser1\", \"defaultDB\", auth.PermissionRW) if err != nil { log.Fatal(err) } err = client.ChangePassword(ctx, []byte(`myNewUser1`), []byte(`myS3cretPassword!`), []byte(`myNewS3cretPassword!`)) if err != nil { log.Fatal(err) } ::: ::: tab Java String database = \"defaultdb\"; String username = \"testCreateUser\"; String password = \"testTest123!\"; Permission permission = Permission.PERMISSION_RW; immuClient.login(\"immudb\", \"immudb\"); immuClient.useDatabase(database); try { immuClient.createUser(username, password, permission, database); } catch (StatusRuntimeException e) { System.out.println(\"createUser exception: \" + e.getMessage()); } // We expect getting back the previously created \"testCreateUser\" user. System.out.println(\"listUsers:\"); List<User> users = immuClient.listUsers(); users.forEach(user -> System.out.println(\"\\t- \" + user)); // Changing the user password. immuClient.changePassword(username, password, \"newTestTest123!\"); ::: ::: tab Python from grpc import RpcError from immudb import ImmudbClient from immudb.constants import PERMISSION_ADMIN, PERMISSION_R, PERMISSION_RW from immudb.grpc.schema_pb2 import GRANT, REVOKE from enum import IntEnum URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) passwordForNewUsers = \"Te1st!@#Test\" try: client.createUser(\"tester1\", passwordForNewUsers, PERMISSION_R, DB) client.createUser(\"tester2\", passwordForNewUsers, PERMISSION_RW, DB) client.createUser(\"tester3\", passwordForNewUsers, PERMISSION_ADMIN, DB) except RpcError as exception: print(exception.details()) users = client.listUsers().userlist.users # immudb.handler.listUsers.listUsersResponse for user in users: print(\"User\", user.user) print(\"Created by\", user.createdby) print(\"Creation date\", user.createdat) print(\"Is active\", user.active) for permission in user.permissions: print(\"Permission\", permission.database, permission.permission) print(\"---\") client.login(\"tester3\", passwordForNewUsers, DB) client.changePermission(GRANT, \"tester2\", DB, PERMISSION_ADMIN) client.changePermission(REVOKE, \"tester2\", DB, PERMISSION_ADMIN) client.login(LOGIN, PASSWORD, database = DB) # Changing password client.changePassword(\"tester1\", \"N1ewpassword!\", passwordForNewUsers) # User logs with new password client.login(\"tester1\", \"N1ewpassword!\") client.login(LOGIN, PASSWORD, database = DB) client.changePassword(\"tester1\", passwordForNewUsers, \"N1ewpassword!\") client.login(\"tester1\", passwordForNewUsers, DB) # No permissions to write try: client.set(b\"test\", b\"test\") except RpcError as exception: print(exception.details()) # But has permissions to read result = client.get(b\"test\") client.login(\"tester3\", passwordForNewUsers, DB) # Now will have permissions to write client.changePermission(GRANT, \"tester1\", DB, PERMISSION_RW) client.login(\"tester1\", passwordForNewUsers, DB) client.set(b\"test\", b\"test\") result = client.get(b\"test\") client.login(\"tester3\", passwordForNewUsers, DB) # Now will have permissions to nothing client.changePermission(REVOKE, \"tester1\", DB, PERMISSION_RW) try: client.login(\"tester1\", passwordForNewUsers, DB) except RpcError as exception: print(exception.details()) client.login(\"tester3\", passwordForNewUsers, DB) client.changePermission(GRANT, \"tester1\", DB, PERMISSION_RW) if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' import { USER_ACTION, USER_PERMISSION } from 'immudb-node/dist/types/user' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const createUserRequest: Parameters.CreateUser = { user: 'myNewUser1', password: 'myS3cretPassword!', permission: USER_PERMISSION.READ_ONLY, database: 'defaultdb', }; const createUserRes = cl.createUser(createUserRequest) console.log('success: createUser', createUserRes) const changePermissionReq: Parameters.ChangePermission = { action: USER_ACTION.GRANT, username: 'myNewUser1', database: 'defaultDB', permission: USER_PERMISSION.READ_WRITE } const changePermissionRes = await cl.changePermission(changePermissionReq) console.log('success: changePermission', changePermissionRes) const changePasswordReq: Parameters.ChangePassword = { user: 'myNewUser1', oldpassword: 'myS3cretPassword!', newpassword: 'myNewS3cretPassword!' } const changePasswordRes = await cl.changePassword(changePasswordReq) console.log('success: changePassword', changePermissionRes) })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"User management"},{"location":"develop/management/#database-management","text":"Multi-database support is included in immudb server. immudb automatically creates an initial database named defaultdb . Managing users and databases requires the appropriate privileges. A user with PermissionAdmin rights can manage everything. Non-admin users have restricted access and can only read or write databases to which they have been granted permission. Each database can be configured with a variety of settings. While some values can be changed at any time (though it may require a database reload to take effect), following ones are fixed and cannot be changed: FileSize, MaxKeyLen, MaxValueLen, MaxTxEntries and IndexOptions.MaxNodeSize.","title":"Database management"},{"location":"develop/management/#configuration-options","text":"Following main database options are available: Name Type Description replicationSettings Replication Setings Repliation settings are described below indexSettings Index Settings Index settings are described below fileSize Uint32 maximum file size of files on disk generated by immudb maxKeyLen Uint32 maximum length of keys for entries stored in the database maxValueLen Uint32 maximum length of values for entries stored in the database maxTxEntries Uint32 maximum number of entries inside one transaction excludeCommitTime Bool if set to true, commit time is not added to transaction headers allowing reproducible database state maxConcurrency Uint32 max number of concurrent operations on the db maxIOConcurrency Uint32 max number of concurrent IO operations on the db txLogCacheSize Uint32 size of transaction log cache vLogMaxOpenedFiles Uint32 maximum number of open files for payload data txLogMaxOpenedFiles Uint32 maximum number of open files for transaction log commitLogMaxOpenedFiles Uint32 maximum number of open files for commit log writeTxHeaderVersion Uint32 transaction header version, used for backwards compatibility autoload Bool if set to false, do not load database on startup Replication settings: Name Type Description replica Bool if true, the database is a replica of another one masterDatabase String name of the database to replicate masterAddress String hostname of the master immudb instance masterPort Uint32 tcp port of the master immudb instance followerUsername String username used to connect to the master immudb instance followerPassword String password used to connect to the master immudb instance Additional index options: Name Type Description flushThreshold Uint32 threshold in number of entries between automatic flushes syncThreshold Uint32 threshold in number of entries between flushes with sync cacheSize Uint32 size of btree node cache maxNodeSize Uint32 max size of btree node in bytes maxActiveSnapshots Uint32 max number of active in-memory btree snapshots renewSnapRootAfter Uint64 threshold in time for automated snapshot renewal during data scans compactionThld Uint32 minimum number of flushed snapshots to enable full compaction of the index delayDuringCompaction Uint32 extra delay added during indexing when full compaction is in progress nodesLogMaxOpenedFiles Uint32 maximum number of files opened for nodes data historyLogMaxOpenedFiles Uint32 maximum number of files opened for nodes history commitLogMaxOpenedFiles Uint32 maximum number of files opened for commit log flushBufferSize Uint32 in-memory buffer size when doing flush operation cleanupPercentage Float % of data to be cleaned up from during next automatic flush operation","title":"Configuration options"},{"location":"develop/management/#database-creation-and-selection","text":"This example shows how to create a new database and how to write records to it. To create a new database, use CreateDatabaseV2 method then UseDatabase to select the newly created one. :::: tabs ::: tab Go client, err := immudb.NewClient() if err != nil { log.Fatal(err) } ctx := context.Background() err = client.OpenSession(ctx, []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(ctx) err = client.CreateDatabaseV2(ctx, \"myimmutabledb\", &schema.DatabaseNullableSettings{ MaxConcurrency: 10, // this setting determines how many transactions can be handled concurrently }) if err != nil { log.Fatal(err) } _, err = client.UseDatabase(ctx, &schema.Database{ Databasename: \"myimmutabledb\", }) if err != nil { log.Fatal(err) } // writing in myimmutabledb _, err = client.Set(ctx, []byte(`key`), []byte(`val`)) if err != nil { log.Fatal(err) } ::: ::: tab Java immuClient.createDatabase(\"db1\"); immuClient.createDatabase(\"db2\"); immuClient.useDatabase(\"db1\"); try { immuClient.set(\"k0\", new byte[]{0, 1, 2, 3}); } catch (CorruptedDataException e) { // ... } ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) testDatabase = \"test\" databases = client.databaseList() if(testDatabase not in databases): client.createDatabase(testDatabase) client.useDatabase(\"test\") client.set(b\"test\", b\"test\") print(client.get(b\"test\")) if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const createDatabaseReq: Parameters.CreateDatabase = { databasename: 'myimmutabledb' } const createDatabaseRes = await cl.createDatabase(createDatabaseReq) console.log('success: createDatabase', createDatabaseRes) const useDatabaseReq: Parameters.UseDatabase = { databasename: 'myimmutabledb' } const useDatabaseRes = await cl.useDatabase(useDatabaseReq) console.log('success: useDatabase', useDatabaseRes) await cl.set('key', 'val') })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Database creation and selection"},{"location":"develop/management/#database-listing","text":"This example shows how to list existent databases using DatabaseListV2 method. :::: tabs ::: tab Go client, err := immudb.NewClient() if err != nil { log.Fatal(err) } ctx := context.Background() err = client.OpenSession(ctx, []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(ctx) res, err := client.DatabaseListV2(ctx) if err != nil { log.Fatal(err) } for _, db := range res.Databases { fmt.Printf(\"database: %s, loaded: %v\\r\\n\", db.Name, db.Loaded) } ::: ::: tab Java List<String> dbs = immuClient.databases(); // List of database names ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Database listing"},{"location":"develop/management/#database-loadingunloading","text":"Databases can be dynamically loaded and unloaded without having to restart the server. After the database is unloaded, all its resources are released. Unloaded databases cannot be queried or written to, but their settings can still be changed. Upon startup, the immudb server will automatically load databases with the attribute Autoload set to true. If a user-created database cannot be loaded successfully, it remains closed, but the server continues to run normally. As a default, autoloading is enabled when creating a database, but it can be disabled during creation or turned on/off at any time thereafter. Following example shows how to load and unload a database using LoadDatabase and UnloadDatabase methods. :::: tabs ::: tab Go client, err := immudb.NewClient() if err != nil { log.Fatal(err) } ctx := context.Background() err = client.OpenSession(ctx, []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(ctx) _, err = client.LoadDatabase(ctx, &schema.LoadDatabaseRequest{Database: \"mydb\"}) if err != nil { log.Fatal(err) } _, err = client.UseDatabase(ctx, &schema.Database{ Databasename: \"mydb\", }) if err != nil { log.Fatal(err) } // do amazing stuff _, err = client.UnloadDatabase(ctx, &schema.UnloadDatabaseRequest{Database: \"mydb\"}) if err != nil { log.Fatal(err) } ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Database loading/unloading"},{"location":"develop/management/#database-settings","text":"Database settings can be individually changed using UpdateDatabaseV2 method. Each database can be configured with a variety of settings. While some values can be changed at any time (though it may require a database reload to take effect), following ones are fixed and cannot be changed: FileSize, MaxKeyLen, MaxValueLen, MaxTxEntries and IndexOptions.MaxNodeSize. Note: Replication settings take effect without the need of reloading the database. Following example shows how to update database using UpdateDatabaseV2 method. :::: tabs ::: tab Go client, err := immudb.NewClient() if err != nil { log.Fatal(err) } ctx := context.Background() err = client.OpenSession(ctx, []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(ctx) res, err := client.UpdateDatabaseV2(ctx, \"mydb\", &schema.DatabaseNullableSettings{ TxLogCacheSize: &schema.NullableUint32{Value: 1000}, }) if err != nil { log.Fatal(err) } ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Database settings"},{"location":"develop/management/#index-cleaning","text":"Maintaining a healthy disk usage is crucial. immudb has two operations operations aiming to remove unreferenced data from the index. A full index clean-up is achieved by calling CompactIndex , which is a routine that creates a fresh index based on the current state, removing all intermediate data generated over time. The index is generated asynchronously, so new transactions may take place while it is created. As a result, if the server is constantly overloaded, there will likely be blocking times when the newly compacted index replaces the current one. In the case of continuous load on the server, the FlushIndex operation may be used instead. It will dump the current index into disk while partly removing unreferenced data. The cleanupPercentage attribute indicates how much space will be scanned for unreferenced data. Even though this operation blocks transaction processing, choosing a small percentage e.g. 0.1 may not significantly hinder normal operations while reducing used storage space. Partially compaction may be triggered automatically by immudb. Database settings can be modified to set the cleanupPercentage attribute to non-zero in order to accomplish this. immudb uses a btree to index key-value entries. While the key is the same submitted by the client, the value stored in the btree is an offset to the file where the actual value as stored, its size and hash value. The btree is keep in memory as new data is inserted, getting a key or even the historical values of a key can directly be made by using a mutex lock on the btree but scanning by prefix requires the tree to be stored into disk, this is referred as a snapshot. The persistence is implemented in append-only mode, thus whenever a snapshot is created (btree flushed to disk), updated and new nodes are appended to the file, while new or updated nodes may be linked to unmodified nodes (already written into disk) and those unmodified nodes are not rewritten. The snapshot creation does not necessarily take place upon each scan by prefix, it's possible to reuse an already created one, client can provide his requirements on how new the snapshot should be by providing a transaction ID which at least must be indexed (sinceTx). After some time, several snapshots may be created (specified by flushAfter properties of the btree and the scan requests), the file backing the btree will hold several old snapshots. Thus the clean index process will dump to a different location only the latest snapshot but in this case also writing the unmodified nodes. Once that dump is done, the index folder is replaced by the new one. While the clean process is made, no data is indexed and there will be an extra disk space requirement due to the new dump. Once completed, a considerable disk space will be reduced by removing the previously indexed data (older snapshots). The btree and clean up process is something specific to indexing. And will not lock transaction processing as indexing is asynchronously generated. :::: tabs ::: tab Go // full async index cleanup err = client.CompactIndex(ctx, &emptypb.Empty{}) // error handling // partial index cleanup err = client.FlushIndex(ctx, &schema.FlushIndexRequest{ CleanupPercentage: 0.1, Synced: false, // if true, fsync after writing data to avoid index regeneration in the case of an unexpected crash // error handling ::: ::: tab Java immuClient.cleanIndex(); ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Index cleaning"},{"location":"develop/management/#healthcheck","text":"HealthCheck return an error if immudb status is not ok. :::: tabs ::: tab Go err = client.HealthCheck(ctx) ::: ::: tab Java boolean isHealthy = immuClient.healthCheck(); ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) check = client.healthCheck() # Returns bool print(check) # True if __name__ == \"__main__\": main() ::: ::: tab Node.js import ImmudbClient from 'immudb-node' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) await cl.health() })() ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"HealthCheck"},{"location":"develop/operations/","text":"State management Current State Current state of immudb provides proof that clients can use to verify immudb: :::: tabs ::: tab Go state, err := client.CurrentState(ctx) if err != nil { log.Fatal(err) } fmt.Printf(\"current state is : %v\", state) ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) state = client.currentState() # immudb.rootService.State print(state.db) # Current selected DB print(state.txId) # Current transaction ID print(state.txHash) # Current transaction hash print(state.signature) # Current signature if __name__ == \"__main__\": main() ::: ::: tab Java ImmuState currState = immuClient.currentState(); System.out.printf(\"The current state is \" + currState.toString()); ::: ::: tab Node.js import ImmudbClient from 'immudb-node' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const currentStateRes = await cl.currentState() console.log('success: currentState', currentStateRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Automated verification of state by immudb SDK It's the responsibility of the immudb client to track the server state. That way it can check each verified read or write operation against a trusted state. :::: tabs ::: tab Go The component in charge of state handling is the StateService . To set up the stateService 3 interfaces need to be implemented and provided to the StateService constructor: * Cache interface in the cache package. Standard cache.NewFileCache provides a file state store solution. * StateProvider in the stateService package. It provides a fresh state from immudb server when the client is being initialized for the first time. Standard StateProvider provides a service that retrieve immudb first state hash from a gRPC endpoint. * UUIDProvider in the stateService package. It provides the immudb identifier. This is needed to allow the client to safely connect to multiple immudb instances. Standard UUIDProvider provides the immudb server identifier from a gRPC endpoint. Following an example how to obtain a client instance with a custom state service. func MyCustomImmuClient(options *c.Options) (cli c.ImmuClient, err error) { ctx := context.Background() cli = c.DefaultClient() options.DialOptions = cli.SetupDialOptions(options) cli.WithOptions(options) var clientConn *grpc.ClientConn if clientConn, err = cli.Connect(ctx); err != nil { return nil, err } cli.WithClientConn(clientConn) serviceClient := schema.NewImmuServiceClient(clientConn) cli.WithServiceClient(serviceClient) if err = cli.WaitForHealthCheck(ctx); err != nil { return nil, err } immudbStateProvider := stateService.NewImmudbStateProvider(serviceClient) immudbUUIDProvider := stateService.NewImmudbUUIDProvider(serviceClient) customDir := \"custom_state_dir\" os.Mkdir(customDir, os.ModePerm) stateService, err := stateService.NewStateService( cache.NewFileCache(customDir), logger.NewSimpleLogger(\"immuclient\", os.Stderr), immudbStateProvider, immudbUUIDProvider) if err != nil { return nil, err } dt, err := timestamp.NewDefaultTimestamp() if err != nil { return nil, err } ts := c.NewTimestampService(dt) cli.WithTimestampService(ts).WithStateService(stateService) return cli, nil } ::: ::: tab Python from immudb import ImmudbClient from immudb.client import PersistentRootService # By default RootService is writing state to RAM # You can choose different implementation of RootService # Persistent root service will save to the disk after every verified transaction URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) PERSISTENT_ROOT_SERVICE_PATH = \"/tmp/psr.db\" def main(): client = ImmudbClient(URL, rs = PersistentRootService(PERSISTENT_ROOT_SERVICE_PATH)) client.login(LOGIN, PASSWORD, database = DB) client.verifiedSet(b'x', b'1') client.verifiedGet(b'x') client.verifiedSet(b'x', b'2') client.verifiedGet(b'x') if __name__ == \"__main__\": main() ::: ::: tab Java Any immudb server has its own UUID. This is exposed as part of the login response. Java SDK can use any implementation of the ImmuStateHolder interface, which specifies two methods: - ImmuState getState(String serverUuid, String database) for getting a state. - void setState(String serverUuid, ImmuState state) for setting a state. Note that a state is related to a specific database (identified by its name) and a server (identified by the UUID). Currently, Java SDK offers two implementations of this interface for storing and retriving a state: - FileImmuStateHolder that uses a disk file based store. - SerializableImmuStateHolder that uses an in-memory store. As most of the code snippets include FileImmuStateHolder , please find below an example using the in-memory alternative: SerializableImmuStateHolder stateHolder = new SerializableImmuStateHolder(); ImmuClient immuClient = ImmuClient.newBuilder() .withStateHolder(stateHolder) .withServerUrl(\"localhost\") .withServerPort(3322) .build(); immuClient.login(\"immudb\", \"immudb\"); immuClient.useDatabase(\"defaultdb\"); // ... immuClient.logout(); ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Verify state signature If immudb is launched with a private signing key, each signed request can be verified with the public key. This ensures the server identity. To run immudb server with state signature use: ./immudb --signingKey test/signer/ec1.key To generate an elliptic curve private key use: openssl ecparam -name prime256v1 -genkey -noout -out private.key To generate the public key from the previous one: openssl ec -in private.key -pubout -out public.key :::: tabs ::: tab Go c, err := client.NewImmuClient(client.DefaultOptions().WithServerSigningPubKey(\"../../immudb/src/wrong.public.key\")) if err != nil { log.Fatal(err) } ctx := context.Background() _ , err = c.Login(ctx, []byte(`immudb`), []byte(`immudb`)) if err != nil { log.Fatal(err) } if _, err = c.Set(ctx, []byte(`immudb`), []byte(`hello world`)); err != nil { log.Fatal(err) } var state *schema.ImmutableState if state, err = c.CurrentState(ctx); err != nil { log.Fatal(err) // if signature is not verified here is trigger an appropriate error } fmt.Print(state) ::: ::: tab Python from immudb import ImmudbClient # All operations are checked against public/private key pair URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) KEYFILE = \"public_signing_key.pem\" # Public key path # needs immudb server with --signingKey option enabled # pointing to corresponding private key def main(): client = ImmudbClient(URL, publicKeyFile = KEYFILE) client.login(LOGIN, PASSWORD, database = DB) client.set(b'x', b'1') client.verifiedGet(b'x') # This operation will also fail if public key # is not paired with private one used in immudb state = client.currentState() # immudb.rootService.State print(state.db) # Current selected DB print(state.txId) # Current transaction ID print(state.txHash) # Current transaction hash print(state.signature) # Current signature if __name__ == \"__main__\": main() ::: ::: tab Java // Having immudb server running with state signature enabled // (by starting it, for example using `immudb --signingKey private_key.pem`) // we provision the client with the public key file, and this implies that // state signature verification is done on the client side // each time the state is retrieved from the server. File publicKeyFile = new File(\"path/to/public_key.pem\"); immuClient = ImmuClient.newBuilder() .withServerUrl(\"localhost\") .withServerPort(3322) .withServerSigningKey(publicKeyFile.getAbsolutePath()) .build(); try { ImmuState state = immuClient.currentState(); // It should all be ok as long as the immudb server has been started with // state signature feature enabled, otherwise, this verification will fail. } catch (RuntimeException e) { // State signature failed. } ::: ::: tab Node.js import ImmudbClient from 'immudb-node' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) await cl.set({ key: 'immudb', value: 'hello world' }) const currentStateRes = await cl.currentState(); console.log('success: currentState', currentStateRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"State management"},{"location":"develop/operations/#state-management","text":"","title":"State management"},{"location":"develop/operations/#current-state","text":"Current state of immudb provides proof that clients can use to verify immudb: :::: tabs ::: tab Go state, err := client.CurrentState(ctx) if err != nil { log.Fatal(err) } fmt.Printf(\"current state is : %v\", state) ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) state = client.currentState() # immudb.rootService.State print(state.db) # Current selected DB print(state.txId) # Current transaction ID print(state.txHash) # Current transaction hash print(state.signature) # Current signature if __name__ == \"__main__\": main() ::: ::: tab Java ImmuState currState = immuClient.currentState(); System.out.printf(\"The current state is \" + currState.toString()); ::: ::: tab Node.js import ImmudbClient from 'immudb-node' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const currentStateRes = await cl.currentState() console.log('success: currentState', currentStateRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Current State"},{"location":"develop/operations/#automated-verification-of-state-by-immudb-sdk","text":"It's the responsibility of the immudb client to track the server state. That way it can check each verified read or write operation against a trusted state. :::: tabs ::: tab Go The component in charge of state handling is the StateService . To set up the stateService 3 interfaces need to be implemented and provided to the StateService constructor: * Cache interface in the cache package. Standard cache.NewFileCache provides a file state store solution. * StateProvider in the stateService package. It provides a fresh state from immudb server when the client is being initialized for the first time. Standard StateProvider provides a service that retrieve immudb first state hash from a gRPC endpoint. * UUIDProvider in the stateService package. It provides the immudb identifier. This is needed to allow the client to safely connect to multiple immudb instances. Standard UUIDProvider provides the immudb server identifier from a gRPC endpoint. Following an example how to obtain a client instance with a custom state service. func MyCustomImmuClient(options *c.Options) (cli c.ImmuClient, err error) { ctx := context.Background() cli = c.DefaultClient() options.DialOptions = cli.SetupDialOptions(options) cli.WithOptions(options) var clientConn *grpc.ClientConn if clientConn, err = cli.Connect(ctx); err != nil { return nil, err } cli.WithClientConn(clientConn) serviceClient := schema.NewImmuServiceClient(clientConn) cli.WithServiceClient(serviceClient) if err = cli.WaitForHealthCheck(ctx); err != nil { return nil, err } immudbStateProvider := stateService.NewImmudbStateProvider(serviceClient) immudbUUIDProvider := stateService.NewImmudbUUIDProvider(serviceClient) customDir := \"custom_state_dir\" os.Mkdir(customDir, os.ModePerm) stateService, err := stateService.NewStateService( cache.NewFileCache(customDir), logger.NewSimpleLogger(\"immuclient\", os.Stderr), immudbStateProvider, immudbUUIDProvider) if err != nil { return nil, err } dt, err := timestamp.NewDefaultTimestamp() if err != nil { return nil, err } ts := c.NewTimestampService(dt) cli.WithTimestampService(ts).WithStateService(stateService) return cli, nil } ::: ::: tab Python from immudb import ImmudbClient from immudb.client import PersistentRootService # By default RootService is writing state to RAM # You can choose different implementation of RootService # Persistent root service will save to the disk after every verified transaction URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) PERSISTENT_ROOT_SERVICE_PATH = \"/tmp/psr.db\" def main(): client = ImmudbClient(URL, rs = PersistentRootService(PERSISTENT_ROOT_SERVICE_PATH)) client.login(LOGIN, PASSWORD, database = DB) client.verifiedSet(b'x', b'1') client.verifiedGet(b'x') client.verifiedSet(b'x', b'2') client.verifiedGet(b'x') if __name__ == \"__main__\": main() ::: ::: tab Java Any immudb server has its own UUID. This is exposed as part of the login response. Java SDK can use any implementation of the ImmuStateHolder interface, which specifies two methods: - ImmuState getState(String serverUuid, String database) for getting a state. - void setState(String serverUuid, ImmuState state) for setting a state. Note that a state is related to a specific database (identified by its name) and a server (identified by the UUID). Currently, Java SDK offers two implementations of this interface for storing and retriving a state: - FileImmuStateHolder that uses a disk file based store. - SerializableImmuStateHolder that uses an in-memory store. As most of the code snippets include FileImmuStateHolder , please find below an example using the in-memory alternative: SerializableImmuStateHolder stateHolder = new SerializableImmuStateHolder(); ImmuClient immuClient = ImmuClient.newBuilder() .withStateHolder(stateHolder) .withServerUrl(\"localhost\") .withServerPort(3322) .build(); immuClient.login(\"immudb\", \"immudb\"); immuClient.useDatabase(\"defaultdb\"); // ... immuClient.logout(); ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Automated verification of state by immudb SDK"},{"location":"develop/operations/#verify-state-signature","text":"If immudb is launched with a private signing key, each signed request can be verified with the public key. This ensures the server identity. To run immudb server with state signature use: ./immudb --signingKey test/signer/ec1.key To generate an elliptic curve private key use: openssl ecparam -name prime256v1 -genkey -noout -out private.key To generate the public key from the previous one: openssl ec -in private.key -pubout -out public.key :::: tabs ::: tab Go c, err := client.NewImmuClient(client.DefaultOptions().WithServerSigningPubKey(\"../../immudb/src/wrong.public.key\")) if err != nil { log.Fatal(err) } ctx := context.Background() _ , err = c.Login(ctx, []byte(`immudb`), []byte(`immudb`)) if err != nil { log.Fatal(err) } if _, err = c.Set(ctx, []byte(`immudb`), []byte(`hello world`)); err != nil { log.Fatal(err) } var state *schema.ImmutableState if state, err = c.CurrentState(ctx); err != nil { log.Fatal(err) // if signature is not verified here is trigger an appropriate error } fmt.Print(state) ::: ::: tab Python from immudb import ImmudbClient # All operations are checked against public/private key pair URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) KEYFILE = \"public_signing_key.pem\" # Public key path # needs immudb server with --signingKey option enabled # pointing to corresponding private key def main(): client = ImmudbClient(URL, publicKeyFile = KEYFILE) client.login(LOGIN, PASSWORD, database = DB) client.set(b'x', b'1') client.verifiedGet(b'x') # This operation will also fail if public key # is not paired with private one used in immudb state = client.currentState() # immudb.rootService.State print(state.db) # Current selected DB print(state.txId) # Current transaction ID print(state.txHash) # Current transaction hash print(state.signature) # Current signature if __name__ == \"__main__\": main() ::: ::: tab Java // Having immudb server running with state signature enabled // (by starting it, for example using `immudb --signingKey private_key.pem`) // we provision the client with the public key file, and this implies that // state signature verification is done on the client side // each time the state is retrieved from the server. File publicKeyFile = new File(\"path/to/public_key.pem\"); immuClient = ImmuClient.newBuilder() .withServerUrl(\"localhost\") .withServerPort(3322) .withServerSigningKey(publicKeyFile.getAbsolutePath()) .build(); try { ImmuState state = immuClient.currentState(); // It should all be ok as long as the immudb server has been started with // state signature feature enabled, otherwise, this verification will fail. } catch (RuntimeException e) { // State signature failed. } ::: ::: tab Node.js import ImmudbClient from 'immudb-node' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) await cl.set({ key: 'immudb', value: 'hello world' }) const currentStateRes = await cl.currentState(); console.log('success: currentState', currentStateRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Verify state signature"},{"location":"develop/reading/","text":"Reads And Writes Most of the methods in SDKs have Verified equivalent, i.e. Get and VerifiedGet . The only difference is that with Verified methods proofs needed to mathematically verify that the data was not tampered are returned by the server and the verification is done automatically by SDKs. Note that generating that proof has a slight performance impact, so primitives are allowed without the proof. It is still possible to get the proofs for a specific item at any time, so the decision about when or how frequently to do checks (with the Verify version of a method) is completely up to the user. It's possible also to use dedicated auditors to ensure the database consistency, but the pattern in which every client is also an auditor is the more interesting one. Get and Set Get / VerifiedGet and Set / VerifiedSet methods allow for basic operations on a Key Value level. In addition, GetAll and SetAll methods allow for adding and reading in a single transaction. See transactions chapter for more details. :::: tabs ::: tab Go package main import ( \"context\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) // Without verification tx, err := client.Set(context.TODO(), []byte(`x`), []byte(`y`)) if err != nil { log.Fatal(err) } log.Printf(\"Set: tx: %d\", tx.Id) entry, err := client.Get(context.TODO(), []byte(`x`)) if err != nil { log.Fatal(err) } log.Printf(\"Get: %v\", entry) tx, err = client.SetAll(context.TODO(), &schema.SetRequest{ KVs: []*schema.KeyValue{ {Key: []byte(`1`), Value: []byte(`test1`)}, {Key: []byte(`2`), Value: []byte(`test2`)}, {Key: []byte(`3`), Value: []byte(`test3`)}, }, }) if err != nil { log.Fatal(err) } log.Printf(\"SetAll: tx: %d\", tx.Id) entries, err := client.GetAll(context.TODO(), [][]byte{[]byte(`1`), []byte(`2`), []byte(`3`)}) if err != nil { log.Fatal(err) } log.Printf(\"GetAll: %+v\", entries) // With verification tx, err = client.VerifiedSet(context.TODO(), []byte(`xx`), []byte(`yy`)) if err != nil { log.Fatal(err) } log.Printf(\"VerifiedSet: tx: %d\", tx.Id) entry, err = client.Get(context.TODO(), []byte(`xx`)) if err != nil { log.Fatal(err) } log.Printf(\"VerifiedGet: %v\", entry) } ::: ::: tab Python from immudb import ImmudbClient import json URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def encode(what: str): return what.encode(\"utf-8\") def decode(what: bytes): return what.decode(\"utf-8\") def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) # You have to operate on bytes setResult = client.set(b'x', b'y') print(setResult) # immudb.datatypes.SetResponse print(setResult.id) # id of transaction print(setResult.verified) # in this case verified = False # see Tamperproof reading and writing # Also you get response in bytes retrieved = client.get(b'x') print(retrieved) # immudb.datatypes.GetResponse print(retrieved.key) # Value is b'x' print(retrieved.value) # Value is b'y' print(retrieved.tx) # Transaction number print(type(retrieved.key)) # <class 'bytes'> print(type(retrieved.value)) # <class 'bytes'> # Operating with strings encodedHello = encode(\"Hello\") encodedImmutable = encode(\"Immutable\") client.set(encodedHello, encodedImmutable) retrieved = client.get(encodedHello) print(decode(retrieved.value) == \"Immutable\") # Value is True notExisting = client.get(b'asdasd') print(notExisting) # Value is None # JSON example toSet = {\"hello\": \"immutable\"} encodedToSet = encode(json.dumps(toSet)) client.set(encodedHello, encodedToSet) retrieved = json.loads(decode(client.get(encodedHello).value)) print(retrieved) # Value is {\"hello\": \"immutable\"} # setAll example - sets all keys to value from dictionary toSet = { b'1': b'test1', b'2': b'test2', b'3': b'test3' } client.setAll(toSet) retrieved = client.getAll(list(toSet.keys())) print(retrieved) # Value is {b'1': b'test1', b'2': b'test2', b'3': b'test3'} if __name__ == \"__main__\": main() ::: ::: tab Java String key = \"key1\"; byte[] value = new byte[]{1, 2, 3}; try { immuClient.set(key, value); } catch (CorruptedDataException e) { // ... } try { value = immuClient.get(key); } catch (Exception e) { // ... } Note that value is a primitive byte array. You can set the value of a String using: \"some string\".getBytes(StandardCharsets.UTF_8) Also, set method is overloaded to allow receiving the key parameter as a byte[] data type. ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const setReq: Parameters.Set = { key: 'hello', value: 'world' } const setRes = await cl.set(setReq) console.log('success: set', setRes) const getReq: Parameters.Get = { key: 'hello' } const getRes = await cl.get(getReq) console.log('success: get', getRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Get at and since a transaction You can retrieve a key on a specific transaction with GetAt / VerifiedGetAt . If you need to check the last value of a key after given transaction (which represent state of the indexer), you can use GetSince / VerifiedGetSince . :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) key := []byte(`123123`) var txIDs []uint64 for _, v := range [][]byte{[]byte(`111`), []byte(`222`), []byte(`333`)} { txID, err := client.Set(context.TODO(), key, v) if err != nil { log.Fatal(err) } txIDs = append(txIDs, txID.Id) } otherTxID, err := client.Set(context.TODO(), []byte(`other`), []byte(`other`)) if err != nil { log.Fatal(err) } // Without verification entry, err := client.GetSince(context.TODO(), key, txIDs[0]) if err != nil { log.Fatal(err) } log.Printf(\"GetSince first: %+v\", entry) // With verification entry, err = client.VerifiedGetSince(context.TODO(), key, txIDs[0]+1) if err != nil { log.Fatal(err) } log.Printf(\"VerifiedGetSince second: %+v\", entry) // GetAt txID after inserting other data _, err = client.GetAt(context.TODO(), key, otherTxID.Id) if err == nil { log.Fatalf(\"This should not happen, %+v\", entry) } // Without verification entry, err = client.GetAt(context.TODO(), key, txIDs[1]) if err != nil { log.Fatal(err) } log.Printf(\"GetAt second: %+v\", entry) // With verification entry, err = client.VerifiedGetAt(context.TODO(), key, txIDs[2]) if err != nil { log.Fatal(err) } log.Printf(\"VerifiedGetAt third: %+v\", entry) // VerifiedGetAt txID after inserting other data entry, err = client.VerifiedGetAt(context.TODO(), key, otherTxID.Id) if err == nil { log.Fatalf(\"This should not happen, %+v\", entry) } } ::: ::: tab Python from grpc import RpcError from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) first = client.set(b'justfirsttransaction', b'justfirsttransaction') key = b'123123' first = client.set(key, b'111') firstTransaction = first.id second = client.set(key, b'222') secondTransaction = second.id third = client.set(key, b'333') thirdTransaction = third.id print(client.verifiedGetSince(key, firstTransaction)) # b\"111\" print(client.verifiedGetSince(key, firstTransaction + 1)) # b\"222\" try: # This key wasn't set on this transaction print(client.verifiedGetAt(key, firstTransaction - 1)) except RpcError as exception: print(exception.debug_error_string()) print(exception.details()) verifiedFirst = client.verifiedGetAt(key, firstTransaction) # immudb.datatypes.SafeGetResponse print(verifiedFirst.id) # id of transaction print(verifiedFirst.key) # Key that was modified print(verifiedFirst.value) # Value after this transaction print(verifiedFirst.refkey) # Reference key # (Queries And History -> setReference) print(verifiedFirst.verified) # Response is verified or not print(verifiedFirst.timestamp) # Time of this transaction print(client.verifiedGetAt(key, secondTransaction)) print(client.verifiedGetAt(key, thirdTransaction)) try: # Transaction doesn't exists yet print(client.verifiedGetAt(key, thirdTransaction + 1)) except RpcError as exception: print(exception.debug_error_string()) print(exception.details()) if __name__ == \"__main__\": main() ::: ::: tab Java byte[] key = \"key1\".getBytes(StandardCharsets.UTF_8); byte[] val = new byte[]{1, 2, 3, 4, 5}; TxMetadata txMd = null; try { txMd = immuClient.set(key, val); } catch (CorruptedDataException e) { // ... } // The standard (traditional) get options: KV kv = immuClient.getAt(key, txMd.id); kv = immuClient.getSince(key, txMd.id); // The verified get flavours: Entry vEntry = null; try { vEntry = immuClient.verifiedGetAt(key, vEntry.txId); } catch (VerificationException e) { // ... } try { vEntry = immuClient.verifiedGetSince(key, vEntry.txId); } catch (VerificationException e) { // ... } ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const { id } = await cl.set({ key: 'key', value: 'value' }) const verifiedGetAtReq: Parameters.VerifiedGetAt = { key: 'key', attx: id } const verifiedGetAtRes = await cl.verifiedGetAt(verifiedGetAtReq) console.log('success: verifiedGetAt', verifiedGetAtRes) for (let i = 0; i < 4; i++) { await cl.set({ key: 'key', value: `value-${i}` }) } const verifiedGetSinceReq: Parameters.VerifiedGetSince = { key: 'key', sincetx: 2 } const verifiedGetSinceRes = await cl.verifiedGetSince(verifiedGetSinceReq) console.log('success: verifiedGetSince', verifiedGetSinceRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Get at revision Each historical value for a single key is attached a revision number. Revision numbers start with 1 and each overwrite of the same key results in a new sequential revision number assignment. A negative revision number can also be specified which means the nth historical value, e.g. -1 is the previous value, -2 is the one before and so on. :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) // Use dedicated API call entry, err := client.GetAtRevision(context.TODO(), []byte(\"key\"), -1) if err != nil { log.Fatal(err) } log.Printf(\"Retrieved entry at revision %d: %s\", entry.Revision, string(entry.Value)) // Use additional get option entry, err = client.Get(context.TODO(), []byte(\"key\"), immudb.AtRevision(-2)) if err != nil { log.Fatal(err) } log.Printf(\"Retrieved entry at revision %d: %s\", entry.Revision, string(entry.Value)) } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Get at TXID It's possible to retrieve all the keys inside a specific transaction. :::: tabs ::: tab Go package main import ( \"context\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) setTxFirst, err := client.SetAll(context.TODO(), &schema.SetRequest{KVs: []*schema.KeyValue{ {Key: []byte(\"key1\"), Value: []byte(\"val1\")}, {Key: []byte(\"key2\"), Value: []byte(\"val2\")}, }}) if err != nil { log.Fatal(err) } log.Printf(\"First txID: %d\", setTxFirst.Id) // Set keys in another transaction setTxSecond, err := client.SetAll(context.TODO(), &schema.SetRequest{KVs: []*schema.KeyValue{ {Key: []byte(\"key1\"), Value: []byte(\"val11\")}, {Key: []byte(\"key2\"), Value: []byte(\"val22\")}, }}) if err != nil { log.Fatal(err) } log.Printf(\"Second txID: %d\", setTxSecond.Id) // Without verification tx, err := client.TxByID(context.TODO(), setTxFirst.Id) if err != nil { log.Fatal(err) } for _, entry := range tx.Entries { item, err := client.GetAt(context.TODO(), entry.Key, setTxFirst.Id) if err != nil { log.Fatal(err) } log.Printf(\"retrieved: %+v\", item) } // With verification tx, err = client.VerifiedTxByID(context.TODO(), setTxSecond.Id) if err != nil { log.Fatal(err) } for _, entry := range tx.Entries { item, err := client.VerifiedGetAt(context.TODO(), entry.Key, setTxSecond.Id) if err != nil { log.Fatal(err) } log.Printf(\"retrieved: %+v\", item) } } ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) keyFirst = b'333' keySecond = b'555' first = client.set(keyFirst, b'111') firstTransaction = first.id second = client.set(keySecond, b'222') secondTransaction = second.id toSet = { b'1': b'test1', b'2': b'test2', b'3': b'test3' } third = client.setAll(toSet) thirdTransaction = third.id keysAtFirst = client.txById(firstTransaction) keysAtSecond = client.txById(secondTransaction) keysAtThird = client.txById(thirdTransaction) print(keysAtFirst) # [b'333'] print(keysAtSecond) # [b'555'] print(keysAtThird) # [b'1', b'2', b'3'] if __name__ == \"__main__\": main() ::: ::: tab Java TxMetadata txMd = null; try { txMd = immuClient.verifiedSet(key, val); } catch (VerificationException e) { // ... } try { Tx tx = immuClient.txById(txMd.id); } catch (MaxWidthExceededException | NoSuchAlgorithmException e) { // ... } ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const { id } = await cl.set({ key: 'key', value: 'value' }) const txByIdReq: Parameters.TxById = { tx: id } const txByIdRes = await cl.txById(txByIdReq) console.log('success: txById', txByIdRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Conditional writes immudb can check additional preconditions before the write operation is made. Precondition is checked atomically with the write operation. It can be then used to ensure consistent state of data inside the database. Following preconditions are supported: MustExist - precondition checks if given key exists in the database, this precondition takes into consideration logical deletion and data expiration, if the entry was logically deleted or has expired, MustExist precondition for such entry will fail MustNotExist - precondition checks if given key does not exist in the database, this precondition also takes into consideration logical deletion and data expiration, if the entry was logically deleted or has expired, MustNotExist precondition for such entry will succeed NotModifiedAfterTX - precondition checks if given key was not modified after given transaction id, local deletion and setting entry with expiration data is also considered modification of the entry In many cases, keys used for constraints will be the same as keys for written entries. A good example here is a situation when a value is set only if that key does not exist. This is not strictly required - keys used in constraints do not have to be the same or even overlap with keys for modified entries. An example would be if only one of two keys should exist in the database. In such case, the first key will be modified and the second key will be used for MustNotExist constraint. A write operation using precondition can not be done in an asynchronous way. Preconditions are checked twice when processing such requests - first check is done against the current state of internal index, the second check is done just before persisting the write and requires up-to-date index. Preconditions are available on SetAll , Reference and ExecAll operations. :::: tabs ::: tab Go In go sdk, the schema package contains convenient wrappers for creating constraint objects, such as schema.PreconditionKeyMustNotExist . Example - ensure modification is done atomically when there are concurrent writers entry, err := c.Get(ctx, []byte(\"key\")) if err != nil { log.Fatal(err) } newValue := modifyValue(entry.Value) _, err = c.SetAll(ctx, &schema.SetRequest{ KVs: []*schema.KeyValue{{ Key: []byte(\"key\"), Value: newValue, }}, Preconditions: []*schema.Precondition{ schema.PreconditionKeyNotModifiedAfterTX( []byte(\"key\"), entry.Tx, ), }, }) if err != nil { log.Fatal(err) } Example - allow setting the key only once tx, err := client.SetAll(ctx, &schema.SetRequest{ KVs: []*schema.KeyValue{ {Key: []byte(\"key\"), Value: []byte(\"val\")}, }, Preconditions: []*schema.Precondition{ schema.PreconditionKeyMustNotExist([]byte(\"key\")), }, }) if err != nil { log.Fatal(err) } Example - set only one key in a group of keys tx, err := client.SetAll(ctx, &schema.SetRequest{ KVs: []*schema.KeyValue{ {Key: []byte(\"key1\"), Value: []byte(\"val1\")}, }, Preconditions: []*schema.Precondition{ schema.PreconditionKeyMustNotExist([]byte(\"key2\")), schema.PreconditionKeyMustNotExist([]byte(\"key3\")), schema.PreconditionKeyMustNotExist([]byte(\"key4\")), }, }) if err != nil { log.Fatal(err) } Example - check if returned error indicates precondition failure import ( immuerrors \"github.com/codenotary/immudb/pkg/client/errors\" ) ... tx, err := client.SetAll(ctx, &schema.SetRequest{ KVs: []*schema.KeyValue{ {Key: []byte(\"key\"), Value: []byte(\"val\")}, }, Preconditions: []*schema.Precondition{ schema.PreconditionKeyMustExist([]byte(\"key\")), }, }) immuErr := immuerrors.FromError(err) if immuErr != nil && immuErr.Code() == immuerrors.CodIntegrityConstraintViolation { log.Println(\"Constraint validation failed\") } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Reads And Writes"},{"location":"develop/reading/#reads-and-writes","text":"Most of the methods in SDKs have Verified equivalent, i.e. Get and VerifiedGet . The only difference is that with Verified methods proofs needed to mathematically verify that the data was not tampered are returned by the server and the verification is done automatically by SDKs. Note that generating that proof has a slight performance impact, so primitives are allowed without the proof. It is still possible to get the proofs for a specific item at any time, so the decision about when or how frequently to do checks (with the Verify version of a method) is completely up to the user. It's possible also to use dedicated auditors to ensure the database consistency, but the pattern in which every client is also an auditor is the more interesting one.","title":"Reads And Writes"},{"location":"develop/reading/#get-and-set","text":"Get / VerifiedGet and Set / VerifiedSet methods allow for basic operations on a Key Value level. In addition, GetAll and SetAll methods allow for adding and reading in a single transaction. See transactions chapter for more details. :::: tabs ::: tab Go package main import ( \"context\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) // Without verification tx, err := client.Set(context.TODO(), []byte(`x`), []byte(`y`)) if err != nil { log.Fatal(err) } log.Printf(\"Set: tx: %d\", tx.Id) entry, err := client.Get(context.TODO(), []byte(`x`)) if err != nil { log.Fatal(err) } log.Printf(\"Get: %v\", entry) tx, err = client.SetAll(context.TODO(), &schema.SetRequest{ KVs: []*schema.KeyValue{ {Key: []byte(`1`), Value: []byte(`test1`)}, {Key: []byte(`2`), Value: []byte(`test2`)}, {Key: []byte(`3`), Value: []byte(`test3`)}, }, }) if err != nil { log.Fatal(err) } log.Printf(\"SetAll: tx: %d\", tx.Id) entries, err := client.GetAll(context.TODO(), [][]byte{[]byte(`1`), []byte(`2`), []byte(`3`)}) if err != nil { log.Fatal(err) } log.Printf(\"GetAll: %+v\", entries) // With verification tx, err = client.VerifiedSet(context.TODO(), []byte(`xx`), []byte(`yy`)) if err != nil { log.Fatal(err) } log.Printf(\"VerifiedSet: tx: %d\", tx.Id) entry, err = client.Get(context.TODO(), []byte(`xx`)) if err != nil { log.Fatal(err) } log.Printf(\"VerifiedGet: %v\", entry) } ::: ::: tab Python from immudb import ImmudbClient import json URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def encode(what: str): return what.encode(\"utf-8\") def decode(what: bytes): return what.decode(\"utf-8\") def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) # You have to operate on bytes setResult = client.set(b'x', b'y') print(setResult) # immudb.datatypes.SetResponse print(setResult.id) # id of transaction print(setResult.verified) # in this case verified = False # see Tamperproof reading and writing # Also you get response in bytes retrieved = client.get(b'x') print(retrieved) # immudb.datatypes.GetResponse print(retrieved.key) # Value is b'x' print(retrieved.value) # Value is b'y' print(retrieved.tx) # Transaction number print(type(retrieved.key)) # <class 'bytes'> print(type(retrieved.value)) # <class 'bytes'> # Operating with strings encodedHello = encode(\"Hello\") encodedImmutable = encode(\"Immutable\") client.set(encodedHello, encodedImmutable) retrieved = client.get(encodedHello) print(decode(retrieved.value) == \"Immutable\") # Value is True notExisting = client.get(b'asdasd') print(notExisting) # Value is None # JSON example toSet = {\"hello\": \"immutable\"} encodedToSet = encode(json.dumps(toSet)) client.set(encodedHello, encodedToSet) retrieved = json.loads(decode(client.get(encodedHello).value)) print(retrieved) # Value is {\"hello\": \"immutable\"} # setAll example - sets all keys to value from dictionary toSet = { b'1': b'test1', b'2': b'test2', b'3': b'test3' } client.setAll(toSet) retrieved = client.getAll(list(toSet.keys())) print(retrieved) # Value is {b'1': b'test1', b'2': b'test2', b'3': b'test3'} if __name__ == \"__main__\": main() ::: ::: tab Java String key = \"key1\"; byte[] value = new byte[]{1, 2, 3}; try { immuClient.set(key, value); } catch (CorruptedDataException e) { // ... } try { value = immuClient.get(key); } catch (Exception e) { // ... } Note that value is a primitive byte array. You can set the value of a String using: \"some string\".getBytes(StandardCharsets.UTF_8) Also, set method is overloaded to allow receiving the key parameter as a byte[] data type. ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const setReq: Parameters.Set = { key: 'hello', value: 'world' } const setRes = await cl.set(setReq) console.log('success: set', setRes) const getReq: Parameters.Get = { key: 'hello' } const getRes = await cl.get(getReq) console.log('success: get', getRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Get and Set"},{"location":"develop/reading/#get-at-and-since-a-transaction","text":"You can retrieve a key on a specific transaction with GetAt / VerifiedGetAt . If you need to check the last value of a key after given transaction (which represent state of the indexer), you can use GetSince / VerifiedGetSince . :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) key := []byte(`123123`) var txIDs []uint64 for _, v := range [][]byte{[]byte(`111`), []byte(`222`), []byte(`333`)} { txID, err := client.Set(context.TODO(), key, v) if err != nil { log.Fatal(err) } txIDs = append(txIDs, txID.Id) } otherTxID, err := client.Set(context.TODO(), []byte(`other`), []byte(`other`)) if err != nil { log.Fatal(err) } // Without verification entry, err := client.GetSince(context.TODO(), key, txIDs[0]) if err != nil { log.Fatal(err) } log.Printf(\"GetSince first: %+v\", entry) // With verification entry, err = client.VerifiedGetSince(context.TODO(), key, txIDs[0]+1) if err != nil { log.Fatal(err) } log.Printf(\"VerifiedGetSince second: %+v\", entry) // GetAt txID after inserting other data _, err = client.GetAt(context.TODO(), key, otherTxID.Id) if err == nil { log.Fatalf(\"This should not happen, %+v\", entry) } // Without verification entry, err = client.GetAt(context.TODO(), key, txIDs[1]) if err != nil { log.Fatal(err) } log.Printf(\"GetAt second: %+v\", entry) // With verification entry, err = client.VerifiedGetAt(context.TODO(), key, txIDs[2]) if err != nil { log.Fatal(err) } log.Printf(\"VerifiedGetAt third: %+v\", entry) // VerifiedGetAt txID after inserting other data entry, err = client.VerifiedGetAt(context.TODO(), key, otherTxID.Id) if err == nil { log.Fatalf(\"This should not happen, %+v\", entry) } } ::: ::: tab Python from grpc import RpcError from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) first = client.set(b'justfirsttransaction', b'justfirsttransaction') key = b'123123' first = client.set(key, b'111') firstTransaction = first.id second = client.set(key, b'222') secondTransaction = second.id third = client.set(key, b'333') thirdTransaction = third.id print(client.verifiedGetSince(key, firstTransaction)) # b\"111\" print(client.verifiedGetSince(key, firstTransaction + 1)) # b\"222\" try: # This key wasn't set on this transaction print(client.verifiedGetAt(key, firstTransaction - 1)) except RpcError as exception: print(exception.debug_error_string()) print(exception.details()) verifiedFirst = client.verifiedGetAt(key, firstTransaction) # immudb.datatypes.SafeGetResponse print(verifiedFirst.id) # id of transaction print(verifiedFirst.key) # Key that was modified print(verifiedFirst.value) # Value after this transaction print(verifiedFirst.refkey) # Reference key # (Queries And History -> setReference) print(verifiedFirst.verified) # Response is verified or not print(verifiedFirst.timestamp) # Time of this transaction print(client.verifiedGetAt(key, secondTransaction)) print(client.verifiedGetAt(key, thirdTransaction)) try: # Transaction doesn't exists yet print(client.verifiedGetAt(key, thirdTransaction + 1)) except RpcError as exception: print(exception.debug_error_string()) print(exception.details()) if __name__ == \"__main__\": main() ::: ::: tab Java byte[] key = \"key1\".getBytes(StandardCharsets.UTF_8); byte[] val = new byte[]{1, 2, 3, 4, 5}; TxMetadata txMd = null; try { txMd = immuClient.set(key, val); } catch (CorruptedDataException e) { // ... } // The standard (traditional) get options: KV kv = immuClient.getAt(key, txMd.id); kv = immuClient.getSince(key, txMd.id); // The verified get flavours: Entry vEntry = null; try { vEntry = immuClient.verifiedGetAt(key, vEntry.txId); } catch (VerificationException e) { // ... } try { vEntry = immuClient.verifiedGetSince(key, vEntry.txId); } catch (VerificationException e) { // ... } ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const { id } = await cl.set({ key: 'key', value: 'value' }) const verifiedGetAtReq: Parameters.VerifiedGetAt = { key: 'key', attx: id } const verifiedGetAtRes = await cl.verifiedGetAt(verifiedGetAtReq) console.log('success: verifiedGetAt', verifiedGetAtRes) for (let i = 0; i < 4; i++) { await cl.set({ key: 'key', value: `value-${i}` }) } const verifiedGetSinceReq: Parameters.VerifiedGetSince = { key: 'key', sincetx: 2 } const verifiedGetSinceRes = await cl.verifiedGetSince(verifiedGetSinceReq) console.log('success: verifiedGetSince', verifiedGetSinceRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Get at and since a transaction"},{"location":"develop/reading/#get-at-revision","text":"Each historical value for a single key is attached a revision number. Revision numbers start with 1 and each overwrite of the same key results in a new sequential revision number assignment. A negative revision number can also be specified which means the nth historical value, e.g. -1 is the previous value, -2 is the one before and so on. :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) // Use dedicated API call entry, err := client.GetAtRevision(context.TODO(), []byte(\"key\"), -1) if err != nil { log.Fatal(err) } log.Printf(\"Retrieved entry at revision %d: %s\", entry.Revision, string(entry.Value)) // Use additional get option entry, err = client.Get(context.TODO(), []byte(\"key\"), immudb.AtRevision(-2)) if err != nil { log.Fatal(err) } log.Printf(\"Retrieved entry at revision %d: %s\", entry.Revision, string(entry.Value)) } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Get at revision"},{"location":"develop/reading/#get-at-txid","text":"It's possible to retrieve all the keys inside a specific transaction. :::: tabs ::: tab Go package main import ( \"context\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) setTxFirst, err := client.SetAll(context.TODO(), &schema.SetRequest{KVs: []*schema.KeyValue{ {Key: []byte(\"key1\"), Value: []byte(\"val1\")}, {Key: []byte(\"key2\"), Value: []byte(\"val2\")}, }}) if err != nil { log.Fatal(err) } log.Printf(\"First txID: %d\", setTxFirst.Id) // Set keys in another transaction setTxSecond, err := client.SetAll(context.TODO(), &schema.SetRequest{KVs: []*schema.KeyValue{ {Key: []byte(\"key1\"), Value: []byte(\"val11\")}, {Key: []byte(\"key2\"), Value: []byte(\"val22\")}, }}) if err != nil { log.Fatal(err) } log.Printf(\"Second txID: %d\", setTxSecond.Id) // Without verification tx, err := client.TxByID(context.TODO(), setTxFirst.Id) if err != nil { log.Fatal(err) } for _, entry := range tx.Entries { item, err := client.GetAt(context.TODO(), entry.Key, setTxFirst.Id) if err != nil { log.Fatal(err) } log.Printf(\"retrieved: %+v\", item) } // With verification tx, err = client.VerifiedTxByID(context.TODO(), setTxSecond.Id) if err != nil { log.Fatal(err) } for _, entry := range tx.Entries { item, err := client.VerifiedGetAt(context.TODO(), entry.Key, setTxSecond.Id) if err != nil { log.Fatal(err) } log.Printf(\"retrieved: %+v\", item) } } ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) keyFirst = b'333' keySecond = b'555' first = client.set(keyFirst, b'111') firstTransaction = first.id second = client.set(keySecond, b'222') secondTransaction = second.id toSet = { b'1': b'test1', b'2': b'test2', b'3': b'test3' } third = client.setAll(toSet) thirdTransaction = third.id keysAtFirst = client.txById(firstTransaction) keysAtSecond = client.txById(secondTransaction) keysAtThird = client.txById(thirdTransaction) print(keysAtFirst) # [b'333'] print(keysAtSecond) # [b'555'] print(keysAtThird) # [b'1', b'2', b'3'] if __name__ == \"__main__\": main() ::: ::: tab Java TxMetadata txMd = null; try { txMd = immuClient.verifiedSet(key, val); } catch (VerificationException e) { // ... } try { Tx tx = immuClient.txById(txMd.id); } catch (MaxWidthExceededException | NoSuchAlgorithmException e) { // ... } ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const { id } = await cl.set({ key: 'key', value: 'value' }) const txByIdReq: Parameters.TxById = { tx: id } const txByIdRes = await cl.txById(txByIdReq) console.log('success: txById', txByIdRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Get at TXID"},{"location":"develop/reading/#conditional-writes","text":"immudb can check additional preconditions before the write operation is made. Precondition is checked atomically with the write operation. It can be then used to ensure consistent state of data inside the database. Following preconditions are supported: MustExist - precondition checks if given key exists in the database, this precondition takes into consideration logical deletion and data expiration, if the entry was logically deleted or has expired, MustExist precondition for such entry will fail MustNotExist - precondition checks if given key does not exist in the database, this precondition also takes into consideration logical deletion and data expiration, if the entry was logically deleted or has expired, MustNotExist precondition for such entry will succeed NotModifiedAfterTX - precondition checks if given key was not modified after given transaction id, local deletion and setting entry with expiration data is also considered modification of the entry In many cases, keys used for constraints will be the same as keys for written entries. A good example here is a situation when a value is set only if that key does not exist. This is not strictly required - keys used in constraints do not have to be the same or even overlap with keys for modified entries. An example would be if only one of two keys should exist in the database. In such case, the first key will be modified and the second key will be used for MustNotExist constraint. A write operation using precondition can not be done in an asynchronous way. Preconditions are checked twice when processing such requests - first check is done against the current state of internal index, the second check is done just before persisting the write and requires up-to-date index. Preconditions are available on SetAll , Reference and ExecAll operations. :::: tabs ::: tab Go In go sdk, the schema package contains convenient wrappers for creating constraint objects, such as schema.PreconditionKeyMustNotExist .","title":"Conditional writes"},{"location":"develop/reading/#example-ensure-modification-is-done-atomically-when-there-are-concurrent-writers","text":"entry, err := c.Get(ctx, []byte(\"key\")) if err != nil { log.Fatal(err) } newValue := modifyValue(entry.Value) _, err = c.SetAll(ctx, &schema.SetRequest{ KVs: []*schema.KeyValue{{ Key: []byte(\"key\"), Value: newValue, }}, Preconditions: []*schema.Precondition{ schema.PreconditionKeyNotModifiedAfterTX( []byte(\"key\"), entry.Tx, ), }, }) if err != nil { log.Fatal(err) }","title":"Example - ensure modification is done atomically when there are concurrent writers"},{"location":"develop/reading/#example-allow-setting-the-key-only-once","text":"tx, err := client.SetAll(ctx, &schema.SetRequest{ KVs: []*schema.KeyValue{ {Key: []byte(\"key\"), Value: []byte(\"val\")}, }, Preconditions: []*schema.Precondition{ schema.PreconditionKeyMustNotExist([]byte(\"key\")), }, }) if err != nil { log.Fatal(err) }","title":"Example - allow setting the key only once"},{"location":"develop/reading/#example-set-only-one-key-in-a-group-of-keys","text":"tx, err := client.SetAll(ctx, &schema.SetRequest{ KVs: []*schema.KeyValue{ {Key: []byte(\"key1\"), Value: []byte(\"val1\")}, }, Preconditions: []*schema.Precondition{ schema.PreconditionKeyMustNotExist([]byte(\"key2\")), schema.PreconditionKeyMustNotExist([]byte(\"key3\")), schema.PreconditionKeyMustNotExist([]byte(\"key4\")), }, }) if err != nil { log.Fatal(err) }","title":"Example - set only one key in a group of keys"},{"location":"develop/reading/#example-check-if-returned-error-indicates-precondition-failure","text":"import ( immuerrors \"github.com/codenotary/immudb/pkg/client/errors\" ) ... tx, err := client.SetAll(ctx, &schema.SetRequest{ KVs: []*schema.KeyValue{ {Key: []byte(\"key\"), Value: []byte(\"val\")}, }, Preconditions: []*schema.Precondition{ schema.PreconditionKeyMustExist([]byte(\"key\")), }, }) immuErr := immuerrors.FromError(err) if immuErr != nil && immuErr.Code() == immuerrors.CodIntegrityConstraintViolation { log.Println(\"Constraint validation failed\") } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Example - check if returned error indicates precondition failure"},{"location":"develop/streams/","text":"Streams immudb provides stream capabilities. Internally it uses \u201cdelimited\u201d messages technique, every chunk has a trailer that describe the length of the message. In this way the receiver can recompose chunk by chunk the original payload. Stream methods accepts a readers as a part of input and output arguments. In this way the large value is decomposed in small chunks that are streamed over the wire. Client don't need to allocate the entire value when sending and can read the received one progressively. For example a client could send a large file much greater than available ram memory. At the moment immudb is not yet able to write the data without allocating the entire received object, but in the next release it will be possible a complete communication without allocations. The maximum size of a transaction sent with streams is temporarily limited to a payload of 32M. Supported stream method now available in the SDK are: StreamSet StreamGet StreamVerifiedSet StreamVerifiedGet StreamScan StreamZScan StreamHistory StreamExecAll :::: tabs ::: tab Go Here an example on how to send a large file and a regular key value to immudb. It's possible to specify the chunk size of the stream with WithStreamChunkSize() method. client, err := immuclient.NewImmuClient(immuclient.DefaultOptions().WithStreamChunkSize(4096)) if err != nil { log.Fatal(err) } ctx := context.Background() _, err = client.Login(ctx, []byte(`immudb`), []byte(`immudb`)) if err != nil { log.Fatal(err) } myFileName := \"streams.go\" key1 := []byte(\"key1\") val1 := []byte(\"val1\") f, err := os.Open(myFileName) if err != nil { log.Fatal(err) } stats, err := os.Stat(myFileName) if err != nil { log.Fatal(err) } kv1 := &stream.KeyValue{ Key: &stream.ValueSize{ Content: bytes.NewBuffer(key1), Size: len(key1), }, Value: &stream.ValueSize{ Content: bytes.NewBuffer(val1), Size: len(val1), }, } kv2 := &stream.KeyValue{ Key: &stream.ValueSize{ Content: bytes.NewBuffer([]byte(myFileName)), Size: len(myFileName), }, Value: &stream.ValueSize{ Content: f, Size: int(stats.Size()), }, } kvs := []*stream.KeyValue{kv1, kv2} _, err = client.StreamSet(ctx, kvs) if err != nil { log.Fatal(err) } entry, err := client.StreamGet(ctx, &schema.KeyRequest{ Key: []byte(myFileName)}) if err != nil { log.Fatal(err) } fmt.Printf(\"returned key %s\", entry.Key) ::: ::: tab Java Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Chunked reading It's possible to read returned value chunk by chunk if needed. This grant to the clients capabilities to handle data coming from immudb chunk by chunk :::: tabs ::: tab Go To read chunk by chunk the inner gRPC protobuffer client is needed. Then it's possible to use kvStreamReceiver to retrieve the key and a value reader. Such reader will fill provided byte array with received data and will return the number of read bytes or error. If no message is present it returns 0 and io.EOF. If the message is complete it returns 0 and nil, in that case successive calls to Read will returns a new message. There are several receivers available (zStreamReceiver, vEntryStreamReceiver, execAllStreamReceiver) and also a primitive receiver MsgReceiver. The last one can be used to receive a simple row []byte message without additional logics. sc := client.GetServiceClient() gs, err := sc.StreamGet(ctx, &schema.KeyRequest{ Key: []byte(myFileName)}) if err != nil { log.Fatal(err) } kvr := stream.NewKvStreamReceiver(stream.NewMsgReceiver(gs), stream.DefaultChunkSize) key, vr, err := kvr.Next() if err != nil { log.Fatal(err) } fmt.Printf(\"read %s key\", key) chunk := make([]byte, 4096) for { l, err := vr.Read(chunk) if err != nil && err != io.EOF { log.Fatal(err) } if err == io.EOF { break } fmt.Printf(\"read %d byte\\n\", l) } ::: ::: tab Java Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Streams"},{"location":"develop/streams/#streams","text":"immudb provides stream capabilities. Internally it uses \u201cdelimited\u201d messages technique, every chunk has a trailer that describe the length of the message. In this way the receiver can recompose chunk by chunk the original payload. Stream methods accepts a readers as a part of input and output arguments. In this way the large value is decomposed in small chunks that are streamed over the wire. Client don't need to allocate the entire value when sending and can read the received one progressively. For example a client could send a large file much greater than available ram memory. At the moment immudb is not yet able to write the data without allocating the entire received object, but in the next release it will be possible a complete communication without allocations. The maximum size of a transaction sent with streams is temporarily limited to a payload of 32M. Supported stream method now available in the SDK are: StreamSet StreamGet StreamVerifiedSet StreamVerifiedGet StreamScan StreamZScan StreamHistory StreamExecAll :::: tabs ::: tab Go Here an example on how to send a large file and a regular key value to immudb. It's possible to specify the chunk size of the stream with WithStreamChunkSize() method. client, err := immuclient.NewImmuClient(immuclient.DefaultOptions().WithStreamChunkSize(4096)) if err != nil { log.Fatal(err) } ctx := context.Background() _, err = client.Login(ctx, []byte(`immudb`), []byte(`immudb`)) if err != nil { log.Fatal(err) } myFileName := \"streams.go\" key1 := []byte(\"key1\") val1 := []byte(\"val1\") f, err := os.Open(myFileName) if err != nil { log.Fatal(err) } stats, err := os.Stat(myFileName) if err != nil { log.Fatal(err) } kv1 := &stream.KeyValue{ Key: &stream.ValueSize{ Content: bytes.NewBuffer(key1), Size: len(key1), }, Value: &stream.ValueSize{ Content: bytes.NewBuffer(val1), Size: len(val1), }, } kv2 := &stream.KeyValue{ Key: &stream.ValueSize{ Content: bytes.NewBuffer([]byte(myFileName)), Size: len(myFileName), }, Value: &stream.ValueSize{ Content: f, Size: int(stats.Size()), }, } kvs := []*stream.KeyValue{kv1, kv2} _, err = client.StreamSet(ctx, kvs) if err != nil { log.Fatal(err) } entry, err := client.StreamGet(ctx, &schema.KeyRequest{ Key: []byte(myFileName)}) if err != nil { log.Fatal(err) } fmt.Printf(\"returned key %s\", entry.Key) ::: ::: tab Java Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Streams"},{"location":"develop/streams/#chunked-reading","text":"It's possible to read returned value chunk by chunk if needed. This grant to the clients capabilities to handle data coming from immudb chunk by chunk :::: tabs ::: tab Go To read chunk by chunk the inner gRPC protobuffer client is needed. Then it's possible to use kvStreamReceiver to retrieve the key and a value reader. Such reader will fill provided byte array with received data and will return the number of read bytes or error. If no message is present it returns 0 and io.EOF. If the message is complete it returns 0 and nil, in that case successive calls to Read will returns a new message. There are several receivers available (zStreamReceiver, vEntryStreamReceiver, execAllStreamReceiver) and also a primitive receiver MsgReceiver. The last one can be used to receive a simple row []byte message without additional logics. sc := client.GetServiceClient() gs, err := sc.StreamGet(ctx, &schema.KeyRequest{ Key: []byte(myFileName)}) if err != nil { log.Fatal(err) } kvr := stream.NewKvStreamReceiver(stream.NewMsgReceiver(gs), stream.DefaultChunkSize) key, vr, err := kvr.Next() if err != nil { log.Fatal(err) } fmt.Printf(\"read %s key\", key) chunk := make([]byte, 4096) for { l, err := vr.Read(chunk) if err != nil && err != io.EOF { log.Fatal(err) } if err == io.EOF { break } fmt.Printf(\"read %d byte\\n\", l) } ::: ::: tab Java Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Node.js Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net Streams is not supported yet in this language SDK. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Chunked reading"},{"location":"develop/transactions/","text":"Transactions GetAll , SetAll and ExecAll are the foundation of transactions at key value level in immudb. They allow the execution of a group of commands in a single step, with two important guarantees: All the commands in a transaction are serialized and executed sequentially. No request issued by another client can ever interrupt the execution of a transaction. This guarantees that the commands are executed as a single isolated operation. Either all of the commands are processed, or none are, so the transaction is also atomic. GetAll :::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) _, err = client.Set(context.TODO(), []byte(`key1`), []byte(`val1`)) if err != nil { log.Fatal(err) } _, err = client.Set(context.TODO(), []byte(`key2`), []byte(`val2`)) if err != nil { log.Fatal(err) } itList, err := client.GetAll(context.TODO(), [][]byte{ []byte(\"key1\"), []byte(\"key2\"), []byte(\"key3\"), // does not exist, no value returned }) log.Printf(\"Set: tx: %+v\", itList) } ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.set(b'key1', b'value1') client.set(b'key2', b'value2') client.set(b'key3', b'value3') response = client.getAll([b'key1', b'key2', b'key3']) print(response) # The same as dictToSetGet, retrieved in one step if __name__ == \"__main__\": main() ::: ::: tab Java // Using getAll: List<String> keys = Arrays.asList(\"key1\", \"key2\", \"key3\"); List<KV> got = immuClient.getAll(keys); // Using execAll for setting multiple KVs at once: byte[] item1 = \"execAll_key1\".getBytes(StandardCharsets.UTF_8); byte[] item2 = \"execAll_key2\".getBytes(StandardCharsets.UTF_8); immuClient.execAll( Arrays.asList( // Providing just a kvList, which is a List< Pair<byte[], byte[]> >. Pair.of(item1, item1), Pair.of(item2, item2) ), null, // No refList provided. null // No zaddList provided. ); // Using execAll for setting multiple references and doing zAdd(s): immuClient.execAll( null, // No kvList provided. Arrays.asList( // The refList. Pair.of(\"ref1\".getBytes(StandardCharsets.UTF_8), item1), Pair.of(\"ref2\".getBytes(StandardCharsets.UTF_8), item2) ), // The zaddList. Collections.singletonList(Triple.of(\"set1\", 1.0, \"execAll_key1\")) ); ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const getAllReq: Parameters.GetAll = { keysList: ['key1', 'key2', 'key3'], sincetx: 0 } const getAllRes = await cl.getAll(getAllReq) console.log('success: getAll', getAllRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: SetAll A more versatile atomic multi set operation :::: tabs SetBatch and GetBatch example ::: tab Go package main import ( \"context\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) tx, err := client.SetAll(context.TODO(), &schema.SetRequest{ KVs: []*schema.KeyValue{ {Key: []byte(`1`), Value: []byte(`key1`)}, {Key: []byte(`2`), Value: []byte(`key2`)}, {Key: []byte(`3`), Value: []byte(`key3`)}, }, }) if err != nil { log.Fatal(err) } log.Printf(\"SetAll: tx: %d\", tx.Id) } ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) dictToSetGet = { b'key1': b'value1', b'key2': b'value2', b'key3': b'value3' } response = client.setAll(dictToSetGet) print(response.id) # All in one transaction response = client.getAll([b'key1', b'key2', b'key3']) print(response) # The same as dictToSetGet, retrieved in one step if __name__ == \"__main__\": main() ::: ::: tab Java List<KV> kvs = Arrays.asList( new KVPair(\"key1\", \"val1\".getBytes(StandardCharsets.UTF_8)), new KVPair(\"key2\", \"val2\".getBytes(StandardCharsets.UTF_8)), ); KVList kvList = KVList.newBuilder().addAll(kvs).build(); try { immuClient.setAll(kvList); } catch (CorruptedDataException e) { // ... } ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const setAllReq: Parameters.SetAll = { kvsList: [ { key: '1,2,3', value: '3,2,1' }, { key: '4,5,6', value: '6,5,4' }, ] } const setAllRes = await cl.setAll(setAllReq) console.log('success: setAll', setAllRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: ExecAll ExecAll allows multiple insertions at once. The difference is that it is possible to specify a list of mixes of key/value sets, references and zAdd insertions. The argument of a ExecAll is an array of the following types: Op_Kv : ordinary key value item Op_ZAdd : ZAdd option element Op_Ref : Reference option element It's possible to persist and reference items that are already persisted on disk. In that case is mandatory to provide the index of the referenced item. This has to be done for: Op_ZAdd Op_Ref If zAdd or reference is not yet persisted on disk it's possible to add it as a regular key value and the reference is done only. In that case if BoundRef is true the reference is bounded to the current transaction values. :::: tabs ::: tab Go package main import ( \"context\" \"encoding/json\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) idx, err := client.Set(context.TODO(), []byte(`persistedKey`), []byte(`persistedVal`)) if err != nil { log.Fatal(err) } aOps := &schema.ExecAllRequest{ Operations: []*schema.Op{ { Operation: &schema.Op_Kv{ Kv: &schema.KeyValue{ Key: []byte(`notPersistedKey`), Value: []byte(`notPersistedVal`), }, }, }, { Operation: &schema.Op_ZAdd{ ZAdd: &schema.ZAddRequest{ Set: []byte(`mySet`), Score: 0.4, Key: []byte(`notPersistedKey`)}, }, }, { Operation: &schema.Op_ZAdd{ ZAdd: &schema.ZAddRequest{ Set: []byte(`mySet`), Score: 0.6, Key: []byte(`persistedKey`), AtTx: idx.Id, BoundRef: true, }, }, }, }, } idx, err = client.ExecAll(context.TODO(), aOps) if err != nil { log.Fatal(err) } list, err := client.ZScan(context.TODO(), &schema.ZScanRequest{ Set: []byte(`mySet`), SinceTx: idx.Id, NoWait: true, }) if err != nil { log.Fatal(err) } s, _ := json.MarshalIndent(list, \"\", \"\\t\") log.Print(string(s)) } ::: ::: tab Python from immudb import ImmudbClient from immudb.datatypes import KeyValue, ZAddRequest, ReferenceRequest URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) toExecute = [ KeyValue(b'key', b'value'), ZAddRequest(b'testscore', 100, b'key'), KeyValue(b'key2', b'value2'), ZAddRequest(b'testscore', 150, b'key2'), ReferenceRequest(b'reference1', b'key') ] info = client.execAll(toExecute) print(info.id) # All in one transaction print(client.zScan(b'testscore', b'', 0, 0, True, 10, True, 0, 200)) # Shows these entries print(client.get(b'reference1')) if __name__ == \"__main__\": main() ::: ::: tab Java byte[] item1 = \"execAll_key1\".getBytes(StandardCharsets.UTF_8); byte[] item2 = \"execAll_key2\".getBytes(StandardCharsets.UTF_8); // Using execAll just for setting multiple KVs: TxMetadata txMd = immuClient.execAll( Arrays.asList( // The kvList. Pair.of(item1, item1), Pair.of(item2, item2) ), null, // No refList provided. null // No zaddList provided. ); immuClient.execAll( null, // No kvList provided. Arrays.asList( // The refList. Pair.of(\"ref1\".getBytes(StandardCharsets.UTF_8), item1), Pair.of(\"ref2\".getBytes(StandardCharsets.UTF_8), item2) ), // The zaddList (even if it has one single entry). Collections.singletonList(Triple.of(\"set1\", 1.0, \"execAll_key1\")) ); ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const { id } = await cl.set({ key: 'persistedKey', value: 'persistedVal' }) const setOperation = { kv: { key: 'notPersistedKey', value: 'notPersistedVal' } } const zAddOperation = { zadd: { set: 'mySet', score: 0.6, key: 'notPersistedKey', attx: 0, boundref: true } } const zAddOperation1 = { zadd: { set: 'mySet', score: 0.6, key: 'persistedKey', attx: id, boundref: true } } const execAllReq: Parameters.ExecAll = { operationsList: [ setOperation, zAddOperation, zAddOperation1, ] } const execAllRes = await cl.execAll(execAllReq) console.log('success: execAll', execAllRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: TxScan TxScan permits iterating over transactions. The argument of a TxScan is an array of the following types: InitialTx : initial transaction id Limit : number of transactions returned Desc : order of returned transacations :::: tabs ::: tab Go package main import ( \"context\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) tx, err := client.Set(context.TODO(), []byte(\"key1\"), []byte(\"val1\")) if err != nil { log.Fatal(err) } _, err = client.Set(context.TODO(), []byte(\"key2\"), []byte(\"val2\")) if err != nil { log.Fatal(err) } _, err = client.Set(context.TODO(), []byte(\"key3\"), []byte(\"val3\")) if err != nil { log.Fatal(err) } txs, err := client.TxScan(context.TODO(), &schema.TxScanRequest{ InitialTx: tx.Id, Limit: 3, Desc: true, }) if err != nil { log.Fatal(err) } // Then it's possible to retrieve entries of every transactions: for _, tx := range txs.GetTxs() { for _, entry := range tx.Entries { item, err := client.GetAt(context.TODO(), entry.Key[1:], tx.Header.Id) if err != nil { item, err = client.GetAt(context.TODO(), entry.Key, tx.Header.Id) if err != nil { log.Fatal(err) } } log.Printf(\"retrieved key %s and val %s\\n\", item.Key, item.Value) } } } Remember to strip the first byte in the key (key prefix). Remember that a transaction could contain sorted sets keys that should not be skipped. ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java String key = \"txtest-t2\"; byte[] val1 = \"immuRocks!\".getBytes(StandardCharsets.UTF_8); byte[] val2 = \"immuRocks! Again!\".getBytes(StandardCharsets.UTF_8); long initialTxId = 1; try { TxMetadata txMd = immuClient.set(key, val1); initialTxId = txMd.id; txMd = immuClient.set(key, val2); } catch (CorruptedDataException e) { Assert.fail(\"Failed at set.\", e); } // This is a .txScan(initialTxId, limit, desc) List<Tx> txs = immuClient.txScan(initialTxId, 1, false); // We expect one Tx entry in this list. txs = immuClient.txScan(initialTxId, 2, false); // We expect two Tx entries in this list. ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) for (let i = 0; i < 3; i++) { await cl.set({ key: `key${i}`, value: `val${i}` }) } const txScanReq: Parameters.TxScan = { initialtx: 2, limit: 3, desc: false } const txScanRes = await cl.txScan(txScanReq) console.log('success: txScan', txScanRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: :::: Filter Transactions The transaction entries are generated by writing key-value pairs, referencing keys, associating scores to key-value pairs (with ZAdd operation), and by mapping SQL data model into key-value model. With TxScan or TxByIDWithSpec operations it's possible to retrieve entries of certain types, either retrieving the digest of the value assigned to the key ( EntryTypeAction_ONLY_DIGEST ), the raw value ( EntryTypeAction_RAW_VALUE ) or the structured value ( EntryTypeAction_RESOLVE ). :::: tabs ::: tab Go package main import ( \"context\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) hdr, err := client.ExecAll(context.TODO(), &schema.ExecAllRequest{ Operations: []*schema.Op{ { Operation: &schema.Op_Kv{ Kv: &schema.KeyValue{ Key: []byte(\"key1\"), Value: []byte(\"value1\"), }, }, }, { Operation: &schema.Op_Ref{ Ref: &schema.ReferenceRequest{ Key: []byte(\"ref1\"), ReferencedKey: []byte(\"key1\"), }, }, }, { Operation: &schema.Op_ZAdd{ ZAdd: &schema.ZAddRequest{ Set: []byte(\"set1\"), Score: 10, Key: []byte(\"key1\"), }, }, }, }, }) // fetch kv and sorted-set entries as structured values while skipping sql-related entries tx, err := client.TxByIDWithSpec(context.TODO(), &schema.TxRequest{ Tx: hdr.Id, EntriesSpec: &schema.EntriesSpec{ KvEntriesSpec: &schema.EntryTypeSpec{ Action: schema.EntryTypeAction_RESOLVE, }, ZEntriesSpec: &schema.EntryTypeSpec{ Action: schema.EntryTypeAction_RESOLVE, }, // explicit exclusion is optional SqlEntriesSpec: &schema.EntryTypeSpec{ // resolution of sql entries is not supported Action: schema.EntryTypeAction_EXCLUDE, }, }, }) if err != nil { log.Fatal(err) } for _, entry := range tx.KvEntries { log.Printf(\"retrieved key %s and val %s\", entry.Key, entry.Value) } for _, entry := range tx.ZEntries { log.Printf(\"retrieved set %s key %s and score %v\", entry.Set, entry.Key, entry.Score) } // scan over unresolved entries // either EntryTypeAction_ONLY_DIGEST or EntryTypeAction_RAW_VALUE options for _, entry := range tx.Entries { log.Printf(\"retrieved key %s and digest %v\", entry.Key, entry.HValue) } } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Transactions"},{"location":"develop/transactions/#transactions","text":"GetAll , SetAll and ExecAll are the foundation of transactions at key value level in immudb. They allow the execution of a group of commands in a single step, with two important guarantees: All the commands in a transaction are serialized and executed sequentially. No request issued by another client can ever interrupt the execution of a transaction. This guarantees that the commands are executed as a single isolated operation. Either all of the commands are processed, or none are, so the transaction is also atomic.","title":"Transactions"},{"location":"develop/transactions/#getall","text":":::: tabs ::: tab Go package main import ( \"context\" \"log\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) _, err = client.Set(context.TODO(), []byte(`key1`), []byte(`val1`)) if err != nil { log.Fatal(err) } _, err = client.Set(context.TODO(), []byte(`key2`), []byte(`val2`)) if err != nil { log.Fatal(err) } itList, err := client.GetAll(context.TODO(), [][]byte{ []byte(\"key1\"), []byte(\"key2\"), []byte(\"key3\"), // does not exist, no value returned }) log.Printf(\"Set: tx: %+v\", itList) } ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.set(b'key1', b'value1') client.set(b'key2', b'value2') client.set(b'key3', b'value3') response = client.getAll([b'key1', b'key2', b'key3']) print(response) # The same as dictToSetGet, retrieved in one step if __name__ == \"__main__\": main() ::: ::: tab Java // Using getAll: List<String> keys = Arrays.asList(\"key1\", \"key2\", \"key3\"); List<KV> got = immuClient.getAll(keys); // Using execAll for setting multiple KVs at once: byte[] item1 = \"execAll_key1\".getBytes(StandardCharsets.UTF_8); byte[] item2 = \"execAll_key2\".getBytes(StandardCharsets.UTF_8); immuClient.execAll( Arrays.asList( // Providing just a kvList, which is a List< Pair<byte[], byte[]> >. Pair.of(item1, item1), Pair.of(item2, item2) ), null, // No refList provided. null // No zaddList provided. ); // Using execAll for setting multiple references and doing zAdd(s): immuClient.execAll( null, // No kvList provided. Arrays.asList( // The refList. Pair.of(\"ref1\".getBytes(StandardCharsets.UTF_8), item1), Pair.of(\"ref2\".getBytes(StandardCharsets.UTF_8), item2) ), // The zaddList. Collections.singletonList(Triple.of(\"set1\", 1.0, \"execAll_key1\")) ); ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const getAllReq: Parameters.GetAll = { keysList: ['key1', 'key2', 'key3'], sincetx: 0 } const getAllRes = await cl.getAll(getAllReq) console.log('success: getAll', getAllRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"GetAll"},{"location":"develop/transactions/#setall","text":"A more versatile atomic multi set operation :::: tabs SetBatch and GetBatch example ::: tab Go package main import ( \"context\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) tx, err := client.SetAll(context.TODO(), &schema.SetRequest{ KVs: []*schema.KeyValue{ {Key: []byte(`1`), Value: []byte(`key1`)}, {Key: []byte(`2`), Value: []byte(`key2`)}, {Key: []byte(`3`), Value: []byte(`key3`)}, }, }) if err != nil { log.Fatal(err) } log.Printf(\"SetAll: tx: %d\", tx.Id) } ::: ::: tab Python from immudb import ImmudbClient URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) dictToSetGet = { b'key1': b'value1', b'key2': b'value2', b'key3': b'value3' } response = client.setAll(dictToSetGet) print(response.id) # All in one transaction response = client.getAll([b'key1', b'key2', b'key3']) print(response) # The same as dictToSetGet, retrieved in one step if __name__ == \"__main__\": main() ::: ::: tab Java List<KV> kvs = Arrays.asList( new KVPair(\"key1\", \"val1\".getBytes(StandardCharsets.UTF_8)), new KVPair(\"key2\", \"val2\".getBytes(StandardCharsets.UTF_8)), ); KVList kvList = KVList.newBuilder().addAll(kvs).build(); try { immuClient.setAll(kvList); } catch (CorruptedDataException e) { // ... } ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const setAllReq: Parameters.SetAll = { kvsList: [ { key: '1,2,3', value: '3,2,1' }, { key: '4,5,6', value: '6,5,4' }, ] } const setAllRes = await cl.setAll(setAllReq) console.log('success: setAll', setAllRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"SetAll"},{"location":"develop/transactions/#execall","text":"ExecAll allows multiple insertions at once. The difference is that it is possible to specify a list of mixes of key/value sets, references and zAdd insertions. The argument of a ExecAll is an array of the following types: Op_Kv : ordinary key value item Op_ZAdd : ZAdd option element Op_Ref : Reference option element It's possible to persist and reference items that are already persisted on disk. In that case is mandatory to provide the index of the referenced item. This has to be done for: Op_ZAdd Op_Ref If zAdd or reference is not yet persisted on disk it's possible to add it as a regular key value and the reference is done only. In that case if BoundRef is true the reference is bounded to the current transaction values. :::: tabs ::: tab Go package main import ( \"context\" \"encoding/json\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) idx, err := client.Set(context.TODO(), []byte(`persistedKey`), []byte(`persistedVal`)) if err != nil { log.Fatal(err) } aOps := &schema.ExecAllRequest{ Operations: []*schema.Op{ { Operation: &schema.Op_Kv{ Kv: &schema.KeyValue{ Key: []byte(`notPersistedKey`), Value: []byte(`notPersistedVal`), }, }, }, { Operation: &schema.Op_ZAdd{ ZAdd: &schema.ZAddRequest{ Set: []byte(`mySet`), Score: 0.4, Key: []byte(`notPersistedKey`)}, }, }, { Operation: &schema.Op_ZAdd{ ZAdd: &schema.ZAddRequest{ Set: []byte(`mySet`), Score: 0.6, Key: []byte(`persistedKey`), AtTx: idx.Id, BoundRef: true, }, }, }, }, } idx, err = client.ExecAll(context.TODO(), aOps) if err != nil { log.Fatal(err) } list, err := client.ZScan(context.TODO(), &schema.ZScanRequest{ Set: []byte(`mySet`), SinceTx: idx.Id, NoWait: true, }) if err != nil { log.Fatal(err) } s, _ := json.MarshalIndent(list, \"\", \"\\t\") log.Print(string(s)) } ::: ::: tab Python from immudb import ImmudbClient from immudb.datatypes import KeyValue, ZAddRequest, ReferenceRequest URL = \"localhost:3322\" # immudb running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) toExecute = [ KeyValue(b'key', b'value'), ZAddRequest(b'testscore', 100, b'key'), KeyValue(b'key2', b'value2'), ZAddRequest(b'testscore', 150, b'key2'), ReferenceRequest(b'reference1', b'key') ] info = client.execAll(toExecute) print(info.id) # All in one transaction print(client.zScan(b'testscore', b'', 0, 0, True, 10, True, 0, 200)) # Shows these entries print(client.get(b'reference1')) if __name__ == \"__main__\": main() ::: ::: tab Java byte[] item1 = \"execAll_key1\".getBytes(StandardCharsets.UTF_8); byte[] item2 = \"execAll_key2\".getBytes(StandardCharsets.UTF_8); // Using execAll just for setting multiple KVs: TxMetadata txMd = immuClient.execAll( Arrays.asList( // The kvList. Pair.of(item1, item1), Pair.of(item2, item2) ), null, // No refList provided. null // No zaddList provided. ); immuClient.execAll( null, // No kvList provided. Arrays.asList( // The refList. Pair.of(\"ref1\".getBytes(StandardCharsets.UTF_8), item1), Pair.of(\"ref2\".getBytes(StandardCharsets.UTF_8), item2) ), // The zaddList (even if it has one single entry). Collections.singletonList(Triple.of(\"set1\", 1.0, \"execAll_key1\")) ); ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) const { id } = await cl.set({ key: 'persistedKey', value: 'persistedVal' }) const setOperation = { kv: { key: 'notPersistedKey', value: 'notPersistedVal' } } const zAddOperation = { zadd: { set: 'mySet', score: 0.6, key: 'notPersistedKey', attx: 0, boundref: true } } const zAddOperation1 = { zadd: { set: 'mySet', score: 0.6, key: 'persistedKey', attx: id, boundref: true } } const execAllReq: Parameters.ExecAll = { operationsList: [ setOperation, zAddOperation, zAddOperation1, ] } const execAllRes = await cl.execAll(execAllReq) console.log('success: execAll', execAllRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"ExecAll"},{"location":"develop/transactions/#txscan","text":"TxScan permits iterating over transactions. The argument of a TxScan is an array of the following types: InitialTx : initial transaction id Limit : number of transactions returned Desc : order of returned transacations :::: tabs ::: tab Go package main import ( \"context\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) tx, err := client.Set(context.TODO(), []byte(\"key1\"), []byte(\"val1\")) if err != nil { log.Fatal(err) } _, err = client.Set(context.TODO(), []byte(\"key2\"), []byte(\"val2\")) if err != nil { log.Fatal(err) } _, err = client.Set(context.TODO(), []byte(\"key3\"), []byte(\"val3\")) if err != nil { log.Fatal(err) } txs, err := client.TxScan(context.TODO(), &schema.TxScanRequest{ InitialTx: tx.Id, Limit: 3, Desc: true, }) if err != nil { log.Fatal(err) } // Then it's possible to retrieve entries of every transactions: for _, tx := range txs.GetTxs() { for _, entry := range tx.Entries { item, err := client.GetAt(context.TODO(), entry.Key[1:], tx.Header.Id) if err != nil { item, err = client.GetAt(context.TODO(), entry.Key, tx.Header.Id) if err != nil { log.Fatal(err) } } log.Printf(\"retrieved key %s and val %s\\n\", item.Key, item.Value) } } } Remember to strip the first byte in the key (key prefix). Remember that a transaction could contain sorted sets keys that should not be skipped. ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java String key = \"txtest-t2\"; byte[] val1 = \"immuRocks!\".getBytes(StandardCharsets.UTF_8); byte[] val2 = \"immuRocks! Again!\".getBytes(StandardCharsets.UTF_8); long initialTxId = 1; try { TxMetadata txMd = immuClient.set(key, val1); initialTxId = txMd.id; txMd = immuClient.set(key, val2); } catch (CorruptedDataException e) { Assert.fail(\"Failed at set.\", e); } // This is a .txScan(initialTxId, limit, desc) List<Tx> txs = immuClient.txScan(initialTxId, 1, false); // We expect one Tx entry in this list. txs = immuClient.txScan(initialTxId, 2, false); // We expect two Tx entries in this list. ::: ::: tab Node.js import ImmudbClient from 'immudb-node' import Parameters from 'immudb-node/types/parameters' const IMMUDB_HOST = '127.0.0.1' const IMMUDB_PORT = '3322' const IMMUDB_USER = 'immudb' const IMMUDB_PWD = 'immudb' const cl = new ImmudbClient({ host: IMMUDB_HOST, port: IMMUDB_PORT }); (async () => { await cl.login({ user: IMMUDB_USER, password: IMMUDB_PWD }) for (let i = 0; i < 3; i++) { await cl.set({ key: `key${i}`, value: `val${i}` }) } const txScanReq: Parameters.TxScan = { initialtx: 2, limit: 3, desc: false } const txScanRes = await cl.txScan(txScanReq) console.log('success: txScan', txScanRes) })() ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"TxScan"},{"location":"develop/transactions/#filter-transactions","text":"The transaction entries are generated by writing key-value pairs, referencing keys, associating scores to key-value pairs (with ZAdd operation), and by mapping SQL data model into key-value model. With TxScan or TxByIDWithSpec operations it's possible to retrieve entries of certain types, either retrieving the digest of the value assigned to the key ( EntryTypeAction_ONLY_DIGEST ), the raw value ( EntryTypeAction_RAW_VALUE ) or the structured value ( EntryTypeAction_RESOLVE ). :::: tabs ::: tab Go package main import ( \"context\" \"log\" \"github.com/codenotary/immudb/pkg/api/schema\" immudb \"github.com/codenotary/immudb/pkg/client\" ) func main() { opts := immudb.DefaultOptions().WithAddress(\"localhost\").WithPort(3322) client := immudb.NewClient().WithOptions(opts) err := client.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } defer client.CloseSession(context.TODO()) hdr, err := client.ExecAll(context.TODO(), &schema.ExecAllRequest{ Operations: []*schema.Op{ { Operation: &schema.Op_Kv{ Kv: &schema.KeyValue{ Key: []byte(\"key1\"), Value: []byte(\"value1\"), }, }, }, { Operation: &schema.Op_Ref{ Ref: &schema.ReferenceRequest{ Key: []byte(\"ref1\"), ReferencedKey: []byte(\"key1\"), }, }, }, { Operation: &schema.Op_ZAdd{ ZAdd: &schema.ZAddRequest{ Set: []byte(\"set1\"), Score: 10, Key: []byte(\"key1\"), }, }, }, }, }) // fetch kv and sorted-set entries as structured values while skipping sql-related entries tx, err := client.TxByIDWithSpec(context.TODO(), &schema.TxRequest{ Tx: hdr.Id, EntriesSpec: &schema.EntriesSpec{ KvEntriesSpec: &schema.EntryTypeSpec{ Action: schema.EntryTypeAction_RESOLVE, }, ZEntriesSpec: &schema.EntryTypeSpec{ Action: schema.EntryTypeAction_RESOLVE, }, // explicit exclusion is optional SqlEntriesSpec: &schema.EntryTypeSpec{ // resolution of sql entries is not supported Action: schema.EntryTypeAction_EXCLUDE, }, }, }) if err != nil { log.Fatal(err) } for _, entry := range tx.KvEntries { log.Printf(\"retrieved key %s and val %s\", entry.Key, entry.Value) } for _, entry := range tx.ZEntries { log.Printf(\"retrieved set %s key %s and score %v\", entry.Set, entry.Key, entry.Score) } // scan over unresolved entries // either EntryTypeAction_ONLY_DIGEST or EntryTypeAction_RAW_VALUE options for _, entry := range tx.Entries { log.Printf(\"retrieved key %s and digest %v\", entry.Key, entry.HValue) } } ::: ::: tab Python This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Python sdk github project ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Filter Transactions"},{"location":"develop/sql/catalog/","text":"Catalog queries immudb provides a set of useful built-in functions that can be used to query the catalog. Listing databases The DATABASES() function can be used as a source of data returning the list of databases that can be accessed by the user running the query. SELECT * FROM DATABASES(); This source can also be constrained using the WHERE clause and the set of columns to retrieve. SELECT name FROM DATABASES() WHERE name LIKE '.*db1.*'; Listing tables The TABLES() function can be used as a source of data returning the list of tables in the currently selected database. SELECT * FROM TABLES(); This source can also be constrained using the WHERE clause and the set of columns to retrieve. SELECT name FROM TABLES() WHERE name like '.*est.*' Listing columns of a table The COLUMNS() function returns the list of columns for a table. It takes a single argument which is the name of the table. The table will be looked up in the currently selected database. SELECT * FROM COLUMNS('mytable'); This source can also be constrained with the WHERE clause and set of columns to retrieve. Note: because colum names can use reserved identifiers such as table , make sure to enclose those in double-quotes. SELECT \"table\", \"name\", \"type\" FROM COLUMNS('mytable'); SELECT name FROM COLUMNS('mytable') WHERE type = 'VARCHAR'; Listing indexes of a table The INDEXES() function returns a list of indexes for a table. It takes a single argument which is the name of the table. The table will be looked up in the currently selected database. SELECT * FROM INDEXES('mytable'); This source can also be constrained with the WHERE clause and set of columns to retrieve. Note: because colum names can use reserved identifiers such as table , make sure to enclose those in double-quotes. SELECT \"table\", \"name\", \"unique\", \"primary\" FROM INDEXES('mytable'); SELECT name FROM INDEXES('mytable') WHERE \"unique\";","title":"Catalog queries"},{"location":"develop/sql/catalog/#catalog-queries","text":"immudb provides a set of useful built-in functions that can be used to query the catalog.","title":"Catalog queries"},{"location":"develop/sql/catalog/#listing-databases","text":"The DATABASES() function can be used as a source of data returning the list of databases that can be accessed by the user running the query. SELECT * FROM DATABASES(); This source can also be constrained using the WHERE clause and the set of columns to retrieve. SELECT name FROM DATABASES() WHERE name LIKE '.*db1.*';","title":"Listing databases"},{"location":"develop/sql/catalog/#listing-tables","text":"The TABLES() function can be used as a source of data returning the list of tables in the currently selected database. SELECT * FROM TABLES(); This source can also be constrained using the WHERE clause and the set of columns to retrieve. SELECT name FROM TABLES() WHERE name like '.*est.*'","title":"Listing tables"},{"location":"develop/sql/catalog/#listing-columns-of-a-table","text":"The COLUMNS() function returns the list of columns for a table. It takes a single argument which is the name of the table. The table will be looked up in the currently selected database. SELECT * FROM COLUMNS('mytable'); This source can also be constrained with the WHERE clause and set of columns to retrieve. Note: because colum names can use reserved identifiers such as table , make sure to enclose those in double-quotes. SELECT \"table\", \"name\", \"type\" FROM COLUMNS('mytable'); SELECT name FROM COLUMNS('mytable') WHERE type = 'VARCHAR';","title":"Listing columns of a table"},{"location":"develop/sql/catalog/#listing-indexes-of-a-table","text":"The INDEXES() function returns a list of indexes for a table. It takes a single argument which is the name of the table. The table will be looked up in the currently selected database. SELECT * FROM INDEXES('mytable'); This source can also be constrained with the WHERE clause and set of columns to retrieve. Note: because colum names can use reserved identifiers such as table , make sure to enclose those in double-quotes. SELECT \"table\", \"name\", \"unique\", \"primary\" FROM INDEXES('mytable'); SELECT name FROM INDEXES('mytable') WHERE \"unique\";","title":"Listing indexes of a table"},{"location":"develop/sql/datatypes/","text":"Data types Name Description Length constraints INTEGER Signed 64-bit integer value. Usually referred to as BIGINT in other databases. - BOOLEAN A boolean value, either TRUE or FALSE - VARCHAR UTF8-encoded text Maximum number of bytes in the UTF-8 encoded representation of the string BLOB sequence of bytes Maximum number of bytes in the sequence TIMESTAMP datetime value with microsecond precision - Size constraints Size constraint is specified with a [MAX_SIZE] suffix on the type, e.g. BLOB[16] represents a sequence of up to 16 bytes. NULL values NULL values in immudb are not unique - two NULL values are considered equal on comparisons. Timestamp values Timestamp values are internally stored as a 64-bit signed integer being a number of microseconds since the epoch time. Those values are not associated with any timezone, whenever a conversion is needed, it is considered to be in UTC.","title":"Data types"},{"location":"develop/sql/datatypes/#data-types","text":"Name Description Length constraints INTEGER Signed 64-bit integer value. Usually referred to as BIGINT in other databases. - BOOLEAN A boolean value, either TRUE or FALSE - VARCHAR UTF8-encoded text Maximum number of bytes in the UTF-8 encoded representation of the string BLOB sequence of bytes Maximum number of bytes in the sequence TIMESTAMP datetime value with microsecond precision -","title":"Data types"},{"location":"develop/sql/datatypes/#size-constraints","text":"Size constraint is specified with a [MAX_SIZE] suffix on the type, e.g. BLOB[16] represents a sequence of up to 16 bytes.","title":"Size constraints"},{"location":"develop/sql/datatypes/#null-values","text":"NULL values in immudb are not unique - two NULL values are considered equal on comparisons.","title":"NULL values"},{"location":"develop/sql/datatypes/#timestamp-values","text":"Timestamp values are internally stored as a 64-bit signed integer being a number of microseconds since the epoch time. Those values are not associated with any timezone, whenever a conversion is needed, it is considered to be in UTC.","title":"Timestamp values"},{"location":"develop/sql/embeddingSQL/","text":"Embedding immudb in your application Using the Go client SDK means you are connecting to a immudb database server. There are cases where you don't want a separate server but embed immudb directly in the same application process, as a library. immudb provides you a immutable embedded SQL engine which keeps all history, is tamper-proof and can travel in time. The SQL engine is mounted on top of the embedded key value store. The following illustrative example showcase how to initialize the SQL engine, write and read data in the scope of a SQL transaction. package main import ( \"log\" \"github.com/codenotary/immudb/embedded/sql\" \"github.com/codenotary/immudb/embedded/store\" ) func handleErr(err error) { if err != nil { log.Fatal(err) } } func main() { // create/open immudb store at specified path st, err := store.Open(\"data\", store.DefaultOptions()) handleErr(err) defer st.Close() // initialize sql engine (specify a key-prefix to isolate generated kv entries) engine, err := sql.NewEngine(st, sql.DefaultOptions().WithPrefix([]byte(\"sql\"))) handleErr(err) _, _, err = engine.Exec(\"CREATE DATABASE db1;\", nil, nil) handleErr(err) // a sql tx is created and carried over next statements sqltx, _, err := engine.Exec(\"BEGIN TRANSACTION;\", nil, nil) handleErr(err) // ensure tx is closed (it won't affect committed tx) defer engine.Exec(\"ROLLBACK;\", nil, sqltx) // set the database to use in the context of the ongoing sql tx _, _, err = engine.Exec(\"USE DATABASE db1;\", nil, sqltx) handleErr(err) // creates a table _, _, err = engine.Exec(` CREATE TABLE journal ( id INTEGER, date TIMESTAMP, creditaccount INTEGER, debitaccount INTEGER, amount INTEGER, description VARCHAR, PRIMARY KEY id );`, nil, sqltx) handleErr(err) // insert some rows _, _, err = engine.Exec(` INSERT INTO journal ( id, date, creditaccount, debitaccount, amount, description ) VALUES (1, NOW(), 100, 0, 4000, 'CREDIT'), (2, NOW(), 0, 50, 4100, 'DEBIT') ;`, nil, sqltx) handleErr(err) // query data including ongoing and unconfirmed changes rowReader, err := engine.Query(` SELECT id, date, creditaccount, debitaccount, amount, description FROM journal WHERE amount > @value; `, map[string]interface{}{\"value\": 100}, sqltx) handleErr(err) // ensure row reader is closed defer rowReader.Close() // selected columns can be read from the rowReader cols, err := rowReader.Columns() handleErr(err) for { // iterate over result set row, err := rowReader.Read() if err == sql.ErrNoMoreRows { break } handleErr(err) // each row contains values for the selected columns log.Printf(\"row: %v\\n\", row.Values[cols[0].Selector()].Value()) } // close row reader rowReader.Close() // commit ongoing transaction _, _, err = engine.Exec(\"COMMIT;\", nil, sqltx) handleErr(err) } If you need to change options like where things get stored by default, you can do that in the underlying store objects that the SQL engine is using.","title":"Embedding immudb in your application"},{"location":"develop/sql/embeddingSQL/#embedding-immudb-in-your-application","text":"Using the Go client SDK means you are connecting to a immudb database server. There are cases where you don't want a separate server but embed immudb directly in the same application process, as a library. immudb provides you a immutable embedded SQL engine which keeps all history, is tamper-proof and can travel in time. The SQL engine is mounted on top of the embedded key value store. The following illustrative example showcase how to initialize the SQL engine, write and read data in the scope of a SQL transaction. package main import ( \"log\" \"github.com/codenotary/immudb/embedded/sql\" \"github.com/codenotary/immudb/embedded/store\" ) func handleErr(err error) { if err != nil { log.Fatal(err) } } func main() { // create/open immudb store at specified path st, err := store.Open(\"data\", store.DefaultOptions()) handleErr(err) defer st.Close() // initialize sql engine (specify a key-prefix to isolate generated kv entries) engine, err := sql.NewEngine(st, sql.DefaultOptions().WithPrefix([]byte(\"sql\"))) handleErr(err) _, _, err = engine.Exec(\"CREATE DATABASE db1;\", nil, nil) handleErr(err) // a sql tx is created and carried over next statements sqltx, _, err := engine.Exec(\"BEGIN TRANSACTION;\", nil, nil) handleErr(err) // ensure tx is closed (it won't affect committed tx) defer engine.Exec(\"ROLLBACK;\", nil, sqltx) // set the database to use in the context of the ongoing sql tx _, _, err = engine.Exec(\"USE DATABASE db1;\", nil, sqltx) handleErr(err) // creates a table _, _, err = engine.Exec(` CREATE TABLE journal ( id INTEGER, date TIMESTAMP, creditaccount INTEGER, debitaccount INTEGER, amount INTEGER, description VARCHAR, PRIMARY KEY id );`, nil, sqltx) handleErr(err) // insert some rows _, _, err = engine.Exec(` INSERT INTO journal ( id, date, creditaccount, debitaccount, amount, description ) VALUES (1, NOW(), 100, 0, 4000, 'CREDIT'), (2, NOW(), 0, 50, 4100, 'DEBIT') ;`, nil, sqltx) handleErr(err) // query data including ongoing and unconfirmed changes rowReader, err := engine.Query(` SELECT id, date, creditaccount, debitaccount, amount, description FROM journal WHERE amount > @value; `, map[string]interface{}{\"value\": 100}, sqltx) handleErr(err) // ensure row reader is closed defer rowReader.Close() // selected columns can be read from the rowReader cols, err := rowReader.Columns() handleErr(err) for { // iterate over result set row, err := rowReader.Read() if err == sql.ErrNoMoreRows { break } handleErr(err) // each row contains values for the selected columns log.Printf(\"row: %v\\n\", row.Values[cols[0].Selector()].Value()) } // close row reader rowReader.Close() // commit ongoing transaction _, _, err = engine.Exec(\"COMMIT;\", nil, sqltx) handleErr(err) } If you need to change options like where things get stored by default, you can do that in the underlying store objects that the SQL engine is using.","title":"Embedding immudb in your application"},{"location":"develop/sql/indexes/","text":"Indexes immudb indexes can be used for a quick search of rows with columns having specific values. Certain operations such as ordering values with ORDER BY clause require columns to be indexed. CREATE INDEX ON customers(customer_name); CREATE INDEX ON customers(country, ip); CREATE INDEX IF NOT EXISTS ON customers(active); CREATE UNIQUE INDEX ON customers(email); Index can only be added to an empty table. Index do not have explicit name and is referenced by the ordered list of indexed columns. Column value constraints Columns of BLOB or VARCHAR type must have a size limit set on them. The maximum allowed value size for one indexed column is 256 bytes. Unique indexes Index can be marked as unique with extra UNIQUE keyword. Unique index will prevent insertion of new data into the table that would violate uniqueness of indexed columns within the table. Multi-column indexes Index can be set on up to 8 columns. The order of columns is important when doing range scans, iterating over such index will first sort by the value of the first column, then by the second and so on. Note: Large indexes will increase the storage requirement and will reduce the performance of data insertion. Iterating using small indexes will also be faster than with the large ones. IF NOT EXISTS With this clause the CREATE INDEX statement will not fail if an index with same type and list of columns already exists. This includes a use case where the table is not empty which can be used to simplify database schema initialization. Note: If the index already exists, it is not compared against the provided index definition neither it is updated to match it.","title":"Indexes"},{"location":"develop/sql/indexes/#indexes","text":"immudb indexes can be used for a quick search of rows with columns having specific values. Certain operations such as ordering values with ORDER BY clause require columns to be indexed. CREATE INDEX ON customers(customer_name); CREATE INDEX ON customers(country, ip); CREATE INDEX IF NOT EXISTS ON customers(active); CREATE UNIQUE INDEX ON customers(email); Index can only be added to an empty table. Index do not have explicit name and is referenced by the ordered list of indexed columns.","title":"Indexes"},{"location":"develop/sql/indexes/#column-value-constraints","text":"Columns of BLOB or VARCHAR type must have a size limit set on them. The maximum allowed value size for one indexed column is 256 bytes.","title":"Column value constraints"},{"location":"develop/sql/indexes/#unique-indexes","text":"Index can be marked as unique with extra UNIQUE keyword. Unique index will prevent insertion of new data into the table that would violate uniqueness of indexed columns within the table.","title":"Unique indexes"},{"location":"develop/sql/indexes/#multi-column-indexes","text":"Index can be set on up to 8 columns. The order of columns is important when doing range scans, iterating over such index will first sort by the value of the first column, then by the second and so on. Note: Large indexes will increase the storage requirement and will reduce the performance of data insertion. Iterating using small indexes will also be faster than with the large ones.","title":"Multi-column indexes"},{"location":"develop/sql/indexes/#if-not-exists","text":"With this clause the CREATE INDEX statement will not fail if an index with same type and list of columns already exists. This includes a use case where the table is not empty which can be used to simplify database schema initialization. Note: If the index already exists, it is not compared against the provided index definition neither it is updated to match it.","title":"IF NOT EXISTS"},{"location":"develop/sql/insertupdate/","text":"Inserting or updating data INSERT immudb supports standard INSERT sql statement. It can be used to add one or multiple values within the same transaction. INSERT INTO customers ( id, customer_name, email, address, city, ip, country, age, active, created_at ) VALUES ( 1, 'Isidro Behnen', 'ibehnen0@mail.ru', 'ibehnen0@chronoengine.com', 'Arvika', '127.0.0.15', 'SE', 24, true, NOW() ); INSERT INTO products (id, product, price, created_at) VALUES ( 1, 'Juice - V8, Tomato', '$4.04', NOW() ), ( 2, 'Milk', '$3.24', NOW() ); INSERT INTO orders (customerid, productid, created_at) VALUES (1, 1, NOW()), (1, 2, NOW()); INSERT INTO customer_review (customerid, productid, review, created_at) VALUES (1, 1, 'Nice Juice!', NOW()); UPSERT UPSERT is an operation with a syntax similar to INSERT , the difference between those two is that UPSERT either creates a new or replaces an existing row. A new row is created if an entry with the same primary key does not yet exist in the table, otherwise the current row is replaced with the new one. If a table contains an AUTO_INCREMENT primary key, the value for that key must be provided and the UPSERT operation will only update the existing row. UPSERT INTO products (id, product, price) VALUES ( 2, 'Milk', '$3.17' ), ( 3, 'Grapes - Red', '$5.03' ); UPSERT INTO orders (id, customerid, productid) VALUES (1, 1, 3); ON CONFLICT The optional ON CONFLICT clause specifies an alternative action to raising a unique violation or constraint error. ON CONFLICT DO NOTHING simply avoids inserting a row as its alternative action. In this case the primary key of the row is returned. Timestamp, NOW() and CAST() built-in function The built-in NOW() function returns the current timestamp value as seen on the server. The CAST function can be used to convert a string or an integer to a timestamp value. The integer value is interpreted as a Unix timestamp (number of seconds since the epoch time). The string value passed to the CAST function must be in one of the following formats: 2021-12-08 , 2021-12-08 17:21 , 2021-12-08 17:21:59 , 2021-12-08 17:21:59.342516 . Time components not specified in the string are set to 0. UPSERT INTO products (id, product, price, created_at) VALUES ( 3, 'Bread', '$1.50', NOW() ), ( 4, 'Spinach', '$0.99', CAST('2021-02-01' AS TIMESTAMP) ) SELECT * FROM products WHERE created_at < NOW()","title":"Inserting or updating data"},{"location":"develop/sql/insertupdate/#inserting-or-updating-data","text":"","title":"Inserting or updating data"},{"location":"develop/sql/insertupdate/#insert","text":"immudb supports standard INSERT sql statement. It can be used to add one or multiple values within the same transaction. INSERT INTO customers ( id, customer_name, email, address, city, ip, country, age, active, created_at ) VALUES ( 1, 'Isidro Behnen', 'ibehnen0@mail.ru', 'ibehnen0@chronoengine.com', 'Arvika', '127.0.0.15', 'SE', 24, true, NOW() ); INSERT INTO products (id, product, price, created_at) VALUES ( 1, 'Juice - V8, Tomato', '$4.04', NOW() ), ( 2, 'Milk', '$3.24', NOW() ); INSERT INTO orders (customerid, productid, created_at) VALUES (1, 1, NOW()), (1, 2, NOW()); INSERT INTO customer_review (customerid, productid, review, created_at) VALUES (1, 1, 'Nice Juice!', NOW());","title":"INSERT"},{"location":"develop/sql/insertupdate/#upsert","text":"UPSERT is an operation with a syntax similar to INSERT , the difference between those two is that UPSERT either creates a new or replaces an existing row. A new row is created if an entry with the same primary key does not yet exist in the table, otherwise the current row is replaced with the new one. If a table contains an AUTO_INCREMENT primary key, the value for that key must be provided and the UPSERT operation will only update the existing row. UPSERT INTO products (id, product, price) VALUES ( 2, 'Milk', '$3.17' ), ( 3, 'Grapes - Red', '$5.03' ); UPSERT INTO orders (id, customerid, productid) VALUES (1, 1, 3);","title":"UPSERT"},{"location":"develop/sql/insertupdate/#on-conflict","text":"The optional ON CONFLICT clause specifies an alternative action to raising a unique violation or constraint error. ON CONFLICT DO NOTHING simply avoids inserting a row as its alternative action. In this case the primary key of the row is returned.","title":"ON CONFLICT"},{"location":"develop/sql/insertupdate/#timestamp-now-and-cast-built-in-function","text":"The built-in NOW() function returns the current timestamp value as seen on the server. The CAST function can be used to convert a string or an integer to a timestamp value. The integer value is interpreted as a Unix timestamp (number of seconds since the epoch time). The string value passed to the CAST function must be in one of the following formats: 2021-12-08 , 2021-12-08 17:21 , 2021-12-08 17:21:59 , 2021-12-08 17:21:59.342516 . Time components not specified in the string are set to 0. UPSERT INTO products (id, product, price, created_at) VALUES ( 3, 'Bread', '$1.50', NOW() ), ( 4, 'Spinach', '$0.99', CAST('2021-02-01' AS TIMESTAMP) ) SELECT * FROM products WHERE created_at < NOW()","title":"Timestamp, NOW() and CAST() built-in function"},{"location":"develop/sql/pg/","text":"Pgsql protocol compatibility immudb can talk the pgsql wire protocol which makes it compatible with a widely available set of clients and drivers. Note: immudb supports the pgsql wire protocol. It is not compatible with the SQL dialect. Check other topics in the Develop with SQL section to see what queries and operations are supported. Some pgsql clients and browser application execute incompatible statements in the background or directly query the pgsql catalog. Those may not work with immudb. immudb needs to be started with the pgsql-server option enabled ( IMMUDB_PGSQL_SERVER=true ). SSL is supported, if you configured immudb with a certificate. :::: tabs ::: tab CLI Use the psql client included with PostgreSQL. ::: ::: tab C You can use a subset of the libpq API. You will need to include: #include <libpq-fe.h> and compile with gcc -o main $(pkg-config libpq --cflags --libs) main.c . ::: ::: tab Ruby You can use the pg gem: require 'pg' ::: ::: tab Java Download the official JDBC driver jar artifact for PostgreSQL. You can then compile your program: $ javac -cp .:./postgresql-42.2.20.jar MyProgram.java ::: ::: tab PHP Please refer to the PHP pgsql module documentation for instructions on how to enable it in your server. ::: :::: To connect to the database: :::: tabs ::: tab CLI psql \"host=localhost dbname=defaultdb user=immudb password=immudb sslmode=disable\" psql (13.2, server 0.0.0) Type \"help\" for help. ::: ::: tab C PGconn *conn = PQconnectdb(\"host=localhost user=immudb password=immudb dbname=defaultdb sslmode=disable\"); if (PQstatus(conn) == CONNECTION_BAD) { fprintf(stderr, \"Connection to database failed: %s\\n\", PQerrorMessage(conn)); PQfinish(conn); exit(1); } ::: ::: tab Ruby conn = PG::Connection.open(\"sslmode=allow dbname=defaultdb user=immudb password=immudb host=127.0.0.1 port=5432\") ::: ::: tab Java It is important to pass the preferQueryMode=simple option, as immudb pgsql server only support simple query mode. Connection conn = DriverManager.getConnection(\"jdbc:postgresql://127.0.0.1:5432/defaultdb?sslmode=allow&preferQueryMode=simple\", \"immudb\", \"immudb\"); System.out.println(\"Opened database successfully\"); ::: ::: tab PHP <?php $dbconn = pg_connect(\"host=localhost port=5432 sslmode=require user=immudb dbname=defaultdb password=immudb\"); //... pg_close($dbconn); ?> ::: :::: Execute statements: :::: tabs ::: tab CLI defaultdb=> CREATE TABLE Orders(id INTEGER, amount INTEGER, title VARCHAR, PRIMARY KEY id); SELECT 1 defaultdb=> UPSERT INTO Orders (id, amount, title) VALUES (1, 200, 'title1'); SELECT 1 ::: ::: tab C PGresult *res = PQexec(conn, \"CREATE TABLE Orders (id INTEGER, amount INTEGER, title VARCHAR, PRIMARY KEY id)\"); if (PQresultStatus(res) != PGRES_COMMAND_OK) { do_exit(conn, res); } PQclear(res); res = PQexec(conn, \"UPSERT INTO Orders (id, amount, title) VALUES (1, 200, 'title 1')\"); if (PQresultStatus(res) != PGRES_COMMAND_OK) { do_exit(conn, res); } PQclear(res); ::: ::: tab Ruby conn.exec( \"CREATE TABLE Orders (id INTEGER, amount INTEGER, title VARCHAR, PRIMARY KEY id)\" ) conn.exec( \"UPSERT INTO Orders (id, amount, title) VALUES (1, 200, 'title 1')\" ) conn.exec( \"UPSERT INTO Orders (id, amount, title) VALUES (2, 400, 'title 2')\" ) ::: ::: tab Java Statement stmt = conn.createStatement(); stmt.executeUpdate(\"CREATE TABLE people(id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY id);\"); stmt.executeUpdate(\"INSERT INTO people(id, name, salary) VALUES (1, 'Joe', 20000);\"); stmt.executeUpdate(\"INSERT INTO people(id, name, salary) VALUES (2, 'Bob', 30000);\"); ::: ::: tab PHP $stmt = 'CREATE TABLE people(id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY id);'; $result = pg_query($stmt) or die('Error message: ' . pg_last_error()); $stmt = 'INSERT INTO people(id, name, salary) VALUES (1, 'Joe', 20000);'; $result = pg_query($stmt) or die('Error message: ' . pg_last_error()); $stmt = 'INSERT INTO people(id, name, salary) VALUES (2, 'Bob', 30000);'; ::: :::: Query and iterate over results: :::: tabs ::: tab CLI defaultdb=> SELECT id, amount, title FROM Orders; (defaultdb.Orders.id) | (defaultdb.Orders.amount) | (defaultdb.Orders.title) -----------------------+---------------------------+-------------------------- 1 | 200 | \"title1\" (1 row) ::: ::: tab C res = PQexec(conn, \"SELECT id, amount, title FROM Orders\"); if (PQresultStatus(res) != PGRES_TUPLES_OK) { printf(\"No data retrieved\\n\"); PQclear(res); do_exit(conn, res); } int rows = PQntuples(res); for(int i=0; i<rows; i++) { printf(\"%s %s %s\\n\", PQgetvalue(res, i, 0), PQgetvalue(res, i, 1), PQgetvalue(res, i, 2)); } PQclear(res); PQfinish(conn); ::: ::: tab Ruby conn.exec( \"SELECT id, amount, title FROM Orders\" ) do |result| result.each do |row| puts row.inspect end end ::: ::: tab Java ResultSet rs = stmt.executeQuery(\"SELECT * FROM people\"); while(rs.next()){ System.out.print(\"ID: \" + rs.getInt(\"(defaultdb.people.id)\")); System.out.print(\", Name: \" + rs.getString(\"(defaultdb.people.name)\")); System.out.print(\", Salary: \" + rs.getInt(\"(defaultdb.people.salary)\")); System.out.println(); } ::: ::: tab PHP $query = 'SELECT * FROM people'; $result = pg_query($query) or die('Error message: ' . pg_last_error()); while ($row = pg_fetch_row($result)) { var_dump($row); } ::: ::::","title":"Pgsql protocol compatibility"},{"location":"develop/sql/pg/#pgsql-protocol-compatibility","text":"immudb can talk the pgsql wire protocol which makes it compatible with a widely available set of clients and drivers. Note: immudb supports the pgsql wire protocol. It is not compatible with the SQL dialect. Check other topics in the Develop with SQL section to see what queries and operations are supported. Some pgsql clients and browser application execute incompatible statements in the background or directly query the pgsql catalog. Those may not work with immudb. immudb needs to be started with the pgsql-server option enabled ( IMMUDB_PGSQL_SERVER=true ). SSL is supported, if you configured immudb with a certificate. :::: tabs ::: tab CLI Use the psql client included with PostgreSQL. ::: ::: tab C You can use a subset of the libpq API. You will need to include: #include <libpq-fe.h> and compile with gcc -o main $(pkg-config libpq --cflags --libs) main.c . ::: ::: tab Ruby You can use the pg gem: require 'pg' ::: ::: tab Java Download the official JDBC driver jar artifact for PostgreSQL. You can then compile your program: $ javac -cp .:./postgresql-42.2.20.jar MyProgram.java ::: ::: tab PHP Please refer to the PHP pgsql module documentation for instructions on how to enable it in your server. ::: :::: To connect to the database: :::: tabs ::: tab CLI psql \"host=localhost dbname=defaultdb user=immudb password=immudb sslmode=disable\" psql (13.2, server 0.0.0) Type \"help\" for help. ::: ::: tab C PGconn *conn = PQconnectdb(\"host=localhost user=immudb password=immudb dbname=defaultdb sslmode=disable\"); if (PQstatus(conn) == CONNECTION_BAD) { fprintf(stderr, \"Connection to database failed: %s\\n\", PQerrorMessage(conn)); PQfinish(conn); exit(1); } ::: ::: tab Ruby conn = PG::Connection.open(\"sslmode=allow dbname=defaultdb user=immudb password=immudb host=127.0.0.1 port=5432\") ::: ::: tab Java It is important to pass the preferQueryMode=simple option, as immudb pgsql server only support simple query mode. Connection conn = DriverManager.getConnection(\"jdbc:postgresql://127.0.0.1:5432/defaultdb?sslmode=allow&preferQueryMode=simple\", \"immudb\", \"immudb\"); System.out.println(\"Opened database successfully\"); ::: ::: tab PHP <?php $dbconn = pg_connect(\"host=localhost port=5432 sslmode=require user=immudb dbname=defaultdb password=immudb\"); //... pg_close($dbconn); ?> ::: :::: Execute statements: :::: tabs ::: tab CLI defaultdb=> CREATE TABLE Orders(id INTEGER, amount INTEGER, title VARCHAR, PRIMARY KEY id); SELECT 1 defaultdb=> UPSERT INTO Orders (id, amount, title) VALUES (1, 200, 'title1'); SELECT 1 ::: ::: tab C PGresult *res = PQexec(conn, \"CREATE TABLE Orders (id INTEGER, amount INTEGER, title VARCHAR, PRIMARY KEY id)\"); if (PQresultStatus(res) != PGRES_COMMAND_OK) { do_exit(conn, res); } PQclear(res); res = PQexec(conn, \"UPSERT INTO Orders (id, amount, title) VALUES (1, 200, 'title 1')\"); if (PQresultStatus(res) != PGRES_COMMAND_OK) { do_exit(conn, res); } PQclear(res); ::: ::: tab Ruby conn.exec( \"CREATE TABLE Orders (id INTEGER, amount INTEGER, title VARCHAR, PRIMARY KEY id)\" ) conn.exec( \"UPSERT INTO Orders (id, amount, title) VALUES (1, 200, 'title 1')\" ) conn.exec( \"UPSERT INTO Orders (id, amount, title) VALUES (2, 400, 'title 2')\" ) ::: ::: tab Java Statement stmt = conn.createStatement(); stmt.executeUpdate(\"CREATE TABLE people(id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY id);\"); stmt.executeUpdate(\"INSERT INTO people(id, name, salary) VALUES (1, 'Joe', 20000);\"); stmt.executeUpdate(\"INSERT INTO people(id, name, salary) VALUES (2, 'Bob', 30000);\"); ::: ::: tab PHP $stmt = 'CREATE TABLE people(id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY id);'; $result = pg_query($stmt) or die('Error message: ' . pg_last_error()); $stmt = 'INSERT INTO people(id, name, salary) VALUES (1, 'Joe', 20000);'; $result = pg_query($stmt) or die('Error message: ' . pg_last_error()); $stmt = 'INSERT INTO people(id, name, salary) VALUES (2, 'Bob', 30000);'; ::: :::: Query and iterate over results: :::: tabs ::: tab CLI defaultdb=> SELECT id, amount, title FROM Orders; (defaultdb.Orders.id) | (defaultdb.Orders.amount) | (defaultdb.Orders.title) -----------------------+---------------------------+-------------------------- 1 | 200 | \"title1\" (1 row) ::: ::: tab C res = PQexec(conn, \"SELECT id, amount, title FROM Orders\"); if (PQresultStatus(res) != PGRES_TUPLES_OK) { printf(\"No data retrieved\\n\"); PQclear(res); do_exit(conn, res); } int rows = PQntuples(res); for(int i=0; i<rows; i++) { printf(\"%s %s %s\\n\", PQgetvalue(res, i, 0), PQgetvalue(res, i, 1), PQgetvalue(res, i, 2)); } PQclear(res); PQfinish(conn); ::: ::: tab Ruby conn.exec( \"SELECT id, amount, title FROM Orders\" ) do |result| result.each do |row| puts row.inspect end end ::: ::: tab Java ResultSet rs = stmt.executeQuery(\"SELECT * FROM people\"); while(rs.next()){ System.out.print(\"ID: \" + rs.getInt(\"(defaultdb.people.id)\")); System.out.print(\", Name: \" + rs.getString(\"(defaultdb.people.name)\")); System.out.print(\", Salary: \" + rs.getInt(\"(defaultdb.people.salary)\")); System.out.println(); } ::: ::: tab PHP $query = 'SELECT * FROM people'; $result = pg_query($query) or die('Error message: ' . pg_last_error()); while ($row = pg_fetch_row($result)) { var_dump($row); } ::: ::::","title":"Pgsql protocol compatibility"},{"location":"develop/sql/querying/","text":"Querying Selecting all columns All columns from all joined tables can be queried with SELECT * statement. SELECT * FROM products; Selecting specific columns SELECT id, customer_name, ip FROM customers; Filtering entries SELECT id, customer_name, email FROM customers WHERE country = 'SE' AND city = 'Arvika'; Ordering by column value SELECT id, customer_name FROM customers ORDER BY customer_name ASC; Currently only one column can be used in the ORDER BY clause. The order may be either ascending ( ASC suffix, default) or descending ( DESC suffix). Ordering rows by a value of a column requires a matching index on that column. INNER JOIN immudb supports standard SQL INNER JOIN syntax. The INNER join type is optional. SELECT * FROM orders INNER JOIN customers ON orders.customerid = customers.id; SELECT * FROM orders JOIN customers ON orders.customerid = customers.id WHERE orders.productid = 2; SELECT * FROM orders JOIN customers ON customers.id = orders.customerid JOIN products ON products.id = orders.productid; LIKE operator immudb supports the LIKE operator. Unlike in other SQL engines though, the pattern use a regexp syntax supported by the regexp library in the go language . A NOT prefix negates the value of the LIKE operator. SELECT product FROM products WHERE product LIKE '(J.*ce|Red)'; SELECT product FROM products WHERE product NOT LIKE '(J.*ce|Red)'; SELECT id, product FROM products WHERE (id > 0 AND NOT products.id >= 10) AND (products.product LIKE 'J'); IN operator immudb has a basic supports for the IN operator. A NOT prefix negates the value of the IN operator. Note: Currently the list for the IN operator can not be calculated using a sub-query. SELECT product FROM products WHERE product IN ('Milk', 'Grapes - Red'); SELECT product FROM products WHERE product NOT IN ('Milk', 'Grapes - Red'); SELECT id, product FROM products WHERE (id > 0 AND NOT products.id >= 10) AND (product IN ('Milk', 'Grapes - Red')); Column and table aliasing SELECT c.id, c.customer_name AS name, active FROM customers AS c WHERE c.id <= 3 AND c.active = true; SELECT c.id, c.customer_name AS name, active FROM customers c WHERE c.id <= 3 AND c.active = true; Table name aliasing is necessary when using more than one join with the same table. Aggregations Available aggregation functions: COUNT SUM MAX MIN AVG SELECT COUNT(*) AS c, SUM(age), MIN(age), MAX(age), AVG(age) FROM customers; Grouping results with GROUP BY Results can be grouped by a value of a single column. That column must also be used in a matching ORDER BY clause. SELECT COUNT(*) as customer_count, country FROM customers GROUP BY country ORDER BY country; Filtering grouped results with HAVING SELECT active, COUNT(*) as c, MIN(age), MAX(age) FROM customers GROUP BY active HAVING COUNT(*) > 0 ORDER BY active DESC; Sub-queries The table in the SELECT or JOIN clauses can be replaced with a sub-query. SELECT * FROM ( SELECT id, customer_name FROM customers WHERE age < 30 ) INNER JOIN customer_review ON customer_review.customerid = customers.id; SELECT * FROM ( SELECT id, customer_name FROM customers WHERE age < 30 ) AS c INNER JOIN ( SELECT * FROM customer_review ) AS r ON r.customerid = c.id; Note: the context of a sub-query does not propagate outside, e.g. it is not possible to reference a table from a sub-query in the WHERE clause outside of the sub-query. Combining query results with UNION It is possible to combine multiple query results with the UNION operator. Subqueries must select the same number and type of columns. The final return will assign the same naming as in the first subquery, even if names differ. SELECT customer_name as name FROM customers WHERE age < 30 UNION SELECT seller_name FROM sellers WHERE age < 30 Subqueries are not constrained in any way, they can contain aggregations or joins. Duplicate rows are excluded by default. Using UNION ALL will leave duplicate rows in place. SELECT AVG(age) FROM customers UNION ALL SELECT AVG(age) FROM sellers Transactions The ACID (Atomicity, Consistency, Isolation, and Durability) compliance is complete. Handling read-write conflicts may be necessary when dealing with concurrent transactions. Getting the error ErrTxReadConflict (\"tx read conflict\") means there was another transaction committed before the current one, and the data it read may have been invalidated. MVCC validations have not yet been implemented, therefore there may be false positives generated. In case of conflict, a new attempt may be required. BEGIN TRANSACTION; UPSERT INTO products (id, price, product) VALUES (4, '$5.76', 'Bread'); INSERT INTO orders(productid, customerid) VALUES(4, 1); COMMIT; Time travel Time travel allows you to read data from SQL as if it were in a previous state or from a specific time range. Initial and final points are optional and can be specified using either a transaction ID or a timestamp. The temporal range can be used to filter out rows from the specified (physical) table, but it is not supported in subqueries. The initial point can be inclusive ( SINCE ) or exclusive ( AFTER ). The final point can be inclusive ( UNTIL ) or exclusive ( BEFORE ). SELECT id, product, price FROM products BEFORE TX 13 WHERE id = 2; SELECT * FROM sales SINCE '2022-01-06 11:38' UNTIL '2022-01-06 12:00' Temporal ranges can be specified using functions and parameters SELECT * FROM mytable SINCE TX @initialTx BEFORE now()","title":"Querying"},{"location":"develop/sql/querying/#querying","text":"","title":"Querying"},{"location":"develop/sql/querying/#selecting-all-columns","text":"All columns from all joined tables can be queried with SELECT * statement. SELECT * FROM products;","title":"Selecting all columns"},{"location":"develop/sql/querying/#selecting-specific-columns","text":"SELECT id, customer_name, ip FROM customers;","title":"Selecting specific columns"},{"location":"develop/sql/querying/#filtering-entries","text":"SELECT id, customer_name, email FROM customers WHERE country = 'SE' AND city = 'Arvika';","title":"Filtering entries"},{"location":"develop/sql/querying/#ordering-by-column-value","text":"SELECT id, customer_name FROM customers ORDER BY customer_name ASC; Currently only one column can be used in the ORDER BY clause. The order may be either ascending ( ASC suffix, default) or descending ( DESC suffix). Ordering rows by a value of a column requires a matching index on that column.","title":"Ordering by column value"},{"location":"develop/sql/querying/#inner-join","text":"immudb supports standard SQL INNER JOIN syntax. The INNER join type is optional. SELECT * FROM orders INNER JOIN customers ON orders.customerid = customers.id; SELECT * FROM orders JOIN customers ON orders.customerid = customers.id WHERE orders.productid = 2; SELECT * FROM orders JOIN customers ON customers.id = orders.customerid JOIN products ON products.id = orders.productid;","title":"INNER JOIN"},{"location":"develop/sql/querying/#like-operator","text":"immudb supports the LIKE operator. Unlike in other SQL engines though, the pattern use a regexp syntax supported by the regexp library in the go language . A NOT prefix negates the value of the LIKE operator. SELECT product FROM products WHERE product LIKE '(J.*ce|Red)'; SELECT product FROM products WHERE product NOT LIKE '(J.*ce|Red)'; SELECT id, product FROM products WHERE (id > 0 AND NOT products.id >= 10) AND (products.product LIKE 'J');","title":"LIKE operator"},{"location":"develop/sql/querying/#in-operator","text":"immudb has a basic supports for the IN operator. A NOT prefix negates the value of the IN operator. Note: Currently the list for the IN operator can not be calculated using a sub-query. SELECT product FROM products WHERE product IN ('Milk', 'Grapes - Red'); SELECT product FROM products WHERE product NOT IN ('Milk', 'Grapes - Red'); SELECT id, product FROM products WHERE (id > 0 AND NOT products.id >= 10) AND (product IN ('Milk', 'Grapes - Red'));","title":"IN operator"},{"location":"develop/sql/querying/#column-and-table-aliasing","text":"SELECT c.id, c.customer_name AS name, active FROM customers AS c WHERE c.id <= 3 AND c.active = true; SELECT c.id, c.customer_name AS name, active FROM customers c WHERE c.id <= 3 AND c.active = true; Table name aliasing is necessary when using more than one join with the same table.","title":"Column and table aliasing"},{"location":"develop/sql/querying/#aggregations","text":"Available aggregation functions: COUNT SUM MAX MIN AVG SELECT COUNT(*) AS c, SUM(age), MIN(age), MAX(age), AVG(age) FROM customers;","title":"Aggregations"},{"location":"develop/sql/querying/#grouping-results-with-group-by","text":"Results can be grouped by a value of a single column. That column must also be used in a matching ORDER BY clause. SELECT COUNT(*) as customer_count, country FROM customers GROUP BY country ORDER BY country;","title":"Grouping results with GROUP BY"},{"location":"develop/sql/querying/#filtering-grouped-results-with-having","text":"SELECT active, COUNT(*) as c, MIN(age), MAX(age) FROM customers GROUP BY active HAVING COUNT(*) > 0 ORDER BY active DESC;","title":"Filtering grouped results with HAVING"},{"location":"develop/sql/querying/#sub-queries","text":"The table in the SELECT or JOIN clauses can be replaced with a sub-query. SELECT * FROM ( SELECT id, customer_name FROM customers WHERE age < 30 ) INNER JOIN customer_review ON customer_review.customerid = customers.id; SELECT * FROM ( SELECT id, customer_name FROM customers WHERE age < 30 ) AS c INNER JOIN ( SELECT * FROM customer_review ) AS r ON r.customerid = c.id; Note: the context of a sub-query does not propagate outside, e.g. it is not possible to reference a table from a sub-query in the WHERE clause outside of the sub-query.","title":"Sub-queries"},{"location":"develop/sql/querying/#combining-query-results-with-union","text":"It is possible to combine multiple query results with the UNION operator. Subqueries must select the same number and type of columns. The final return will assign the same naming as in the first subquery, even if names differ. SELECT customer_name as name FROM customers WHERE age < 30 UNION SELECT seller_name FROM sellers WHERE age < 30 Subqueries are not constrained in any way, they can contain aggregations or joins. Duplicate rows are excluded by default. Using UNION ALL will leave duplicate rows in place. SELECT AVG(age) FROM customers UNION ALL SELECT AVG(age) FROM sellers","title":"Combining query results with UNION"},{"location":"develop/sql/querying/#transactions","text":"The ACID (Atomicity, Consistency, Isolation, and Durability) compliance is complete. Handling read-write conflicts may be necessary when dealing with concurrent transactions. Getting the error ErrTxReadConflict (\"tx read conflict\") means there was another transaction committed before the current one, and the data it read may have been invalidated. MVCC validations have not yet been implemented, therefore there may be false positives generated. In case of conflict, a new attempt may be required. BEGIN TRANSACTION; UPSERT INTO products (id, price, product) VALUES (4, '$5.76', 'Bread'); INSERT INTO orders(productid, customerid) VALUES(4, 1); COMMIT;","title":"Transactions"},{"location":"develop/sql/querying/#time-travel","text":"Time travel allows you to read data from SQL as if it were in a previous state or from a specific time range. Initial and final points are optional and can be specified using either a transaction ID or a timestamp. The temporal range can be used to filter out rows from the specified (physical) table, but it is not supported in subqueries. The initial point can be inclusive ( SINCE ) or exclusive ( AFTER ). The final point can be inclusive ( UNTIL ) or exclusive ( BEFORE ). SELECT id, product, price FROM products BEFORE TX 13 WHERE id = 2; SELECT * FROM sales SINCE '2022-01-06 11:38' UNTIL '2022-01-06 12:00' Temporal ranges can be specified using functions and parameters SELECT * FROM mytable SINCE TX @initialTx BEFORE now()","title":"Time travel"},{"location":"develop/sql/sqlstdlib/","text":"GO SQL std library From immudb v1.1.0 is possible to use go standard library sql interface to query data. import ( \"context\" \"fmt\" \"github.com/codenotary/immudb/pkg/client\" \"github.com/codenotary/immudb/pkg/stdlib\" ) opts := client.DefaultOptions() opts.Username = \"immudb\" opts.Password = \"immudb\" opts.Database = \"defaultdb\" db := stdlib.OpenDB(opts) defer db.Close() _, err := db.ExecContext(context.TODO(), \"CREATE TABLE myTable(id INTEGER, name VARCHAR, PRIMARY KEY id)\") _, err = db.ExecContext(context.TODO(), \"INSERT INTO myTable (id, name) VALUES (1, 'immu1')\") rows, err := db.QueryContext(context.TODO(), \"SELECT * FROM myTable\") var id uint64 var name string defer rows.Close() rows.Next() err = rows.Scan(&id, &name) if err != nil { panic(err) } fmt.Printf(\"id: %d\\n\", id) fmt.Printf(\"name: %s\\n\", name) In alternative is possible to open immudb with a connection string: import ( \"database/sql\" _ \"github.com/codenotary/immudb/pkg/stdlib\" ) func main() { db, err := sql.Open(\"immudb\", \"immudb://immudb:immudb@127.0.0.1:3322/defaultdb?sslmode=disable\") defer db.Close() Available SSL modes are: * disable . SSL is off * insecure-verify . SSL is on but client will not check the server name. * require . SSL is on.","title":"GO SQL std library"},{"location":"develop/sql/sqlstdlib/#go-sql-std-library","text":"From immudb v1.1.0 is possible to use go standard library sql interface to query data. import ( \"context\" \"fmt\" \"github.com/codenotary/immudb/pkg/client\" \"github.com/codenotary/immudb/pkg/stdlib\" ) opts := client.DefaultOptions() opts.Username = \"immudb\" opts.Password = \"immudb\" opts.Database = \"defaultdb\" db := stdlib.OpenDB(opts) defer db.Close() _, err := db.ExecContext(context.TODO(), \"CREATE TABLE myTable(id INTEGER, name VARCHAR, PRIMARY KEY id)\") _, err = db.ExecContext(context.TODO(), \"INSERT INTO myTable (id, name) VALUES (1, 'immu1')\") rows, err := db.QueryContext(context.TODO(), \"SELECT * FROM myTable\") var id uint64 var name string defer rows.Close() rows.Next() err = rows.Scan(&id, &name) if err != nil { panic(err) } fmt.Printf(\"id: %d\\n\", id) fmt.Printf(\"name: %s\\n\", name) In alternative is possible to open immudb with a connection string: import ( \"database/sql\" _ \"github.com/codenotary/immudb/pkg/stdlib\" ) func main() { db, err := sql.Open(\"immudb\", \"immudb://immudb:immudb@127.0.0.1:3322/defaultdb?sslmode=disable\") defer db.Close() Available SSL modes are: * disable . SSL is off * insecure-verify . SSL is on but client will not check the server name. * require . SSL is on.","title":"GO SQL std library"},{"location":"develop/sql/tablesalter/","text":"Altering tables immudb supports limited table altering. The supported operations are lightweight. They do not require any changes to already written row data and there is no performance penalty on read/write operations in such altered tables. ADD COLUMN A new column can be added to an existing table. Such column must be nullable. For rows that already existed in the table before the alter operation, the value of the newly added column will be read as NULL . New column can not be set as AUTO_INCREMENT which is only allowed for the primary key. ALTER TABLE customers ADD COLUMN created_time TIMESTAMP; SELECT customer_name, created_time FROM customers; RENAME COLUMN An existing column can be renamed. The column with the new name must not exist in the table when performing the alter operation. If the column was previously part of an index, such index will continue working with the new column name. Renaming a column does not change column's type. ALTER TABLE customers RENAME COLUMN created_time TO created_at; SELECT customer_name, created_at FROM customers;","title":"Altering tables"},{"location":"develop/sql/tablesalter/#altering-tables","text":"immudb supports limited table altering. The supported operations are lightweight. They do not require any changes to already written row data and there is no performance penalty on read/write operations in such altered tables.","title":"Altering tables"},{"location":"develop/sql/tablesalter/#add-column","text":"A new column can be added to an existing table. Such column must be nullable. For rows that already existed in the table before the alter operation, the value of the newly added column will be read as NULL . New column can not be set as AUTO_INCREMENT which is only allowed for the primary key. ALTER TABLE customers ADD COLUMN created_time TIMESTAMP; SELECT customer_name, created_time FROM customers;","title":"ADD COLUMN"},{"location":"develop/sql/tablesalter/#rename-column","text":"An existing column can be renamed. The column with the new name must not exist in the table when performing the alter operation. If the column was previously part of an index, such index will continue working with the new column name. Renaming a column does not change column's type. ALTER TABLE customers RENAME COLUMN created_time TO created_at; SELECT customer_name, created_at FROM customers;","title":"RENAME COLUMN"},{"location":"develop/sql/tablescreate/","text":"Creating tables Common examples of CREATE TABLE statements are presented below. CREATE TABLE IF NOT EXISTS customers ( id INTEGER, customer_name VARCHAR[60], email VARCHAR[150], address VARCHAR, city VARCHAR, ip VARCHAR[40], country VARCHAR[15], age INTEGER, active BOOLEAN, PRIMARY KEY (id) ); CREATE TABLE IF NOT EXISTS products ( id INTEGER, product VARCHAR NOT NULL, price VARCHAR NOT NULL, created_at TIMESTAMP, PRIMARY KEY (id) ); CREATE TABLE IF NOT EXISTS orders ( id INTEGER AUTO_INCREMENT, customerid INTEGER, productid INTEGER, created_at TIMESTAMP, PRIMARY KEY id ); CREATE TABLE customer_review( customerid INTEGER, productid INTEGER, review VARCHAR, created_at TIMESTAMP, PRIMARY KEY (customerid, productid) ); IF NOT EXISTS With this clause the CREATE TABLE statement will not fail if a table with same name already exists. Note: If the table already exists, it is not compared against the provided table definition neither it is updated to match it. NOT NULL Columns marked as not null can not have a null value assigned. PRIMARY KEY Every table in immudb must have a primary key. Primary key can use at least 1 and up to 8 columns. Columns used in a primary key can not have NULL values assigned, even if those columns are not explicitly marked as NOT NULL . Primary key creates an implicit unique index on all contained columns. AUTO_INCREMENT A single-column PRIMARY KEY can be marked as AUTO_INCREMENT . immudb will automatically set a unique value of this column for new rows. When inserting data into a table with an INSERT statement, the value for such primary key must be omitted. When updating data in such table with UPSERT statement, the value for such primary key is obligatory and the UPSERT statement can only update existing rows. The type of an AUTO_INCREMENT column must be INTEGER . Internally immudb will assign sequentially increasing values for new rows ensuring this value is unique within a single table. Foreign keys Explicit support for relations to foreign tables is not currently supported in immudb. It is possible however to create ordinary columns containing foreign key values that can be used in JOIN statements. Application logic is responsible for ensuring data consistency and foreign key constraints. SELECT * FROM orders INNER JOIN customers ON customers.id = orders.customerid INNER JOIN products ON products.id = orders.productid;","title":"Creating tables"},{"location":"develop/sql/tablescreate/#creating-tables","text":"Common examples of CREATE TABLE statements are presented below. CREATE TABLE IF NOT EXISTS customers ( id INTEGER, customer_name VARCHAR[60], email VARCHAR[150], address VARCHAR, city VARCHAR, ip VARCHAR[40], country VARCHAR[15], age INTEGER, active BOOLEAN, PRIMARY KEY (id) ); CREATE TABLE IF NOT EXISTS products ( id INTEGER, product VARCHAR NOT NULL, price VARCHAR NOT NULL, created_at TIMESTAMP, PRIMARY KEY (id) ); CREATE TABLE IF NOT EXISTS orders ( id INTEGER AUTO_INCREMENT, customerid INTEGER, productid INTEGER, created_at TIMESTAMP, PRIMARY KEY id ); CREATE TABLE customer_review( customerid INTEGER, productid INTEGER, review VARCHAR, created_at TIMESTAMP, PRIMARY KEY (customerid, productid) );","title":"Creating tables"},{"location":"develop/sql/tablescreate/#if-not-exists","text":"With this clause the CREATE TABLE statement will not fail if a table with same name already exists. Note: If the table already exists, it is not compared against the provided table definition neither it is updated to match it.","title":"IF NOT EXISTS"},{"location":"develop/sql/tablescreate/#not-null","text":"Columns marked as not null can not have a null value assigned.","title":"NOT NULL"},{"location":"develop/sql/tablescreate/#primary-key","text":"Every table in immudb must have a primary key. Primary key can use at least 1 and up to 8 columns. Columns used in a primary key can not have NULL values assigned, even if those columns are not explicitly marked as NOT NULL . Primary key creates an implicit unique index on all contained columns.","title":"PRIMARY KEY"},{"location":"develop/sql/tablescreate/#auto_increment","text":"A single-column PRIMARY KEY can be marked as AUTO_INCREMENT . immudb will automatically set a unique value of this column for new rows. When inserting data into a table with an INSERT statement, the value for such primary key must be omitted. When updating data in such table with UPSERT statement, the value for such primary key is obligatory and the UPSERT statement can only update existing rows. The type of an AUTO_INCREMENT column must be INTEGER . Internally immudb will assign sequentially increasing values for new rows ensuring this value is unique within a single table.","title":"AUTO_INCREMENT"},{"location":"develop/sql/tablescreate/#foreign-keys","text":"Explicit support for relations to foreign tables is not currently supported in immudb. It is possible however to create ordinary columns containing foreign key values that can be used in JOIN statements. Application logic is responsible for ensuring data consistency and foreign key constraints. SELECT * FROM orders INNER JOIN customers ON customers.id = orders.customerid INNER JOIN products ON products.id = orders.productid;","title":"Foreign keys"},{"location":"develop/sql/transactions/","text":"Transactions immudb supports transactions both on key-value and SQL level, but interactive transactions are supported only on SQL with the exception of execAll method, that provides some additional properties. Interactive transactions are a way to execute multiple SQL statements in a single transaction. This makes possible to delegate application logic to SQL statements - a very common use case is for example checking if the balance > 0 before making a purchase. In order to create a transaction, you must call the NewTx() method on the client instance. The resulting object is a transaction object that can be used to execute multiple SQL statements, queries, commit or rollback. Following there are methods exposed by the transaction object: Commit() CommittedSQLTx, error Rollback() error SQLExec(sql, params) error SQLQuery(sql, params) SQLQueryResult, error It's possible to rollback a transaction by calling the Rollback() method. In this case, the transaction object is no longer valid and should not be used anymore. To commit a transaction, you must call the Commit() method. Note : At the moment immudb support only 1 read-write transaction at a time, so it's up the application to ensure that only one read-write transaction is open at a time, or to handle read conflict error. In such case the error code returned by sdk will be 25P02 CodInFailedSqlTransaction . :::: tabs ::: tab Go cli := immudb.NewClient() err := cli.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } tx1, err := cli.NewTx(context.TODO()) if err != nil { log.Fatal(err) } err = tx1.SQLExec(context.TODO(), `CREATE TABLE table1(id INTEGER,PRIMARY KEY id);`, nil) if err != nil { log.Fatal(err) } rand.Seed(time.Now().UnixNano()) err = tx1.SQLExec(context.TODO(), fmt.Sprintf(\"INSERT INTO table1(id) VALUES (%d)\", rand.Int()), nil) if err != nil { log.Fatal(err) } txh, err := tx1.Commit(context.TODO()) if err != nil { log.Fatal(err) } fmt.Printf(\"Successfully committed rows %d\\n\", txh.UpdatedRows) err = cli.CloseSession(context.TODO()) if err != nil { log.Fatal(err) } ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python Currently immudb Python sdk doesn't support interactive transactions. However you can still use non-interactive SQL Transactions. from immudb import ImmudbClient from uuid import uuid4 URL = \"localhost:3322\" # ImmuDB running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.sqlExec(\"\"\" CREATE TABLE IF NOT EXISTS example ( uniqueID VARCHAR[64], value VARCHAR[32], created TIMESTAMP, PRIMARY KEY(uniqueID) );\"\"\") client.sqlExec(\"\"\" CREATE TABLE IF NOT EXISTS related ( id INTEGER AUTO_INCREMENT, uniqueID VARCHAR[64], relatedValue VARCHAR[32], PRIMARY KEY(id) );\"\"\") uid1 = str(uuid4()) uid2 = str(uuid4()) params = { \"uid1\": uid1, \"uid2\": uid2 } resp = client.sqlExec(\"\"\" BEGIN TRANSACTION; INSERT INTO example (uniqueID, value, created) VALUES (@uid1, 'test1', NOW()), (@uid2, 'test2', NOW()); INSERT INTO related (uniqueID, relatedValue) VALUES (@uid1, 'related1'), (@uid2, 'related2'); INSERT INTO related (uniqueID, relatedValue) VALUES (@uid1, 'related3'), (@uid2, 'related4'); COMMIT; \"\"\", params) transactionId = resp.txs[0].header.id result = client.sqlQuery(\"\"\" SELECT related.id, related.uniqueID, example.value, related.relatedValue, example.created FROM related JOIN example ON example.uniqueID = related.uniqueID; \"\"\") for item in result: id, uid, value, relatedValue, created = item print(\"ITEM\", id, uid, value, relatedValue, created.isoformat()) result = client.sqlQuery(f\"\"\" SELECT related.id, related.uniqueID, example.value, related.relatedValue, example.created FROM related BEFORE TX {transactionId} JOIN example BEFORE TX {transactionId} ON example.uniqueID = related.uniqueID; \"\"\") print(result) # You can't see just added entries, # my fellow time traveller if __name__ == \"__main__\": main() ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Transactions"},{"location":"develop/sql/transactions/#transactions","text":"immudb supports transactions both on key-value and SQL level, but interactive transactions are supported only on SQL with the exception of execAll method, that provides some additional properties. Interactive transactions are a way to execute multiple SQL statements in a single transaction. This makes possible to delegate application logic to SQL statements - a very common use case is for example checking if the balance > 0 before making a purchase. In order to create a transaction, you must call the NewTx() method on the client instance. The resulting object is a transaction object that can be used to execute multiple SQL statements, queries, commit or rollback. Following there are methods exposed by the transaction object: Commit() CommittedSQLTx, error Rollback() error SQLExec(sql, params) error SQLQuery(sql, params) SQLQueryResult, error It's possible to rollback a transaction by calling the Rollback() method. In this case, the transaction object is no longer valid and should not be used anymore. To commit a transaction, you must call the Commit() method. Note : At the moment immudb support only 1 read-write transaction at a time, so it's up the application to ensure that only one read-write transaction is open at a time, or to handle read conflict error. In such case the error code returned by sdk will be 25P02 CodInFailedSqlTransaction . :::: tabs ::: tab Go cli := immudb.NewClient() err := cli.OpenSession(context.TODO(), []byte(`immudb`), []byte(`immudb`), \"defaultdb\") if err != nil { log.Fatal(err) } tx1, err := cli.NewTx(context.TODO()) if err != nil { log.Fatal(err) } err = tx1.SQLExec(context.TODO(), `CREATE TABLE table1(id INTEGER,PRIMARY KEY id);`, nil) if err != nil { log.Fatal(err) } rand.Seed(time.Now().UnixNano()) err = tx1.SQLExec(context.TODO(), fmt.Sprintf(\"INSERT INTO table1(id) VALUES (%d)\", rand.Int()), nil) if err != nil { log.Fatal(err) } txh, err := tx1.Commit(context.TODO()) if err != nil { log.Fatal(err) } fmt.Printf(\"Successfully committed rows %d\\n\", txh.UpdatedRows) err = cli.CloseSession(context.TODO()) if err != nil { log.Fatal(err) } ::: ::: tab Java This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Java sdk github project ::: ::: tab Python Currently immudb Python sdk doesn't support interactive transactions. However you can still use non-interactive SQL Transactions. from immudb import ImmudbClient from uuid import uuid4 URL = \"localhost:3322\" # ImmuDB running on your machine LOGIN = \"immudb\" # Default username PASSWORD = \"immudb\" # Default password DB = b\"defaultdb\" # Default database name (must be in bytes) def main(): client = ImmudbClient(URL) client.login(LOGIN, PASSWORD, database = DB) client.sqlExec(\"\"\" CREATE TABLE IF NOT EXISTS example ( uniqueID VARCHAR[64], value VARCHAR[32], created TIMESTAMP, PRIMARY KEY(uniqueID) );\"\"\") client.sqlExec(\"\"\" CREATE TABLE IF NOT EXISTS related ( id INTEGER AUTO_INCREMENT, uniqueID VARCHAR[64], relatedValue VARCHAR[32], PRIMARY KEY(id) );\"\"\") uid1 = str(uuid4()) uid2 = str(uuid4()) params = { \"uid1\": uid1, \"uid2\": uid2 } resp = client.sqlExec(\"\"\" BEGIN TRANSACTION; INSERT INTO example (uniqueID, value, created) VALUES (@uid1, 'test1', NOW()), (@uid2, 'test2', NOW()); INSERT INTO related (uniqueID, relatedValue) VALUES (@uid1, 'related1'), (@uid2, 'related2'); INSERT INTO related (uniqueID, relatedValue) VALUES (@uid1, 'related3'), (@uid2, 'related4'); COMMIT; \"\"\", params) transactionId = resp.txs[0].header.id result = client.sqlQuery(\"\"\" SELECT related.id, related.uniqueID, example.value, related.relatedValue, example.created FROM related JOIN example ON example.uniqueID = related.uniqueID; \"\"\") for item in result: id, uid, value, relatedValue, created = item print(\"ITEM\", id, uid, value, relatedValue, created.isoformat()) result = client.sqlQuery(f\"\"\" SELECT related.id, related.uniqueID, example.value, related.relatedValue, example.created FROM related BEFORE TX {transactionId} JOIN example BEFORE TX {transactionId} ON example.uniqueID = related.uniqueID; \"\"\") print(result) # You can't see just added entries, # my fellow time traveller if __name__ == \"__main__\": main() ::: ::: tab Node.js This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on Node.js sdk github project ::: ::: tab .Net This feature is not yet supported or not documented. Do you want to make a feature request or help out? Open an issue on .Net sdk github project ::: ::: tab Others If you're using another development language, please refer to the immugw option. ::: ::::","title":"Transactions"},{"location":"getstarted/build/","text":"Building from source Build the binaries Building binaries requires a Linux operating system. To build the binaries yourself, simply clone immudb repository and run: make all immudb can be cross compiled for different systems and architectures by setting GOOS and GOARCH variables, i.e.: GOOS=windows GOARCH=amd64 make all Build the Docker images If you want to build the container images yourself, simply clone immudb repository and run: docker build -t myown/immudb:latest -f Dockerfile . docker build -t myown/immuadmin:latest -f Dockerfile.immuadmin . docker build -t myown/immuclient:latest -f Dockerfile.immuclient .","title":"Building from source"},{"location":"getstarted/build/#building-from-source","text":"","title":"Building from source"},{"location":"getstarted/build/#build-the-binaries","text":"Building binaries requires a Linux operating system. To build the binaries yourself, simply clone immudb repository and run: make all immudb can be cross compiled for different systems and architectures by setting GOOS and GOARCH variables, i.e.: GOOS=windows GOARCH=amd64 make all","title":"Build the binaries"},{"location":"getstarted/build/#build-the-docker-images","text":"If you want to build the container images yourself, simply clone immudb repository and run: docker build -t myown/immudb:latest -f Dockerfile . docker build -t myown/immuadmin:latest -f Dockerfile.immuadmin . docker build -t myown/immuclient:latest -f Dockerfile.immuclient .","title":"Build the Docker images"},{"location":"getstarted/clitools/","text":"CLI tools Before any operations can be run by immuadmin or immuclient, it is necessary to authenticate against the running immudb server. When immudb is first run, it is ready to use immediately with the default database and credentials: Database name: defaultdb User: immudb Password: immudb Address: 127.0.0.1 Port: 3322 immuadmin immuadmin is the admin client for immudb. It is used for a variety of tasks such as creating and updating databases and users. Creating backups, restoring from backups etc. You may download the immuadmin binary from the latest releases on Github . Once you have downloaded immuadmin, rename it to immuadmin , make sure to mark it as executable, then run it. The following example shows how to obtain v1.3.0 for Linux amd64: $ wget https://github.com/vchain-us/immudb/releases/download/v1.3.0/immuadmin-v1.3.0-linux-amd64 $ mv immuadmin-v1.3.0-linux-amd64 immuadmin $ chmod +x immuadmin Alternatively, you may pull immuclient docker image from DockerHub and run it in a ready-to-use container: $ docker run -it --rm --name immuadmin codenotary/immuadmin:latest status Basic operations To get started we need to login to immuadmin first. The admin user is the similar to the root user in MySQL etc. $ ./immuadmin login immudb Password: immudb Once logged in we can create a new database using $ ./immuadmin database create mydatabase database 'mydatabase' {replica: false} successfully created To switch to our newly created database $ ./immuclient use mydatabase Now using mydatabase To create new user with read/write access to just created database $ ./immuadmin user create user1 readwrite mydatabase Choose a password for user1: Confirm password: For detailed description of immuadmin command arguments use help $ ./immuadmin help immuclient immuclient is used for interacting with databases, like reading, writing and querying for data or invoking SQL. You may download the immuclient binary from the latest releases on Github . Once you have downloaded immuclient, rename it to immuclient , make sure to mark it as executable, then run it. The following example shows how to obtain v1.3.0 for Linux amd64: $ wget https://github.com/vchain-us/immudb/releases/download/v1.3.0/immuclient-v1.3.0-linux-amd64 $ mv immuclient-v1.3.0-linux-amd64 immuclient $ chmod +x immuclient Alternatively, you may pull immuclient docker image from DockerHub and run it in a ready-to-use container: $ docker run -it --rm --net host --name immuclient codenotary/immuclient:latest Basic operations To display all available options and their description run: $ ./immudb help Running login immudb from within immuclient will use the default database name and port. All you need to supply is the user and password: $ ./immuclient login immudb Password: immudb While immudb supports set and get for key-value storing and retrieving, its immutability means that we can verify the integrity of the underlying Merkle tree. To do this, we use the safeset and safeget commands. Let's try setting a value of 100 for the key balance : $ ./immuclient safeset balance 100 tx: 2 key: balance value: 100 verified: true Then, we can immediately overwrite the key balance with a value of 9001 instead: $ ./immuclient safeset balance 9001 tx: 3 key: balance value: 9001 verified: true If we try to retrieve the current value of key balance , we should get 9001 : $ ./immuclient safeget balance tx: 3 key: balance value: 9001 verified: true Note that at each step so far, the verified flag is set to true. This ensures that the Merkle tree remains consistent for each transaction. We can show the history of transactions for key balance using the history command: $ ./immuclient history balance tx: 2 key: balance value: 100 tx: 3 key: balance value: 9001 SQL operations In addition to a key-value store, immudb supports the relational model (SQL). For example, to create a table: $ ./immuclient exec \"CREATE TABLE people(id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY id);\" Updated rows: 0 To insert data, use UPSERT (insert or update), which will add an entry, or overwrite it if already exists (based on the primary key): $ ./immuclient exec \"UPSERT INTO people(id, name, salary) VALUES (1, 'Joe', 10000);\" Updated rows: 1 $ ./immuclient exec \"UPSERT INTO people(id, name, salary) VALUES (2, 'Bob', 30000);\" Updated rows: 1 To query the data you can use the traditional SELECT : $ ./immuclient query \"SELECT id, name, salary FROM people;\" +------------------------+--------------------------+----------------------------+ | (MYDATABASE PEOPLE ID) | (MYDATABASE PEOPLE NAME) | (MYDATABASE PEOPLE SALARY) | +------------------------+--------------------------+----------------------------+ | 1 | \"Joe\" | 10000 | | 2 | \"Bob\" | 30000 | +------------------------+--------------------------+----------------------------+ If we upsert again on the primary key \"1\", the value for \"Joe\" will be overwritten: $ ./immuclient exec \"UPSERT INTO people(id, name, salary) VALUES (1, 'Joe', 20000);\" Updated rows: 1 $ ./immuclient query \"SELECT id, name, salary FROM people;\" +------------------------+--------------------------+----------------------------+ | (MYDATABASE PEOPLE ID) | (MYDATABASE PEOPLE NAME) | (MYDATABASE PEOPLE SALARY) | +------------------------+--------------------------+----------------------------+ | 1 | \"Joe\" | 20000 | | 2 | \"Bob\" | 30000 | +------------------------+--------------------------+----------------------------+ Time travel immudb is a immutable database. History is always preserved. With immudb you can travel in time! $ ./immuclient query \"SELECT id, name, salary FROM people WHERE name='Joe';\" +------------------------+--------------------------+----------------------------+ | (MYDATABASE PEOPLE ID) | (MYDATABASE PEOPLE NAME) | (MYDATABASE PEOPLE SALARY) | +------------------------+--------------------------+----------------------------+ | 1 | \"Joe\" | 20000 | +------------------------+--------------------------+----------------------------+ We can see the current transaction id using 'current': $ ./immuclient current database: mydatabase txID: 5 hash: 2986dfeb2d15e55d8189f08c2508318addabe9e773e0b6e329cf23b654cc22e7 This is the transaction id we will be using for the subsequent queries. Eg. before the update: $ ./immuclient query \"SELECT id, name, salary FROM people BEFORE TX 5 WHERE name='Joe';\" +------------------------+--------------------------+----------------------------+ | (MYDATABASE PEOPLE ID) | (MYDATABASE PEOPLE NAME) | (MYDATABASE PEOPLE SALARY) | +------------------------+--------------------------+----------------------------+ | 1 | \"Joe\" | 10000 | +------------------------+--------------------------+----------------------------+ or even before the first time insert (guess what, it is empty!): $ ./immuclient query \"SELECT id, name, salary FROM people BEFORE TX 1 WHERE name='Joe';\" +------------------------+--------------------------+----------------------------+ | (MYDATABASE PEOPLE ID) | (MYDATABASE PEOPLE NAME) | (MYDATABASE PEOPLE SALARY) | +------------------------+--------------------------+----------------------------+ +------------------------+--------------------------+----------------------------+ You can even TABLE a table with itself in the past. Imagine you want to see how people salary changed between two points in time: $ ./immuclient query \"SELECT peoplenow.id, peoplenow.name, peoplethen.salary, peoplenow.salary FROM people BEFORE TX 5 AS peoplethen INNER JOIN people AS peoplenow ON peoplenow.id=peoplethen.id;\" +---------------------------+-----------------------------+--------------------------------+-------------------------------+ | (MYDATABASE PEOPLENOW ID) | (MYDATABASE PEOPLENOW NAME) | (MYDATABASE PEOPLETHEN SALARY) | (MYDATABASE PEOPLENOW SALARY) | +---------------------------+-----------------------------+--------------------------------+-------------------------------+ | 1 | \"Joe\" | 10000 | 20000 | | 2 | \"Bob\" | 30000 | 30000 | +---------------------------+-----------------------------+--------------------------------+-------------------------------+ KV Data revisions Whenever a new value is stored under given key, immudb saves a new revision of that data. Revision numbers start with 1 - the first value ever written to the database will have a revision number 1, the second will have 2 and so on. When reading a value from immudb, an explicit revision number can be specified. If the provided number is greater than 0, a value for given revision is retrieved. If the provided number is less than 0, the nth previous value is retrieved. $ ./immuclient set key value1 tx: 2 rev: 1 key: key value: value1 $ ./immuclient set key value2 tx: 3 rev: 2 key: key value: value2 $ ./immuclient set key value3 tx: 4 rev: 3 key: key value: value3 $ ./immuclient get key@1 # Get the key at the first revision tx: 2 rev: 1 key: key value: value1 $ ./immuclient get key@-1 # Get the key at the previous revision tx: 3 rev: 2 key: key value: value2 The immuclient tool has also the possibility to restore a previous revision for given key. $ ./immuclient restore key@-2 tx: 5 rev: 4 key: key value: value1 Querying for keys containing revision separator In some cases, the key can already contain the @ character reserved for key separator. In such case there are few options to read such key. The revision separator can be changed to any other string that is not part of the key. Also because immuclient will only scan the last occurrence of the revision separator, an explicit 0th revision can be set to read the current value behind such key. $ ./immuclient set some@email.address active tx: 2 rev: 1 key: some@email.address value: active # Change the revision separator with environment variable $ IMMUCLIENT_REVISION_SEPARATOR=\"###\" ./immuclient get some@email.address tx: 2 key: some@email.address value: active hash: 138033b5a89438758fdb3481ba0dc44816d550749f799223587cb30cd7eadf5a # Disable / change the revision separator through command-line argument $ ./immuclient get --revision-separator=\"\" some@email.address tx: 2 rev: 1 key: some@email.address value: active # Always use the revision number, use 0 for the current value $ ./immuclient get some@email.address@0 tx: 2 rev: 1 key: some@email.address value: active","title":"CLI tools"},{"location":"getstarted/clitools/#cli-tools","text":"Before any operations can be run by immuadmin or immuclient, it is necessary to authenticate against the running immudb server. When immudb is first run, it is ready to use immediately with the default database and credentials: Database name: defaultdb User: immudb Password: immudb Address: 127.0.0.1 Port: 3322","title":"CLI tools"},{"location":"getstarted/clitools/#immuadmin","text":"immuadmin is the admin client for immudb. It is used for a variety of tasks such as creating and updating databases and users. Creating backups, restoring from backups etc. You may download the immuadmin binary from the latest releases on Github . Once you have downloaded immuadmin, rename it to immuadmin , make sure to mark it as executable, then run it. The following example shows how to obtain v1.3.0 for Linux amd64: $ wget https://github.com/vchain-us/immudb/releases/download/v1.3.0/immuadmin-v1.3.0-linux-amd64 $ mv immuadmin-v1.3.0-linux-amd64 immuadmin $ chmod +x immuadmin Alternatively, you may pull immuclient docker image from DockerHub and run it in a ready-to-use container: $ docker run -it --rm --name immuadmin codenotary/immuadmin:latest status","title":"immuadmin"},{"location":"getstarted/clitools/#basic-operations","text":"To get started we need to login to immuadmin first. The admin user is the similar to the root user in MySQL etc. $ ./immuadmin login immudb Password: immudb Once logged in we can create a new database using $ ./immuadmin database create mydatabase database 'mydatabase' {replica: false} successfully created To switch to our newly created database $ ./immuclient use mydatabase Now using mydatabase To create new user with read/write access to just created database $ ./immuadmin user create user1 readwrite mydatabase Choose a password for user1: Confirm password: For detailed description of immuadmin command arguments use help $ ./immuadmin help","title":"Basic operations"},{"location":"getstarted/clitools/#immuclient","text":"immuclient is used for interacting with databases, like reading, writing and querying for data or invoking SQL. You may download the immuclient binary from the latest releases on Github . Once you have downloaded immuclient, rename it to immuclient , make sure to mark it as executable, then run it. The following example shows how to obtain v1.3.0 for Linux amd64: $ wget https://github.com/vchain-us/immudb/releases/download/v1.3.0/immuclient-v1.3.0-linux-amd64 $ mv immuclient-v1.3.0-linux-amd64 immuclient $ chmod +x immuclient Alternatively, you may pull immuclient docker image from DockerHub and run it in a ready-to-use container: $ docker run -it --rm --net host --name immuclient codenotary/immuclient:latest","title":"immuclient"},{"location":"getstarted/clitools/#basic-operations_1","text":"To display all available options and their description run: $ ./immudb help Running login immudb from within immuclient will use the default database name and port. All you need to supply is the user and password: $ ./immuclient login immudb Password: immudb While immudb supports set and get for key-value storing and retrieving, its immutability means that we can verify the integrity of the underlying Merkle tree. To do this, we use the safeset and safeget commands. Let's try setting a value of 100 for the key balance : $ ./immuclient safeset balance 100 tx: 2 key: balance value: 100 verified: true Then, we can immediately overwrite the key balance with a value of 9001 instead: $ ./immuclient safeset balance 9001 tx: 3 key: balance value: 9001 verified: true If we try to retrieve the current value of key balance , we should get 9001 : $ ./immuclient safeget balance tx: 3 key: balance value: 9001 verified: true Note that at each step so far, the verified flag is set to true. This ensures that the Merkle tree remains consistent for each transaction. We can show the history of transactions for key balance using the history command: $ ./immuclient history balance tx: 2 key: balance value: 100 tx: 3 key: balance value: 9001","title":"Basic operations"},{"location":"getstarted/clitools/#sql-operations","text":"In addition to a key-value store, immudb supports the relational model (SQL). For example, to create a table: $ ./immuclient exec \"CREATE TABLE people(id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY id);\" Updated rows: 0 To insert data, use UPSERT (insert or update), which will add an entry, or overwrite it if already exists (based on the primary key): $ ./immuclient exec \"UPSERT INTO people(id, name, salary) VALUES (1, 'Joe', 10000);\" Updated rows: 1 $ ./immuclient exec \"UPSERT INTO people(id, name, salary) VALUES (2, 'Bob', 30000);\" Updated rows: 1 To query the data you can use the traditional SELECT : $ ./immuclient query \"SELECT id, name, salary FROM people;\" +------------------------+--------------------------+----------------------------+ | (MYDATABASE PEOPLE ID) | (MYDATABASE PEOPLE NAME) | (MYDATABASE PEOPLE SALARY) | +------------------------+--------------------------+----------------------------+ | 1 | \"Joe\" | 10000 | | 2 | \"Bob\" | 30000 | +------------------------+--------------------------+----------------------------+ If we upsert again on the primary key \"1\", the value for \"Joe\" will be overwritten: $ ./immuclient exec \"UPSERT INTO people(id, name, salary) VALUES (1, 'Joe', 20000);\" Updated rows: 1 $ ./immuclient query \"SELECT id, name, salary FROM people;\" +------------------------+--------------------------+----------------------------+ | (MYDATABASE PEOPLE ID) | (MYDATABASE PEOPLE NAME) | (MYDATABASE PEOPLE SALARY) | +------------------------+--------------------------+----------------------------+ | 1 | \"Joe\" | 20000 | | 2 | \"Bob\" | 30000 | +------------------------+--------------------------+----------------------------+","title":"SQL operations"},{"location":"getstarted/clitools/#time-travel","text":"immudb is a immutable database. History is always preserved. With immudb you can travel in time! $ ./immuclient query \"SELECT id, name, salary FROM people WHERE name='Joe';\" +------------------------+--------------------------+----------------------------+ | (MYDATABASE PEOPLE ID) | (MYDATABASE PEOPLE NAME) | (MYDATABASE PEOPLE SALARY) | +------------------------+--------------------------+----------------------------+ | 1 | \"Joe\" | 20000 | +------------------------+--------------------------+----------------------------+ We can see the current transaction id using 'current': $ ./immuclient current database: mydatabase txID: 5 hash: 2986dfeb2d15e55d8189f08c2508318addabe9e773e0b6e329cf23b654cc22e7 This is the transaction id we will be using for the subsequent queries. Eg. before the update: $ ./immuclient query \"SELECT id, name, salary FROM people BEFORE TX 5 WHERE name='Joe';\" +------------------------+--------------------------+----------------------------+ | (MYDATABASE PEOPLE ID) | (MYDATABASE PEOPLE NAME) | (MYDATABASE PEOPLE SALARY) | +------------------------+--------------------------+----------------------------+ | 1 | \"Joe\" | 10000 | +------------------------+--------------------------+----------------------------+ or even before the first time insert (guess what, it is empty!): $ ./immuclient query \"SELECT id, name, salary FROM people BEFORE TX 1 WHERE name='Joe';\" +------------------------+--------------------------+----------------------------+ | (MYDATABASE PEOPLE ID) | (MYDATABASE PEOPLE NAME) | (MYDATABASE PEOPLE SALARY) | +------------------------+--------------------------+----------------------------+ +------------------------+--------------------------+----------------------------+ You can even TABLE a table with itself in the past. Imagine you want to see how people salary changed between two points in time: $ ./immuclient query \"SELECT peoplenow.id, peoplenow.name, peoplethen.salary, peoplenow.salary FROM people BEFORE TX 5 AS peoplethen INNER JOIN people AS peoplenow ON peoplenow.id=peoplethen.id;\" +---------------------------+-----------------------------+--------------------------------+-------------------------------+ | (MYDATABASE PEOPLENOW ID) | (MYDATABASE PEOPLENOW NAME) | (MYDATABASE PEOPLETHEN SALARY) | (MYDATABASE PEOPLENOW SALARY) | +---------------------------+-----------------------------+--------------------------------+-------------------------------+ | 1 | \"Joe\" | 10000 | 20000 | | 2 | \"Bob\" | 30000 | 30000 | +---------------------------+-----------------------------+--------------------------------+-------------------------------+","title":"Time travel"},{"location":"getstarted/clitools/#kv-data-revisions","text":"Whenever a new value is stored under given key, immudb saves a new revision of that data. Revision numbers start with 1 - the first value ever written to the database will have a revision number 1, the second will have 2 and so on. When reading a value from immudb, an explicit revision number can be specified. If the provided number is greater than 0, a value for given revision is retrieved. If the provided number is less than 0, the nth previous value is retrieved. $ ./immuclient set key value1 tx: 2 rev: 1 key: key value: value1 $ ./immuclient set key value2 tx: 3 rev: 2 key: key value: value2 $ ./immuclient set key value3 tx: 4 rev: 3 key: key value: value3 $ ./immuclient get key@1 # Get the key at the first revision tx: 2 rev: 1 key: key value: value1 $ ./immuclient get key@-1 # Get the key at the previous revision tx: 3 rev: 2 key: key value: value2 The immuclient tool has also the possibility to restore a previous revision for given key. $ ./immuclient restore key@-2 tx: 5 rev: 4 key: key value: value1","title":"KV Data revisions"},{"location":"getstarted/clitools/#querying-for-keys-containing-revision-separator","text":"In some cases, the key can already contain the @ character reserved for key separator. In such case there are few options to read such key. The revision separator can be changed to any other string that is not part of the key. Also because immuclient will only scan the last occurrence of the revision separator, an explicit 0th revision can be set to read the current value behind such key. $ ./immuclient set some@email.address active tx: 2 rev: 1 key: some@email.address value: active # Change the revision separator with environment variable $ IMMUCLIENT_REVISION_SEPARATOR=\"###\" ./immuclient get some@email.address tx: 2 key: some@email.address value: active hash: 138033b5a89438758fdb3481ba0dc44816d550749f799223587cb30cd7eadf5a # Disable / change the revision separator through command-line argument $ ./immuclient get --revision-separator=\"\" some@email.address tx: 2 rev: 1 key: some@email.address value: active # Always use the revision number, use 0 for the current value $ ./immuclient get some@email.address@0 tx: 2 rev: 1 key: some@email.address value: active","title":"Querying for keys containing revision separator"},{"location":"getstarted/jumpstart/","text":"SDKs ::: tip Examples used in this documentation can be found in immudb examples repository . ::: In the most common scenario, you would perform write and read operations on the database talking to the server. In this case your application will be a client to immudb. SDKs make it comfortable to talk to the server from your favorite language, without having to deal with details about how to talk to it. The most well-known and recommended immudb SDK is written in Golang , but there are other SDKs available, both maintained by the internal team and by the community. Language Maintainer Immdb version link Notes go immudb team 1.3.0 link python immudb team 1.2.4 link JAVA immudb team 1.2.1 link Verification is not working NODE immudb team 1.2.1 link Verification is not working JS immudb team 1.2.1 link Verification is not working ruby Community ( Ankane ) 1.2.1 link Verification is not working The immudb server manages the requests from the outside world to the store. In order to insert or retrieve data, you need to talk with the server. ![SDK Architecture](/immudb/immudb-server.svg) immugw communication For other unsupported programming languages, immugw provides a REST gateway that can be used to talk to the server via generic HTTP. immugw can be found in its own repository immugw proxies REST client communication and gRPC server interface. For security reasons, immugw should not run on the same server as immudb. The following diagram shows how the communication works:","title":"SDKs"},{"location":"getstarted/jumpstart/#sdks","text":"::: tip Examples used in this documentation can be found in immudb examples repository . ::: In the most common scenario, you would perform write and read operations on the database talking to the server. In this case your application will be a client to immudb. SDKs make it comfortable to talk to the server from your favorite language, without having to deal with details about how to talk to it. The most well-known and recommended immudb SDK is written in Golang , but there are other SDKs available, both maintained by the internal team and by the community. Language Maintainer Immdb version link Notes go immudb team 1.3.0 link python immudb team 1.2.4 link JAVA immudb team 1.2.1 link Verification is not working NODE immudb team 1.2.1 link Verification is not working JS immudb team 1.2.1 link Verification is not working ruby Community ( Ankane ) 1.2.1 link Verification is not working The immudb server manages the requests from the outside world to the store. In order to insert or retrieve data, you need to talk with the server. ![SDK Architecture](/immudb/immudb-server.svg)","title":"SDKs"},{"location":"getstarted/jumpstart/#immugw-communication","text":"For other unsupported programming languages, immugw provides a REST gateway that can be used to talk to the server via generic HTTP. immugw can be found in its own repository immugw proxies REST client communication and gRPC server interface. For security reasons, immugw should not run on the same server as immudb. The following diagram shows how the communication works:","title":"immugw communication"},{"location":"getstarted/quickstart/","text":"Running ::: tip To learn interactively and to get started with immudb from the command line and with programming languages, visit the immudb Playground at https://play.codenotary.com ::: You may download the immudb binary from the latest releases on Github . Once you have downloaded immudb, rename it to immudb , make sure to mark it as executable, then run it. The following example shows how to obtain v1.3.0 for linux amd64: $ wget https://github.com/vchain-us/immudb/releases/download/v1.3.0/immudb-v1.3.0-linux-amd64 $ mv immudb-v1.3.0-linux-amd64 immudb $ chmod +x immudb # run immudb in the foreground to see all output $ ./immudb # or run immudb in the background $ ./immudb -d Alternatively, you may pull immudb docker image from DockerHub and run it in a ready-to-use container: $ docker run -d --net host -it --rm --name immudb codenotary/immudb:latest","title":"Running"},{"location":"getstarted/quickstart/#running","text":"::: tip To learn interactively and to get started with immudb from the command line and with programming languages, visit the immudb Playground at https://play.codenotary.com ::: You may download the immudb binary from the latest releases on Github . Once you have downloaded immudb, rename it to immudb , make sure to mark it as executable, then run it. The following example shows how to obtain v1.3.0 for linux amd64: $ wget https://github.com/vchain-us/immudb/releases/download/v1.3.0/immudb-v1.3.0-linux-amd64 $ mv immudb-v1.3.0-linux-amd64 immudb $ chmod +x immudb # run immudb in the foreground to see all output $ ./immudb # or run immudb in the background $ ./immudb -d Alternatively, you may pull immudb docker image from DockerHub and run it in a ready-to-use container: $ docker run -d --net host -it --rm --name immudb codenotary/immudb:latest","title":"Running"},{"location":"getstarted/webconsole/","text":"Web Console immudb includes an embedded web console which can be accessed via the default port 8080 ( web-server-port option). The console allows you to: Metrics for the default database Execute SQL queries Configure users Create databases Manage permissions for users Accessing the Web Console Once immudb has started, it will tell you if the web console is enabled and where it is listening: immudb 2021/05/17 21:38:30 INFO: Webconsole enabled: 0.0.0.0:8080 immudb 2021/05/17 21:38:30 INFO: Web API server enabled on 0.0.0.0:8080/api (http) Just navigating to that address in your web browser will bring you to the login screen:","title":"Web Console"},{"location":"getstarted/webconsole/#web-console","text":"immudb includes an embedded web console which can be accessed via the default port 8080 ( web-server-port option). The console allows you to: Metrics for the default database Execute SQL queries Configure users Create databases Manage permissions for users","title":"Web Console"},{"location":"getstarted/webconsole/#accessing-the-web-console","text":"Once immudb has started, it will tell you if the web console is enabled and where it is listening: immudb 2021/05/17 21:38:30 INFO: Webconsole enabled: 0.0.0.0:8080 immudb 2021/05/17 21:38:30 INFO: Web API server enabled on 0.0.0.0:8080/api (http) Just navigating to that address in your web browser will bring you to the login screen:","title":"Accessing the Web Console"},{"location":"operations/auditor/","text":"Use immuclient as Auditor The Auditor is a component for checking if immudb was tampered, it's a good practice to run the auditor as a separate and independent component. immuclient can act as Auditor by running the following command: Start interactive: $ ./immuclient audit-mode 1m0s immuclientd 2022/05/22 12:34:11 INFO: starting auditor with a 1m0s interval ... immuclientd 2022/05/22 12:34:11 INFO: auditor monitoring HTTP server starting on 0.0.0.0:9477 ... immuclientd 2022/05/22 12:34:11 INFO: audit #1 started @ 2022-05-22 12:34:11.543823286 +0200 CEST m=+0.153679785 immuclientd 2022/05/22 12:34:11 INFO: audit #1 - list of databases to audit has been (re)loaded - 2 database(s) found: [defaultdb mydatabase] immuclientd 2022/05/22 12:34:11 INFO: audit #1 - auditing database defaultdb immuclientd 2022/05/22 12:34:11 INFO: audit #1 finished in 55.295777ms @ 2022-05-22T12:34:11.599119184+02:00 immuclient is now running on the following address: 0.0.0.0:9477/metrics example output: # HELP immuclient_audit_curr_root_per_server Current root index used for the latest audit. # TYPE immuclient_audit_curr_root_per_server gauge immuclient_audit_curr_root_per_server{server_address=\"127.0.0.1:3322\",server_id=\"br8eugq036tfln0ct6o0\"} 2 # HELP immuclient_audit_prev_root_per_server Previous root index used for the latest audit. # TYPE immuclient_audit_prev_root_per_server gauge immuclient_audit_prev_root_per_server{server_address=\"127.0.0.1:3322\",server_id=\"br8eugq036tfln0ct6o0\"} -1 # HELP immuclient_audit_result_per_server Latest audit result (1 = ok, 0 = tampered). # TYPE immuclient_audit_result_per_server gauge immuclient_audit_result_per_server{server_address=\"127.0.0.1:3322\",server_id=\"br8eugq036tfln0ct6o0\"} -1 # HELP immuclient_audit_run_at_per_server Timestamp in unix seconds at which latest audit run. # TYPE immuclient_audit_run_at_per_server gauge immuclient_audit_run_at_per_server{server_address=\"127.0.0.1:3322\",server_id=\"br8eugq036tfln0ct6o0\"} 1.5907565337454605e+09 immuclient looks for immudb at 127.0.0.1:3322 by default with the default username and password. Nevertheless a number of parameters can be defined: immuclient audit-mode - Run a foreground auditor immuclient audit-mode install - Install and runs daemon immuclient audit-mode stop - Stops the daemon immuclient audit-mode start - Starts initialized daemon immuclient audit-mode restart - Restarts daemon immuclient audit-mode uninstall - Removes daemon and its setup Flags: -h, --help help for audit-mode Global Flags: --audit-databases string Optional comma-separated list of databases (names) to be audited. Can be full name(s) or just name prefix(es). --audit-monitoring-host string Host for the monitoring HTTP server when running in audit mode (serves endpoints like metrics, health and version). (default \"0.0.0.0\") --audit-monitoring-port int Port for the monitoring HTTP server when running in audit mode (serves endpoints like metrics, health and version). (default 9477) --audit-notification-password string Password used to authenticate when publishing audit result to 'audit-notification-url'. --audit-notification-url string If set, auditor will send a POST request at this URL with audit result details. --audit-notification-username string Username used to authenticate when publishing audit result to 'audit-notification-url'. --audit-password string immudb password used to login during audit; can be plain-text or base64 encoded (must be prefixed with 'enc:' if it is encoded) --audit-username string immudb username used to login during audit --certificate string server certificate file path (default \"./tools/mtls/4_client/certs/localhost.cert.pem\") --clientcas string clients certificates list. Aka certificate authority (default \"./tools/mtls/2_intermediate/certs/ca-chain.cert.pem\") --config string config file (default path are configs or $HOME. Default filename is immuclient.toml) --database string immudb database to be used --dir string Main directory for audit process tool to initialize (default \"/var/folders/0z/wk6v4sjd31qbvt7l75t_z_v00000gn/T/\") -a, --immudb-address string immudb host address (default \"127.0.0.1\") -p, --immudb-port int immudb port number (default 3322) --max-recv-msg-size int max message size in bytes the client can receive (default 4194304) -m, --mtls enable mutual tls --password string immudb password used to login; can be plain-text or base64 encoded (must be prefixed with 'enc:' if it is encoded) --pkey string server private key path (default \"./tools/mtls/4_client/private/localhost.key.pem\") --roots-filepath string Filepath for storing root hashes after every successful audit loop. Default is tempdir of every OS. (default \"/tmp/\") --server-signing-pub-key string Path to the public key to verify signatures when presents --servername string used to verify the hostname on the returned certificates (default \"localhost\") --tokenfile string authentication token file (default path is $HOME or binary location; default filename is ) --username string immudb username used to login --value-only returning only values for get operations Running immuclient Auditor as a service immuclient as Auditor can be installed in the system with the following command: Install service: immuclient audit-mode install In this case, all parameters are written into the immuclient configuration file: * Linux: /etc/immudb/immuclient.toml * Windows: C:\\ProgramData\\ImmuClient\\config\\immuclient.toml Running immuclient Auditor with docker We also provide a docker image starting immuclient as Auditor: docker pull codenotary/auditor Then it's possible to run the command with: docker run -it -e IMMUCLIENT_IMMUDB_ADDRESS=\"ip\" -e IMMUCLIENT_AUDIT_USERNAME=\"immudb\" -e IMMUCLIENT_AUDIT_PASSWORD=\"immudb\" codenotary/auditor Auditor best practices How can I be notified if my immudb instance was tampered? It's possible to provide an external url that will be triggered in case a tamper is detected. By configuring IMMUCLIENT_AUDIT_NOTIFICATION_URL , a POST request will be sent with the following body: { \"current_state\": { \"hash\": \"string\", \"signature\": { \"public_key\": \"string\", \"signature\": \"string\" }, \"tx\": 0 }, \"db\": \"string\", \"password\": \"string\", \"previous_state\": { \"hash\": \"string\", \"signature\": { \"public_key\": \"string\", \"signature\": \"string\" }, \"tx\": 0 }, \"run_at\": \"2020-11-13T00:53:42+01:00\", \"tampered\": true, \"username\": \"string\" } NOTE: it's not possible to know at which transaction the database was tampered. The Auditor checks every second if the data was tampered - so it's only possible to know at which time frame the tampering was detected. How many Auditors should I run to secure my immudb instance? A proper setup of one immuclient instance can fit most of cases, but there are ways to increase the security on detecting tampering. A single instance can go offline for any reason: network problems, hardware failures or attacks. Therefore a good practice can be to have multiple Auditor instances running in different zones.","title":"Running an Auditor with immuclient"},{"location":"operations/auditor/#use-immuclient-as-auditor","text":"The Auditor is a component for checking if immudb was tampered, it's a good practice to run the auditor as a separate and independent component. immuclient can act as Auditor by running the following command: Start interactive: $ ./immuclient audit-mode 1m0s immuclientd 2022/05/22 12:34:11 INFO: starting auditor with a 1m0s interval ... immuclientd 2022/05/22 12:34:11 INFO: auditor monitoring HTTP server starting on 0.0.0.0:9477 ... immuclientd 2022/05/22 12:34:11 INFO: audit #1 started @ 2022-05-22 12:34:11.543823286 +0200 CEST m=+0.153679785 immuclientd 2022/05/22 12:34:11 INFO: audit #1 - list of databases to audit has been (re)loaded - 2 database(s) found: [defaultdb mydatabase] immuclientd 2022/05/22 12:34:11 INFO: audit #1 - auditing database defaultdb immuclientd 2022/05/22 12:34:11 INFO: audit #1 finished in 55.295777ms @ 2022-05-22T12:34:11.599119184+02:00 immuclient is now running on the following address: 0.0.0.0:9477/metrics example output: # HELP immuclient_audit_curr_root_per_server Current root index used for the latest audit. # TYPE immuclient_audit_curr_root_per_server gauge immuclient_audit_curr_root_per_server{server_address=\"127.0.0.1:3322\",server_id=\"br8eugq036tfln0ct6o0\"} 2 # HELP immuclient_audit_prev_root_per_server Previous root index used for the latest audit. # TYPE immuclient_audit_prev_root_per_server gauge immuclient_audit_prev_root_per_server{server_address=\"127.0.0.1:3322\",server_id=\"br8eugq036tfln0ct6o0\"} -1 # HELP immuclient_audit_result_per_server Latest audit result (1 = ok, 0 = tampered). # TYPE immuclient_audit_result_per_server gauge immuclient_audit_result_per_server{server_address=\"127.0.0.1:3322\",server_id=\"br8eugq036tfln0ct6o0\"} -1 # HELP immuclient_audit_run_at_per_server Timestamp in unix seconds at which latest audit run. # TYPE immuclient_audit_run_at_per_server gauge immuclient_audit_run_at_per_server{server_address=\"127.0.0.1:3322\",server_id=\"br8eugq036tfln0ct6o0\"} 1.5907565337454605e+09 immuclient looks for immudb at 127.0.0.1:3322 by default with the default username and password. Nevertheless a number of parameters can be defined: immuclient audit-mode - Run a foreground auditor immuclient audit-mode install - Install and runs daemon immuclient audit-mode stop - Stops the daemon immuclient audit-mode start - Starts initialized daemon immuclient audit-mode restart - Restarts daemon immuclient audit-mode uninstall - Removes daemon and its setup Flags: -h, --help help for audit-mode Global Flags: --audit-databases string Optional comma-separated list of databases (names) to be audited. Can be full name(s) or just name prefix(es). --audit-monitoring-host string Host for the monitoring HTTP server when running in audit mode (serves endpoints like metrics, health and version). (default \"0.0.0.0\") --audit-monitoring-port int Port for the monitoring HTTP server when running in audit mode (serves endpoints like metrics, health and version). (default 9477) --audit-notification-password string Password used to authenticate when publishing audit result to 'audit-notification-url'. --audit-notification-url string If set, auditor will send a POST request at this URL with audit result details. --audit-notification-username string Username used to authenticate when publishing audit result to 'audit-notification-url'. --audit-password string immudb password used to login during audit; can be plain-text or base64 encoded (must be prefixed with 'enc:' if it is encoded) --audit-username string immudb username used to login during audit --certificate string server certificate file path (default \"./tools/mtls/4_client/certs/localhost.cert.pem\") --clientcas string clients certificates list. Aka certificate authority (default \"./tools/mtls/2_intermediate/certs/ca-chain.cert.pem\") --config string config file (default path are configs or $HOME. Default filename is immuclient.toml) --database string immudb database to be used --dir string Main directory for audit process tool to initialize (default \"/var/folders/0z/wk6v4sjd31qbvt7l75t_z_v00000gn/T/\") -a, --immudb-address string immudb host address (default \"127.0.0.1\") -p, --immudb-port int immudb port number (default 3322) --max-recv-msg-size int max message size in bytes the client can receive (default 4194304) -m, --mtls enable mutual tls --password string immudb password used to login; can be plain-text or base64 encoded (must be prefixed with 'enc:' if it is encoded) --pkey string server private key path (default \"./tools/mtls/4_client/private/localhost.key.pem\") --roots-filepath string Filepath for storing root hashes after every successful audit loop. Default is tempdir of every OS. (default \"/tmp/\") --server-signing-pub-key string Path to the public key to verify signatures when presents --servername string used to verify the hostname on the returned certificates (default \"localhost\") --tokenfile string authentication token file (default path is $HOME or binary location; default filename is ) --username string immudb username used to login --value-only returning only values for get operations","title":"Use immuclient as Auditor"},{"location":"operations/auditor/#running-immuclient-auditor-as-a-service","text":"immuclient as Auditor can be installed in the system with the following command: Install service: immuclient audit-mode install In this case, all parameters are written into the immuclient configuration file: * Linux: /etc/immudb/immuclient.toml * Windows: C:\\ProgramData\\ImmuClient\\config\\immuclient.toml","title":"Running immuclient Auditor as a service"},{"location":"operations/auditor/#running-immuclient-auditor-with-docker","text":"We also provide a docker image starting immuclient as Auditor: docker pull codenotary/auditor Then it's possible to run the command with: docker run -it -e IMMUCLIENT_IMMUDB_ADDRESS=\"ip\" -e IMMUCLIENT_AUDIT_USERNAME=\"immudb\" -e IMMUCLIENT_AUDIT_PASSWORD=\"immudb\" codenotary/auditor","title":"Running immuclient Auditor with docker"},{"location":"operations/auditor/#auditor-best-practices","text":"","title":"Auditor best practices"},{"location":"operations/auditor/#how-can-i-be-notified-if-my-immudb-instance-was-tampered","text":"It's possible to provide an external url that will be triggered in case a tamper is detected. By configuring IMMUCLIENT_AUDIT_NOTIFICATION_URL , a POST request will be sent with the following body: { \"current_state\": { \"hash\": \"string\", \"signature\": { \"public_key\": \"string\", \"signature\": \"string\" }, \"tx\": 0 }, \"db\": \"string\", \"password\": \"string\", \"previous_state\": { \"hash\": \"string\", \"signature\": { \"public_key\": \"string\", \"signature\": \"string\" }, \"tx\": 0 }, \"run_at\": \"2020-11-13T00:53:42+01:00\", \"tampered\": true, \"username\": \"string\" } NOTE: it's not possible to know at which transaction the database was tampered. The Auditor checks every second if the data was tampered - so it's only possible to know at which time frame the tampering was detected.","title":"How can I be notified if my immudb instance was tampered?"},{"location":"operations/auditor/#how-many-auditors-should-i-run-to-secure-my-immudb-instance","text":"A proper setup of one immuclient instance can fit most of cases, but there are ways to increase the security on detecting tampering. A single instance can go offline for any reason: network problems, hardware failures or attacks. Therefore a good practice can be to have multiple Auditor instances running in different zones.","title":"How many Auditors should I run to secure my immudb instance?"},{"location":"operations/backup/","text":"Hot backup and restore Hot backup/restore feature allows to backup and restore immudb database without stopping immudb engine. Database remains accessible during backup process. It is possibly to perform full or incremental/differential backup and restore. Both backup and restore functions can use streams or files as a source/destination. Backup file is not compressed, assuming user may use any suitable method (see examples for bzip2 compression). Backup immuadmin hot-backup <database> [-o <file> [--append]] [--start-tx] Full backup To run full database backup, execute immuadmin hot-backup <database> command, specifying the optional backup file name with -o options. If -o option is not specified, output is sent to stdout . If backup file is specified with -o option, the file is created. If file already exists, backup process fails. Incremental backup When backup database up to the existing file, immuadmin tools finds the last backed up database transaction in file, verifies its checksum and appends only database changes, made after this transaction. immuadmin requires user to specify --append command line option to append to existing file. When backup up to the stream, immuadmin doesn't have information about last backup up transaction, however user can specify the ID of the transaction to start from with --start-tx command line option. It allows user to implement incremental/differential backup strategy, using streams. Restore immuadmin hot-restore <database> [-i <file>] [--append] [--force] [--force-replica] Full restore To run full restore, execute immuadmin hot-restore <database> command, specifying the optional backup file name with -o options. If -o option is not specified, input data is read from stdin . If database already exists, restore process fails. Incremental restore If database already exists, it is possible to append new data from backup file to the database. In this case user has to specify --append flag. Transaction overlap/gap handling immuadmin tries to verify that backup file and database where data are being restored to have the same origin. To do this immuadmin finds the last transaction in source database and the same transaction in the backup file, and check transaction signatures. If transactions don't match, restore isn't possible. When there is no overlap between transactions in database and file, transaction verification is not possible. However, if there is no gap between transactions, immuadmin allows to bypass verification with --force command line option. If there is a gap between last transaction in database and first transaction in file, restore isn't possible. Transaction verification During restore process immuadmin checks if checksum, reported by database after restoration of the transaction, matches the one stored in the file during backup process. It allows to detect backup file accidental or malicious corruption. Replica flag handling It is possible to restore data only to the replica database. During full restore database automatically created as replica (replica flag is switched off after restore), but for incremental restore immuadmin assumes database is already in replica mode (user can use immuadmin database update <database> --replication-enabled command to switch on replica mode). However, it is possible to automatically switch on and off replica mode for incremental backup using --force-replica command line option. Verifying backup file immuadmin hot-restore --verify [-i <file>] It is possible to verify backup file/stream using immuadmin hot-restore --verify command. It only checks the correctness of database file, e.g. file format and correct sequence of transactions in file. The only way to detect data corruption is to restore data. Examples Full backup to file: immuadmin hot-backup foo -o foo.backup immuadmin hot-backup foo > foo.backup Incremental backup to file: immuadmin hot-backup foo -o foo.backup --append Incremental backup with bzip2 compression: immuadmin hot-backup foo --start-tx 123 | bzip2 > foo.bz2 Full restore immuadmin hot-restore bar -i foo.backup immuadmin hot-restore bar < foo.backup Full restore from bzip2 -compressed file bunzip2 foo.bz2 -c | immuadmin hot-restore bar Incremental restore with automatic switching of replica mode immuadmin hot-restore bar -i foo.backup --append --force-replica Copy database: immuadmin hot-backup foo | immuadmin hot-restore bar","title":"Hot backup and restore"},{"location":"operations/backup/#hot-backup-and-restore","text":"Hot backup/restore feature allows to backup and restore immudb database without stopping immudb engine. Database remains accessible during backup process. It is possibly to perform full or incremental/differential backup and restore. Both backup and restore functions can use streams or files as a source/destination. Backup file is not compressed, assuming user may use any suitable method (see examples for bzip2 compression).","title":"Hot backup and restore"},{"location":"operations/backup/#backup","text":"immuadmin hot-backup <database> [-o <file> [--append]] [--start-tx]","title":"Backup"},{"location":"operations/backup/#full-backup","text":"To run full database backup, execute immuadmin hot-backup <database> command, specifying the optional backup file name with -o options. If -o option is not specified, output is sent to stdout . If backup file is specified with -o option, the file is created. If file already exists, backup process fails.","title":"Full backup"},{"location":"operations/backup/#incremental-backup","text":"When backup database up to the existing file, immuadmin tools finds the last backed up database transaction in file, verifies its checksum and appends only database changes, made after this transaction. immuadmin requires user to specify --append command line option to append to existing file. When backup up to the stream, immuadmin doesn't have information about last backup up transaction, however user can specify the ID of the transaction to start from with --start-tx command line option. It allows user to implement incremental/differential backup strategy, using streams.","title":"Incremental backup"},{"location":"operations/backup/#restore","text":"immuadmin hot-restore <database> [-i <file>] [--append] [--force] [--force-replica]","title":"Restore"},{"location":"operations/backup/#full-restore","text":"To run full restore, execute immuadmin hot-restore <database> command, specifying the optional backup file name with -o options. If -o option is not specified, input data is read from stdin . If database already exists, restore process fails.","title":"Full restore"},{"location":"operations/backup/#incremental-restore","text":"If database already exists, it is possible to append new data from backup file to the database. In this case user has to specify --append flag.","title":"Incremental restore"},{"location":"operations/backup/#transaction-overlapgap-handling","text":"immuadmin tries to verify that backup file and database where data are being restored to have the same origin. To do this immuadmin finds the last transaction in source database and the same transaction in the backup file, and check transaction signatures. If transactions don't match, restore isn't possible. When there is no overlap between transactions in database and file, transaction verification is not possible. However, if there is no gap between transactions, immuadmin allows to bypass verification with --force command line option. If there is a gap between last transaction in database and first transaction in file, restore isn't possible.","title":"Transaction overlap/gap handling"},{"location":"operations/backup/#transaction-verification","text":"During restore process immuadmin checks if checksum, reported by database after restoration of the transaction, matches the one stored in the file during backup process. It allows to detect backup file accidental or malicious corruption.","title":"Transaction verification"},{"location":"operations/backup/#replica-flag-handling","text":"It is possible to restore data only to the replica database. During full restore database automatically created as replica (replica flag is switched off after restore), but for incremental restore immuadmin assumes database is already in replica mode (user can use immuadmin database update <database> --replication-enabled command to switch on replica mode). However, it is possible to automatically switch on and off replica mode for incremental backup using --force-replica command line option.","title":"Replica flag handling"},{"location":"operations/backup/#verifying-backup-file","text":"immuadmin hot-restore --verify [-i <file>] It is possible to verify backup file/stream using immuadmin hot-restore --verify command. It only checks the correctness of database file, e.g. file format and correct sequence of transactions in file. The only way to detect data corruption is to restore data.","title":"Verifying backup file"},{"location":"operations/backup/#examples","text":"Full backup to file: immuadmin hot-backup foo -o foo.backup immuadmin hot-backup foo > foo.backup Incremental backup to file: immuadmin hot-backup foo -o foo.backup --append Incremental backup with bzip2 compression: immuadmin hot-backup foo --start-tx 123 | bzip2 > foo.bz2 Full restore immuadmin hot-restore bar -i foo.backup immuadmin hot-restore bar < foo.backup Full restore from bzip2 -compressed file bunzip2 foo.bz2 -c | immuadmin hot-restore bar Incremental restore with automatic switching of replica mode immuadmin hot-restore bar -i foo.backup --append --force-replica Copy database: immuadmin hot-backup foo | immuadmin hot-restore bar","title":"Examples"},{"location":"operations/backwards-compatibility/","text":"Backwards compatibility immudb 1.1 proof compatibility immudb 1.2 introduced KV metadata to support new features such as logical deletion or data expiration. This change required updates to the way a transaction hash is calculated. The downside of such change is that immudb clients using immudb 1.2+ needed an updated method of proof calculation in order to verify newly added data. In some cases it is very hard or impossible to update the verification code on the client side. If this is the case, immudb offers a way to disable metadata to maintain compatibility with older clients. Enabling the 1.1 proof compatibility mode Note: backwards compatibility mode is currently not available for the detaultdb database. When creating new database, the mode can be specified with: $ ./immuadmin database create <db-name> --write-tx-header-version 0 Enabling compatibility mode for existing databases can be done by: $ ./immuadmin database update <db-name> --write-tx-header-version 0 Note: immudb restart is needed to make this change effective. In order to re-enable metadata-enhanced proofs, update database settings with --write-tx-header-version 1 option. Limitations of 1.1 compatibility mode Switching to 1.1-compatible proof mode will disable metadata support and thus will make the following operations unavailable: For KV interface: Logical deletion Data expiration Non-indexable entries For SQL interface: Logical deletion Updates to indexed columns Make sure to test your application before enabling the 1.1 compatibility mode. Working with database that already contains metadata-enhanced entries Even though old clients can not validate proofs for metadata-enhanced records, those can still read the data without proofs as long as those don't use metadata. Operations such as Get , Scan or History will not cause errors in such workloads. If proofs are needed, KV entries that were previously added with metadata should be re-added to the database after enabling immudb 1.1 compatibility mode.","title":"Backwards compatibility"},{"location":"operations/backwards-compatibility/#backwards-compatibility","text":"","title":"Backwards compatibility"},{"location":"operations/backwards-compatibility/#immudb-11-proof-compatibility","text":"immudb 1.2 introduced KV metadata to support new features such as logical deletion or data expiration. This change required updates to the way a transaction hash is calculated. The downside of such change is that immudb clients using immudb 1.2+ needed an updated method of proof calculation in order to verify newly added data. In some cases it is very hard or impossible to update the verification code on the client side. If this is the case, immudb offers a way to disable metadata to maintain compatibility with older clients.","title":"immudb 1.1 proof compatibility"},{"location":"operations/backwards-compatibility/#enabling-the-11-proof-compatibility-mode","text":"Note: backwards compatibility mode is currently not available for the detaultdb database. When creating new database, the mode can be specified with: $ ./immuadmin database create <db-name> --write-tx-header-version 0 Enabling compatibility mode for existing databases can be done by: $ ./immuadmin database update <db-name> --write-tx-header-version 0 Note: immudb restart is needed to make this change effective. In order to re-enable metadata-enhanced proofs, update database settings with --write-tx-header-version 1 option.","title":"Enabling the 1.1 proof compatibility mode"},{"location":"operations/backwards-compatibility/#limitations-of-11-compatibility-mode","text":"Switching to 1.1-compatible proof mode will disable metadata support and thus will make the following operations unavailable: For KV interface: Logical deletion Data expiration Non-indexable entries For SQL interface: Logical deletion Updates to indexed columns Make sure to test your application before enabling the 1.1 compatibility mode.","title":"Limitations of 1.1 compatibility mode"},{"location":"operations/backwards-compatibility/#working-with-database-that-already-contains-metadata-enhanced-entries","text":"Even though old clients can not validate proofs for metadata-enhanced records, those can still read the data without proofs as long as those don't use metadata. Operations such as Get , Scan or History will not cause errors in such workloads. If proofs are needed, KV entries that were previously added with metadata should be re-added to the database after enabling immudb 1.1 compatibility mode.","title":"Working with database that already contains metadata-enhanced entries"},{"location":"operations/monitoring/","text":"Health Monitoring immudb exposes a Prometheus end-point, by default on port 9497 on /metrics . $ curl -s http://localhost:9497/metrics # HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. # TYPE go_gc_duration_seconds summary go_gc_duration_seconds{quantile=\"0\"} 1.3355e-05 go_gc_duration_seconds{quantile=\"0.25\"} 1.3615e-05 go_gc_duration_seconds{quantile=\"0.5\"} 1.9991e-05 go_gc_duration_seconds{quantile=\"0.75\"} 3.0348e-05 go_gc_duration_seconds{quantile=\"1\"} 3.3859e-05 go_gc_duration_seconds_sum 0.000151623 go_gc_duration_seconds_count 7 # HELP go_goroutines Number of goroutines that currently exist. ... Querying metrics with a simple curl command is not a very practical solution. immudb has predefined Grafana dashboard visualizing some of the key metrics. This dashboard can be downloaded from immudb github repository . ![immudb grafana stats](/immudb/grafana-immudb.png) You can also use immuadmin stats to see these metrics without additional tools: $ ./immuadmin stats ![immuadmin stats](/immudb/immuadmin-stats.png) immudb exports the standard Go metrics, so dashboards like Go metrics work out of the box. ![immuadmin stats](/immudb/grafana-go.jpg) For very simple cases, you can use immuadmin status from monitoring scripts to ping the server: $ ./immuadmin status OK - server is reachable and responding to queries","title":"Health Monitoring"},{"location":"operations/monitoring/#health-monitoring","text":"immudb exposes a Prometheus end-point, by default on port 9497 on /metrics . $ curl -s http://localhost:9497/metrics # HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. # TYPE go_gc_duration_seconds summary go_gc_duration_seconds{quantile=\"0\"} 1.3355e-05 go_gc_duration_seconds{quantile=\"0.25\"} 1.3615e-05 go_gc_duration_seconds{quantile=\"0.5\"} 1.9991e-05 go_gc_duration_seconds{quantile=\"0.75\"} 3.0348e-05 go_gc_duration_seconds{quantile=\"1\"} 3.3859e-05 go_gc_duration_seconds_sum 0.000151623 go_gc_duration_seconds_count 7 # HELP go_goroutines Number of goroutines that currently exist. ... Querying metrics with a simple curl command is not a very practical solution. immudb has predefined Grafana dashboard visualizing some of the key metrics. This dashboard can be downloaded from immudb github repository . ![immudb grafana stats](/immudb/grafana-immudb.png) You can also use immuadmin stats to see these metrics without additional tools: $ ./immuadmin stats ![immuadmin stats](/immudb/immuadmin-stats.png) immudb exports the standard Go metrics, so dashboards like Go metrics work out of the box. ![immuadmin stats](/immudb/grafana-go.jpg) For very simple cases, you can use immuadmin status from monitoring scripts to ping the server: $ ./immuadmin status OK - server is reachable and responding to queries","title":"Health Monitoring"},{"location":"operations/planning/","text":"Planning Before running a database in production, it is important to plan: Computing resources Disk space Configuration Backups Health Monitoring Computing Resources immudb was designed to have a stable memory/CPU footprint. Memory is pre-allocated based on specified maximum concurrency, maximum number of entries per transaction, cache sizes, etc. With the default settings, it's possible to stress immudb and memory usage should stay around 1.5GB (assuming low-sized values). Otherwise, memory will be needed to maintain the values within a transaction during commit time. Disk space and data location immudb is an immutable database, this means all history is preserved and therefore disk usage is higher than a normal database. Data is stored in the directory specified by the dir option.","title":"Planning"},{"location":"operations/planning/#planning","text":"Before running a database in production, it is important to plan: Computing resources Disk space Configuration Backups Health Monitoring","title":"Planning"},{"location":"operations/planning/#computing-resources","text":"immudb was designed to have a stable memory/CPU footprint. Memory is pre-allocated based on specified maximum concurrency, maximum number of entries per transaction, cache sizes, etc. With the default settings, it's possible to stress immudb and memory usage should stay around 1.5GB (assuming low-sized values). Otherwise, memory will be needed to maintain the values within a transaction during commit time.","title":"Computing Resources"},{"location":"operations/planning/#disk-space-and-data-location","text":"immudb is an immutable database, this means all history is preserved and therefore disk usage is higher than a normal database. Data is stored in the directory specified by the dir option.","title":"Disk space and data location"},{"location":"operations/replication/","text":"Replication Replication strategy immudb includes support for replication by means of a follower approach. A database can be created or configured either to be a master or a replica of another database. ![replication using grpc clients](/immudb/replication-servers.jpg) During replication, master databases have a passive role. The grpc endpoint ExportTx is used by replicas to fetch unseen committed transactions from the master. Replicas are read only and any direct write operation will be rejected. Using replicas allow to distribute query loads. ![replicator fetches committed txs via grpc calls and replicate them using in-process method invocations](/immudb/replication-comm.jpg) Replication and users As shown in the diagram above, the replicator fetches committed transaction from the master via grpc calls. Internally, the replicator instantiates an immudb client (using the official golang SDK) and fetches unseen committed transactions from the master. In order to do so, the replicator requires valid user credentials with admin permissions, otherwise the master will reject any request. Creating a replica Creating a replica of an existent database using immuadmin is super easy: $ ./immuadmin login immudb Password: logged in $ ./immuadmin database create --replication-enabled=true --replication-follower-username=immudb --replication-follower-password=immudb --replication-master-database=defaultdb replicadb database 'replicadb' {replica: true} successfully created ::: tip Display all database creation flags with $ ./immuadmin help database create ::: Creating a second immudb instance to replicate systemdb and defaultdb behaves similarly Start immudb with enabled replication: $ ./immudb --replication-enabled=true --replication-follower-password=immudb --replication-follower-username=immudb --replication-master-address=127.0.0.1 ::: tip Display all replication flags $ ./immudb --help ::: Multiple replicas It's possible to create multiple replicas of a database. Each replica works independently of the others. ![multiple replicas of the same master database](/immudb/replication-multiple.jpg) Given the master database acts in passive mode, there are no special steps needed in order to create more replicas. Thus, by repeating the same steps to create the first replica it's possible to configure new ones. Replica of a replica In case many replicas are needed or the master database is under heavy load, it's possible to delegate the creation of replicas to an existent replica. This way, the master database is not affected by the total number of replicas being created. ![a replica indirectly following the master](/immudb/replication-chain.jpg) External replicator By creating a database as a replica but with disabled replication, no replicator is created for the database and an external process could be used to replicate committed transactions from the master. The grpc endpoint ReplicateTx may be used to externally replicate a transaction. Heterogeneous settings Replication is configured per database. Thus, the same immudb server may hold several master and replica databases at the same time.","title":"Replication"},{"location":"operations/replication/#replication","text":"","title":"Replication"},{"location":"operations/replication/#replication-strategy","text":"immudb includes support for replication by means of a follower approach. A database can be created or configured either to be a master or a replica of another database. ![replication using grpc clients](/immudb/replication-servers.jpg) During replication, master databases have a passive role. The grpc endpoint ExportTx is used by replicas to fetch unseen committed transactions from the master. Replicas are read only and any direct write operation will be rejected. Using replicas allow to distribute query loads. ![replicator fetches committed txs via grpc calls and replicate them using in-process method invocations](/immudb/replication-comm.jpg)","title":"Replication strategy"},{"location":"operations/replication/#replication-and-users","text":"As shown in the diagram above, the replicator fetches committed transaction from the master via grpc calls. Internally, the replicator instantiates an immudb client (using the official golang SDK) and fetches unseen committed transactions from the master. In order to do so, the replicator requires valid user credentials with admin permissions, otherwise the master will reject any request.","title":"Replication and users"},{"location":"operations/replication/#creating-a-replica","text":"Creating a replica of an existent database using immuadmin is super easy: $ ./immuadmin login immudb Password: logged in $ ./immuadmin database create --replication-enabled=true --replication-follower-username=immudb --replication-follower-password=immudb --replication-master-database=defaultdb replicadb database 'replicadb' {replica: true} successfully created ::: tip Display all database creation flags with $ ./immuadmin help database create :::","title":"Creating a replica"},{"location":"operations/replication/#creating-a-second-immudb-instance-to-replicate-systemdb-and-defaultdb-behaves-similarly","text":"Start immudb with enabled replication: $ ./immudb --replication-enabled=true --replication-follower-password=immudb --replication-follower-username=immudb --replication-master-address=127.0.0.1 ::: tip Display all replication flags $ ./immudb --help :::","title":"Creating a second immudb instance to replicate systemdb and defaultdb behaves similarly"},{"location":"operations/replication/#multiple-replicas","text":"It's possible to create multiple replicas of a database. Each replica works independently of the others. ![multiple replicas of the same master database](/immudb/replication-multiple.jpg) Given the master database acts in passive mode, there are no special steps needed in order to create more replicas. Thus, by repeating the same steps to create the first replica it's possible to configure new ones.","title":"Multiple replicas"},{"location":"operations/replication/#replica-of-a-replica","text":"In case many replicas are needed or the master database is under heavy load, it's possible to delegate the creation of replicas to an existent replica. This way, the master database is not affected by the total number of replicas being created. ![a replica indirectly following the master](/immudb/replication-chain.jpg)","title":"Replica of a replica"},{"location":"operations/replication/#external-replicator","text":"By creating a database as a replica but with disabled replication, no replicator is created for the database and an external process could be used to replicate committed transactions from the master. The grpc endpoint ReplicateTx may be used to externally replicate a transaction.","title":"External replicator"},{"location":"operations/replication/#heterogeneous-settings","text":"Replication is configured per database. Thus, the same immudb server may hold several master and replica databases at the same time.","title":"Heterogeneous settings"},{"location":"operations/service/","text":"Running as a service Every operating system has different ways of running services. immudb provides a facility called immudb service to hide this complexity. To install the service run as root: $ ./immudb service install This will for example, on Linux, install /etc/systemd/system/immudb.service and create the appropriate user to run the service. On other operating systems, the native method would be used. The immudb service command also allows to control the lifecycle of the service: $ ./immudb service start $ ./immudb service stop $ ./immudb service status On Linux, immudb service status is equivalent to systemctl status immudb.service , and is what it does under the hoods.","title":"Running as a service"},{"location":"operations/service/#running-as-a-service","text":"Every operating system has different ways of running services. immudb provides a facility called immudb service to hide this complexity. To install the service run as root: $ ./immudb service install This will for example, on Linux, install /etc/systemd/system/immudb.service and create the appropriate user to run the service. On other operating systems, the native method would be used. The immudb service command also allows to control the lifecycle of the service: $ ./immudb service start $ ./immudb service stop $ ./immudb service status On Linux, immudb service status is equivalent to systemctl status immudb.service , and is what it does under the hoods.","title":"Running as a service"},{"location":"operations/specs/","text":"immudb specs immudb is an append-only, tamperproof database with key/value and SQL (Structured Query Language) application programming interfaces. The immudb core persistence layer consists of a cryptographically-immutable log. Transactions are sequentially stored and uniquely identified by unsigned 64-bit integer values, thus setting a theoretical limit of 18446744073709551615 transactions (1^64 - 1). In order to provide manageable limits, immudb is designed to set an upper bound to the number of key-value pairs included in a single transaction. The default value being 1024, so using default settings, the theoretical number of key-value pairs that can be stored in immudb is: 1024 * (1^64 - 1). We designed immudb to require stable resources but not imposing strong limitations as most of the settings can be adjusted based on the use-case requirements. While key-value pairs consist of arbitrary byte arrays, a maximum length may be set at database creation time. Both parameters can be increased as needed, considering: long keys may degrade performance (when querying data through the index) longer values requires more memory at runtime Note: The cryptographic linking does not impose a practical restriction. immudb relies on a file abstraction layer and does not directly interact with the underlying file-system, if any. But default storage layer implementation writes data into fixed-size files, default size being 512MB. The current theoretical maximum number of files is 100 millions. Summary Theoretical limits may be determined by a couple of elements: max number transactions: 2^64-1 (uint64) max number of files: 2^63-1 (max file size 2^56-1) max value length: 32 MB (max size: 2^56-1 bytes) max key length: 1024 Bytes (max length: 2^31-1 bytes) Running platforms immudb server runs in most operating systems: BSD, Linux, OS X, Solaris, Windows, IBM z/OS Key/Value API immudb includes a basic yet complete set of operations you would expect from a key-value store: Set (SetRequest) returns (TxMetadata) Get (KeyRequest) returns (Entry) SetReference (ReferenceRequest) returns (TxMetadata) Scan(ScanRequest) returns (Entries) History(HistoryRequest) returns (Entries) // grouping and sorting keys based on assgined scores ZAdd (ZAddRequest) returns (TxMetadata) ZScan (ZScanRequest) returns (ZEntries) Additionally, immudb exposes direct access to transactions based on its unique identifier: TxById(TxRequest) returns (Tx) TxScan(TxScanRequest) returns (TxList) But more importantly, immudb is able to generate cryptographic-proofs whenever is needed: VerifiableSet (VerifiableSetRequest) returns (VerifiableTx) VerifiableGet (VerifiableGetRequest) returns (VerifiableEntry) VerifiableTxById(VerifiableTxRequest) returns (VerifiableTx) VerifiableSetReference (VerifiableReferenceRequest) returns (VerifiableTx) VerifiableZAdd (VerifiableZAddRequest) returns (VerifiableTx) Check official SDKs documentation at develop with immudb . SQL API Based on the key-value storage layer, immudb includes a simplified SQL engine which is able to interprete most common features you would expect from a relational database but with the possibility to verify rows has not been tampered with. SQLExec(SQLExecRequest) returns (SQLExecResult) SQLQuery(SQLQueryRequest) returns (SQLQueryResult) \u200b VerifiableSQLGet (VerifiableSQLGetRequest) returns (VerifiableSQLEntry) Check SQL reference for a comprehensive description of SQL statements. S3 Storage Backend immudb can store its data in the Amazon S3 service (or a compatible alternative). The following example shows how to run immudb with the S3 storage enabled: export IMMUDB_S3_STORAGE=true export IMMUDB_S3_ACCESS_KEY_ID=<S3 ACCESS KEY ID> export IMMUDB_S3_SECRET_KEY=<SECRET KEY> export IMMUDB_S3_BUCKET_NAME=<BUCKET NAME> export IMMUDB_S3_LOCATION=<AWS S3 REGION> export IMMUDB_S3_PATH_PREFIX=testing-001 export IMMUDB_S3_ENDPOINT=\"https://${IMMUDB_S3_BUCKET_NAME}.s3.amazonaws.com\" ./immudb","title":"immudb specs"},{"location":"operations/specs/#immudb-specs","text":"immudb is an append-only, tamperproof database with key/value and SQL (Structured Query Language) application programming interfaces. The immudb core persistence layer consists of a cryptographically-immutable log. Transactions are sequentially stored and uniquely identified by unsigned 64-bit integer values, thus setting a theoretical limit of 18446744073709551615 transactions (1^64 - 1). In order to provide manageable limits, immudb is designed to set an upper bound to the number of key-value pairs included in a single transaction. The default value being 1024, so using default settings, the theoretical number of key-value pairs that can be stored in immudb is: 1024 * (1^64 - 1). We designed immudb to require stable resources but not imposing strong limitations as most of the settings can be adjusted based on the use-case requirements. While key-value pairs consist of arbitrary byte arrays, a maximum length may be set at database creation time. Both parameters can be increased as needed, considering: long keys may degrade performance (when querying data through the index) longer values requires more memory at runtime Note: The cryptographic linking does not impose a practical restriction. immudb relies on a file abstraction layer and does not directly interact with the underlying file-system, if any. But default storage layer implementation writes data into fixed-size files, default size being 512MB. The current theoretical maximum number of files is 100 millions.","title":"immudb specs"},{"location":"operations/specs/#summary","text":"Theoretical limits may be determined by a couple of elements: max number transactions: 2^64-1 (uint64) max number of files: 2^63-1 (max file size 2^56-1) max value length: 32 MB (max size: 2^56-1 bytes) max key length: 1024 Bytes (max length: 2^31-1 bytes)","title":"Summary"},{"location":"operations/specs/#running-platforms","text":"immudb server runs in most operating systems: BSD, Linux, OS X, Solaris, Windows, IBM z/OS","title":"Running platforms"},{"location":"operations/specs/#keyvalue-api","text":"immudb includes a basic yet complete set of operations you would expect from a key-value store: Set (SetRequest) returns (TxMetadata) Get (KeyRequest) returns (Entry) SetReference (ReferenceRequest) returns (TxMetadata) Scan(ScanRequest) returns (Entries) History(HistoryRequest) returns (Entries) // grouping and sorting keys based on assgined scores ZAdd (ZAddRequest) returns (TxMetadata) ZScan (ZScanRequest) returns (ZEntries) Additionally, immudb exposes direct access to transactions based on its unique identifier: TxById(TxRequest) returns (Tx) TxScan(TxScanRequest) returns (TxList) But more importantly, immudb is able to generate cryptographic-proofs whenever is needed: VerifiableSet (VerifiableSetRequest) returns (VerifiableTx) VerifiableGet (VerifiableGetRequest) returns (VerifiableEntry) VerifiableTxById(VerifiableTxRequest) returns (VerifiableTx) VerifiableSetReference (VerifiableReferenceRequest) returns (VerifiableTx) VerifiableZAdd (VerifiableZAddRequest) returns (VerifiableTx) Check official SDKs documentation at develop with immudb .","title":"Key/Value API"},{"location":"operations/specs/#sql-api","text":"Based on the key-value storage layer, immudb includes a simplified SQL engine which is able to interprete most common features you would expect from a relational database but with the possibility to verify rows has not been tampered with. SQLExec(SQLExecRequest) returns (SQLExecResult) SQLQuery(SQLQueryRequest) returns (SQLQueryResult) \u200b VerifiableSQLGet (VerifiableSQLGetRequest) returns (VerifiableSQLEntry) Check SQL reference for a comprehensive description of SQL statements.","title":"SQL API"},{"location":"operations/specs/#s3-storage-backend","text":"immudb can store its data in the Amazon S3 service (or a compatible alternative). The following example shows how to run immudb with the S3 storage enabled: export IMMUDB_S3_STORAGE=true export IMMUDB_S3_ACCESS_KEY_ID=<S3 ACCESS KEY ID> export IMMUDB_S3_SECRET_KEY=<SECRET KEY> export IMMUDB_S3_BUCKET_NAME=<BUCKET NAME> export IMMUDB_S3_LOCATION=<AWS S3 REGION> export IMMUDB_S3_PATH_PREFIX=testing-001 export IMMUDB_S3_ENDPOINT=\"https://${IMMUDB_S3_BUCKET_NAME}.s3.amazonaws.com\" ./immudb","title":"S3 Storage Backend"},{"location":"reference/commands/","text":"Command reference immudb Simply run ./immudb -d to start immudb locally in the background. If you want to stop immudb \u00een that case you need to find the process ps -ax | grep immudb and then kill -15 <pid> . Windows PowerShell would be Get-Process immudb* | Stop-Process . immudb - the lightweight, high-speed immutable database for systems and applications. Environment variables: IMMUDB_DIR=. IMMUDB_NETWORK=tcp IMMUDB_ADDRESS=0.0.0.0 IMMUDB_PORT=3322 IMMUDB_DBNAME=immudb IMMUDB_PIDFILE= IMMUDB_LOGFILE= IMMUDB_MTLS=false IMMUDB_AUTH=true IMMUDB_DETACHED=false IMMUDB_CONSISTENCY_CHECK=true IMMUDB_PKEY=./tools/mtls/3_application/private/localhost.key.pem IMMUDB_CERTIFICATE=./tools/mtls/3_application/certs/localhost.cert.pem IMMUDB_CLIENTCAS=./tools/mtls/2_intermediate/certs/ca-chain.cert.pem IMMUDB_DEVMODE=true IMMUDB_MAINTENANCE=false IMMUDB_ADMIN_PASSWORD=immudb Usage: immudb [flags] immudb [command] Available Commands: help Help about any command version Show the immudb version Flags: -a, --address string bind address (default \"0.0.0.0\") --admin-password string admin password (default is 'immu') as plain-text or base64 encoded (must be prefixed with 'enc:' if it is encoded) (default \"immudb\") -s, --auth enable auth --certificate string server certificate file path (default \"./tools/mtls/3_application/certs/localhost.cert.pem\") --clientcas string clients certificates list. Aka certificate authority (default \"./tools/mtls/2_intermediate/certs/ca-chain.cert.pem\") --config string config file (default path are configs or $HOME. Default filename is immudb.ini) --consistency-check enable consistency check monitor routine. To disable: --consistency-check=false (default true) -d, --detached run immudb in background --devmode enable dev mode: accept remote connections without auth --dir string data folder (default \"./data\") -h, --help help for immudb --logfile string log path with filename. E.g. /tmp/immudb/immudb.log --maintenance override the authentication flag -m, --mtls enable mutual tls --no-histograms disable collection of histogram metrics like query durations --pidfile string pid path with filename. E.g. /var/run/immudb.pid --pkey string server private key path (default \"./tools/mtls/3_application/private/localhost.key.pem\") -p, --port int port number (default 3322) Use \"immudb [command] --help\" for more information about a command. immugw immugw can be found in a different repository Simply run ./immugw -d to start immugw on the same machine as immudb (test or dev environment) or point to the remote immudb system ./immugw --immudbaddress \"immudb-server\" . If you want to stop immugw \u00een that case you need to find the process ps -ax | grep immugw and then kill -15 <pid> . Windows PowerShell would be Get-Process immugw* | Stop-Process . immu gateway: a smart REST proxy for immudb - the lightweight, high-speed immutable database for systems and applications. It exposes all gRPC methods with a REST interface while wrapping all SAFE endpoints with a verification service. Environment variables: IMMUGW_ADDRESS=0.0.0.0 IMMUGW_PORT=3323 IMMUGW_IMMUDB_ADDRESS=127.0.0.1 IMMUGW_IMMUDB_PORT=3322 IMMUGW_DIR=. IMMUGW_PIDFILE= IMMUGW_LOGFILE= IMMUGW_DETACHED=false IMMUGW_MTLS=false IMMUGW_SERVERNAME=localhost IMMUGW_PKEY=./tools/mtls/4_client/private/localhost.key.pem IMMUGW_CERTIFICATE=./tools/mtls/4_client/certs/localhost.cert.pem IMMUGW_CLIENTCAS=./tools/mtls/2_intermediate/certs/ca-chain.cert.pem Usage: immugw [flags] immugw [command] Available Commands: help Help about any command version Show the immugw version Flags: -a, --address string immugw host address (default \"0.0.0.0\") --audit enable audit mode (continuously fetches latest root from server, checks consistency against a local root and saves the latest root locally) --audit-interval duration interval at which audit should run (default 5m0s) --audit-password string immudb password used to login during audit; can be plain-text or base64 encoded (must be prefixed with 'enc:' if it is encoded) --audit-username string immudb username used to login during audit (default \"immugwauditor\") --certificate string server certificate file path (default \"./tools/mtls/4_client/certs/localhost.cert.pem\") --clientcas string clients certificates list. Aka certificate authority (default \"./tools/mtls/2_intermediate/certs/ca-chain.cert.pem\") --config string config file (default path are configs or $HOME. Default filename is immugw.toml) -d, --detached run immudb in background --dir string program files folder (default \".\") -h, --help help for immugw -k, --immudb-address string immudb host address (default \"127.0.0.1\") -j, --immudb-port int immudb port number (default 3322) --logfile string log path with filename. E.g. /tmp/immugw/immugw.log -m, --mtls enable mutual tls --pidfile string pid path with filename. E.g. /var/run/immugw.pid --pkey string server private key path (default \"./tools/mtls/4_client/private/localhost.key.pem\") -p, --port int immugw port number (default 3323) --servername string used to verify the hostname on the returned certificates (default \"localhost\") Use \"immugw [command] --help\" for more information about a command. immuadmin For security reasons we recommend using immuadmin only on the same system as immudb. User management is restricted to localhost usage. Simply run ./immuadmin on the same machine. CLI admin client for immudb - the lightweight, high-speed immutable database for systems and applications. Environment variables: IMMUADMIN_IMMUDB_ADDRESS=127.0.0.1 IMMUADMIN_IMMUDB_PORT=3322 IMMUADMIN_MTLS=true IMMUADMIN_SERVERNAME=localhost IMMUADMIN_PKEY=./tools/mtls/4_client/private/localhost.key.pem IMMUADMIN_CERTIFICATE=./tools/mtls/4_client/certs/localhost.cert.pem IMMUADMIN_CLIENTCAS=./tools/mtls/2_intermediate/certs/ca-chain.cert.pem Usage: immuadmin [command] Available Commands: backup Make a copy of the database files and folders database Issue all database commands dump Dump database content to a file help Help about any command login Login using the specified username and password (admin username is immudb) logout print Print merkle tree restore Restore the database from a snapshot archive or folder service Manage immu services set Update server config items: auth (none|password|cryptosig), mtls (true|false) stats Show statistics as text or visually with the '-v' option. Run 'immuadmin stats -h' for details. status Show heartbeat status user Issue all user commands version Show the immuadmin version Flags: --certificate string server certificate file path (default \"./tools/mtls/4_client/certs/localhost.cert.pem\") --clientcas string clients certificates list. Aka certificate authority (default \"./tools/mtls/2_intermediate/certs/ca-chain.cert.pem\") --config string config file (default path is configs or $HOME; default filename is immuadmin.toml) -h, --help help for immuadmin -a, --immudb-address string immudb host address (default \"127.0.0.1\") -p, --immudb-port int immudb port number (default 3322) -m, --mtls enable mutual tls --pkey string server private key path (default \"./tools/mtls/4_client/private/localhost.key.pem\") --servername string used to verify the hostname on the returned certificates (default \"localhost\") --tokenfile string authentication token file (default path is $HOME or binary location; the supplied value will be automatically suffixed with _admin; default filename is token-0.7.0_admin) (default \"token-0.7.0\") Use \"immuadmin [command] --help\" for more information about a command. immuclient Simply run ./immuclient on the same machine or connect to a remote immudb ./immuclient -a <immudb-host> CLI client for immudb - the lightweight, high-speed immutable database for systems and applications. Environment variables: IMMUCLIENT_IMMUDB_ADDRESS=127.0.0.1 IMMUCLIENT_IMMUDB_PORT=3322 IMMUCLIENT_AUTH=true IMMUCLIENT_MTLS=false IMMUCLIENT_SERVERNAME=localhost IMMUCLIENT_PKEY=./tools/mtls/4_client/private/localhost.key.pem IMMUCLIENT_CERTIFICATE=./tools/mtls/4_client/certs/localhost.cert.pem IMMUCLIENT_CLIENTCAS=./tools/mtls/2_intermediate/certs/ca-chain.cert.pem IMPORTANT: All get and safeget functions return base64-encoded keys and values, while all set and safeset functions expect base64-encoded inputs. Usage: immuclient [flags] immuclient [command] Available Commands: audit-mode Starts immuclient as daemon in auditor mode. Run 'immuclient audit-mode help' or use -h flag for details check-consistency Check consistency for the specified index and hash count Count keys having the specified prefix current Return the last merkle tree root and index stored locally get Get item having the specified key getByIndex Return an element by index getRawBySafeIndex Return an element by index help Help about any command history Fetch history for the item having the specified key inclusion Check if specified index is included in the current tree iscan Iterate over all elements by insertion order it Starts immuclient in CLI mode. Use 'help' or -h flag on the shell for details login Login using the specified username and password logout rawsafeget Get item having the specified key, without parsing structured values rawsafeset Set a value for the item having the specified key, without setup structured values reference Add new reference to an existing key safeget Get and verify item having the specified key safereference Add and verify new reference to an existing key safeset Add and verify new item having the specified key and value safezadd Add and verify new key with score to a new or existing sorted set scan Iterate over keys having the specified prefix set Add new item having the specified key and value status Ping to check if server connection is alive use Select database user Issue all user commands version Show the immuclient version zadd Add new key with score to a new or existing sorted set zscan Iterate over a sorted set Flags: --audit-password string immudb password used to login during audit; can be plain-text or base64 encoded (must be prefixed with 'enc:' if it is encoded) --audit-username string immudb username used to login during audit --certificate string server certificate file path (default \"./tools/mtls/4_client/certs/localhost.cert.pem\") --clientcas string clients certificates list. Aka certificate authority (default \"./tools/mtls/2_intermediate/certs/ca-chain.cert.pem\") --config string config file (default path are configs or $HOME. Default filename is immuclient.toml) --dir string Main directory for audit process tool to initialize (default \"/tmp\") -h, --help help for immuclient -a, --immudb-address string immudb host address (default \"127.0.0.1\") -p, --immudb-port int immudb port number (default 3322) -m, --mtls enable mutual tls --pkey string server private key path (default \"./tools/mtls/4_client/private/localhost.key.pem\") --prometheus-host string Launch host of the Prometheus exporter. (default \"0.0.0.0\") --prometheus-port string Launch port of the Prometheus exporter. (default \"9477\") --roots-filepath string Filepath for storing root hashes after every successful audit loop. Default is tempdir of every OS. (default \"/tmp/\") --servername string used to verify the hostname on the returned certificates (default \"localhost\") --tokenfile string authentication token file (default path is $HOME or binary location; default filename is token-0.7.0) (default \"token-0.7.0\") --value-only returning only values for get operations Use \"immuclient [command] --help\" for more information about a command.","title":"Command reference"},{"location":"reference/commands/#command-reference","text":"","title":"Command reference"},{"location":"reference/commands/#immudb","text":"Simply run ./immudb -d to start immudb locally in the background. If you want to stop immudb \u00een that case you need to find the process ps -ax | grep immudb and then kill -15 <pid> . Windows PowerShell would be Get-Process immudb* | Stop-Process . immudb - the lightweight, high-speed immutable database for systems and applications. Environment variables: IMMUDB_DIR=. IMMUDB_NETWORK=tcp IMMUDB_ADDRESS=0.0.0.0 IMMUDB_PORT=3322 IMMUDB_DBNAME=immudb IMMUDB_PIDFILE= IMMUDB_LOGFILE= IMMUDB_MTLS=false IMMUDB_AUTH=true IMMUDB_DETACHED=false IMMUDB_CONSISTENCY_CHECK=true IMMUDB_PKEY=./tools/mtls/3_application/private/localhost.key.pem IMMUDB_CERTIFICATE=./tools/mtls/3_application/certs/localhost.cert.pem IMMUDB_CLIENTCAS=./tools/mtls/2_intermediate/certs/ca-chain.cert.pem IMMUDB_DEVMODE=true IMMUDB_MAINTENANCE=false IMMUDB_ADMIN_PASSWORD=immudb Usage: immudb [flags] immudb [command] Available Commands: help Help about any command version Show the immudb version Flags: -a, --address string bind address (default \"0.0.0.0\") --admin-password string admin password (default is 'immu') as plain-text or base64 encoded (must be prefixed with 'enc:' if it is encoded) (default \"immudb\") -s, --auth enable auth --certificate string server certificate file path (default \"./tools/mtls/3_application/certs/localhost.cert.pem\") --clientcas string clients certificates list. Aka certificate authority (default \"./tools/mtls/2_intermediate/certs/ca-chain.cert.pem\") --config string config file (default path are configs or $HOME. Default filename is immudb.ini) --consistency-check enable consistency check monitor routine. To disable: --consistency-check=false (default true) -d, --detached run immudb in background --devmode enable dev mode: accept remote connections without auth --dir string data folder (default \"./data\") -h, --help help for immudb --logfile string log path with filename. E.g. /tmp/immudb/immudb.log --maintenance override the authentication flag -m, --mtls enable mutual tls --no-histograms disable collection of histogram metrics like query durations --pidfile string pid path with filename. E.g. /var/run/immudb.pid --pkey string server private key path (default \"./tools/mtls/3_application/private/localhost.key.pem\") -p, --port int port number (default 3322) Use \"immudb [command] --help\" for more information about a command.","title":"immudb"},{"location":"reference/commands/#immugw","text":"immugw can be found in a different repository Simply run ./immugw -d to start immugw on the same machine as immudb (test or dev environment) or point to the remote immudb system ./immugw --immudbaddress \"immudb-server\" . If you want to stop immugw \u00een that case you need to find the process ps -ax | grep immugw and then kill -15 <pid> . Windows PowerShell would be Get-Process immugw* | Stop-Process . immu gateway: a smart REST proxy for immudb - the lightweight, high-speed immutable database for systems and applications. It exposes all gRPC methods with a REST interface while wrapping all SAFE endpoints with a verification service. Environment variables: IMMUGW_ADDRESS=0.0.0.0 IMMUGW_PORT=3323 IMMUGW_IMMUDB_ADDRESS=127.0.0.1 IMMUGW_IMMUDB_PORT=3322 IMMUGW_DIR=. IMMUGW_PIDFILE= IMMUGW_LOGFILE= IMMUGW_DETACHED=false IMMUGW_MTLS=false IMMUGW_SERVERNAME=localhost IMMUGW_PKEY=./tools/mtls/4_client/private/localhost.key.pem IMMUGW_CERTIFICATE=./tools/mtls/4_client/certs/localhost.cert.pem IMMUGW_CLIENTCAS=./tools/mtls/2_intermediate/certs/ca-chain.cert.pem Usage: immugw [flags] immugw [command] Available Commands: help Help about any command version Show the immugw version Flags: -a, --address string immugw host address (default \"0.0.0.0\") --audit enable audit mode (continuously fetches latest root from server, checks consistency against a local root and saves the latest root locally) --audit-interval duration interval at which audit should run (default 5m0s) --audit-password string immudb password used to login during audit; can be plain-text or base64 encoded (must be prefixed with 'enc:' if it is encoded) --audit-username string immudb username used to login during audit (default \"immugwauditor\") --certificate string server certificate file path (default \"./tools/mtls/4_client/certs/localhost.cert.pem\") --clientcas string clients certificates list. Aka certificate authority (default \"./tools/mtls/2_intermediate/certs/ca-chain.cert.pem\") --config string config file (default path are configs or $HOME. Default filename is immugw.toml) -d, --detached run immudb in background --dir string program files folder (default \".\") -h, --help help for immugw -k, --immudb-address string immudb host address (default \"127.0.0.1\") -j, --immudb-port int immudb port number (default 3322) --logfile string log path with filename. E.g. /tmp/immugw/immugw.log -m, --mtls enable mutual tls --pidfile string pid path with filename. E.g. /var/run/immugw.pid --pkey string server private key path (default \"./tools/mtls/4_client/private/localhost.key.pem\") -p, --port int immugw port number (default 3323) --servername string used to verify the hostname on the returned certificates (default \"localhost\") Use \"immugw [command] --help\" for more information about a command.","title":"immugw"},{"location":"reference/commands/#immuadmin","text":"For security reasons we recommend using immuadmin only on the same system as immudb. User management is restricted to localhost usage. Simply run ./immuadmin on the same machine. CLI admin client for immudb - the lightweight, high-speed immutable database for systems and applications. Environment variables: IMMUADMIN_IMMUDB_ADDRESS=127.0.0.1 IMMUADMIN_IMMUDB_PORT=3322 IMMUADMIN_MTLS=true IMMUADMIN_SERVERNAME=localhost IMMUADMIN_PKEY=./tools/mtls/4_client/private/localhost.key.pem IMMUADMIN_CERTIFICATE=./tools/mtls/4_client/certs/localhost.cert.pem IMMUADMIN_CLIENTCAS=./tools/mtls/2_intermediate/certs/ca-chain.cert.pem Usage: immuadmin [command] Available Commands: backup Make a copy of the database files and folders database Issue all database commands dump Dump database content to a file help Help about any command login Login using the specified username and password (admin username is immudb) logout print Print merkle tree restore Restore the database from a snapshot archive or folder service Manage immu services set Update server config items: auth (none|password|cryptosig), mtls (true|false) stats Show statistics as text or visually with the '-v' option. Run 'immuadmin stats -h' for details. status Show heartbeat status user Issue all user commands version Show the immuadmin version Flags: --certificate string server certificate file path (default \"./tools/mtls/4_client/certs/localhost.cert.pem\") --clientcas string clients certificates list. Aka certificate authority (default \"./tools/mtls/2_intermediate/certs/ca-chain.cert.pem\") --config string config file (default path is configs or $HOME; default filename is immuadmin.toml) -h, --help help for immuadmin -a, --immudb-address string immudb host address (default \"127.0.0.1\") -p, --immudb-port int immudb port number (default 3322) -m, --mtls enable mutual tls --pkey string server private key path (default \"./tools/mtls/4_client/private/localhost.key.pem\") --servername string used to verify the hostname on the returned certificates (default \"localhost\") --tokenfile string authentication token file (default path is $HOME or binary location; the supplied value will be automatically suffixed with _admin; default filename is token-0.7.0_admin) (default \"token-0.7.0\") Use \"immuadmin [command] --help\" for more information about a command.","title":"immuadmin"},{"location":"reference/commands/#immuclient","text":"Simply run ./immuclient on the same machine or connect to a remote immudb ./immuclient -a <immudb-host> CLI client for immudb - the lightweight, high-speed immutable database for systems and applications. Environment variables: IMMUCLIENT_IMMUDB_ADDRESS=127.0.0.1 IMMUCLIENT_IMMUDB_PORT=3322 IMMUCLIENT_AUTH=true IMMUCLIENT_MTLS=false IMMUCLIENT_SERVERNAME=localhost IMMUCLIENT_PKEY=./tools/mtls/4_client/private/localhost.key.pem IMMUCLIENT_CERTIFICATE=./tools/mtls/4_client/certs/localhost.cert.pem IMMUCLIENT_CLIENTCAS=./tools/mtls/2_intermediate/certs/ca-chain.cert.pem IMPORTANT: All get and safeget functions return base64-encoded keys and values, while all set and safeset functions expect base64-encoded inputs. Usage: immuclient [flags] immuclient [command] Available Commands: audit-mode Starts immuclient as daemon in auditor mode. Run 'immuclient audit-mode help' or use -h flag for details check-consistency Check consistency for the specified index and hash count Count keys having the specified prefix current Return the last merkle tree root and index stored locally get Get item having the specified key getByIndex Return an element by index getRawBySafeIndex Return an element by index help Help about any command history Fetch history for the item having the specified key inclusion Check if specified index is included in the current tree iscan Iterate over all elements by insertion order it Starts immuclient in CLI mode. Use 'help' or -h flag on the shell for details login Login using the specified username and password logout rawsafeget Get item having the specified key, without parsing structured values rawsafeset Set a value for the item having the specified key, without setup structured values reference Add new reference to an existing key safeget Get and verify item having the specified key safereference Add and verify new reference to an existing key safeset Add and verify new item having the specified key and value safezadd Add and verify new key with score to a new or existing sorted set scan Iterate over keys having the specified prefix set Add new item having the specified key and value status Ping to check if server connection is alive use Select database user Issue all user commands version Show the immuclient version zadd Add new key with score to a new or existing sorted set zscan Iterate over a sorted set Flags: --audit-password string immudb password used to login during audit; can be plain-text or base64 encoded (must be prefixed with 'enc:' if it is encoded) --audit-username string immudb username used to login during audit --certificate string server certificate file path (default \"./tools/mtls/4_client/certs/localhost.cert.pem\") --clientcas string clients certificates list. Aka certificate authority (default \"./tools/mtls/2_intermediate/certs/ca-chain.cert.pem\") --config string config file (default path are configs or $HOME. Default filename is immuclient.toml) --dir string Main directory for audit process tool to initialize (default \"/tmp\") -h, --help help for immuclient -a, --immudb-address string immudb host address (default \"127.0.0.1\") -p, --immudb-port int immudb port number (default 3322) -m, --mtls enable mutual tls --pkey string server private key path (default \"./tools/mtls/4_client/private/localhost.key.pem\") --prometheus-host string Launch host of the Prometheus exporter. (default \"0.0.0.0\") --prometheus-port string Launch port of the Prometheus exporter. (default \"9477\") --roots-filepath string Filepath for storing root hashes after every successful audit loop. Default is tempdir of every OS. (default \"/tmp/\") --servername string used to verify the hostname on the returned certificates (default \"localhost\") --tokenfile string authentication token file (default path is $HOME or binary location; default filename is token-0.7.0) (default \"token-0.7.0\") --value-only returning only values for get operations Use \"immuclient [command] --help\" for more information about a command.","title":"immuclient"},{"location":"reference/configuration/","text":"Configuration This page describes how to set different settings in immudb. Some of the most important settings that ones are: Parameter Default Description dir ./data System and user databases are stored here network tcp address 0.0.0.0 Listening address port 3322 Listing port mtls false Whether to enable Mutual TLS pkey If specified, the server can sign the state the clients use to verify immutability auth true If enabled, immudb will require user and password from the client clientcas Client certificate authority maintenance Maintenance mode. Override the authentication flag sync Runs in sync mode. Prevents data loss but affects performance token-expiry-time 1440 Client token expiry time, in minutes web-server true Embedded web console server web-server-port 8080 Embeded web console port server pgsql-server true pqsql protocol compatibility server (allows to connect from pgsql compatible clients) pgsql-server-port 5432 pqsql protocol compatibility server port Settings can be specified as command line options to immudb (see immudb -h ), in a configuration file, or as environment variables. Configuration file Settings can be specified in a immudb.toml configuration file . Which configuration file to use is set with the --config option. By default, immudb looks into the configs subfolder in the current directory. When running immudb as a service, immudb service install allows to specify the configuration file to use with the --config option. Environment variables Settings specified via environment variables take override the configuration file. They are specified in the form of IMMUDB_ , for example IMMUDB_DIR specifies the dir variable.","title":"Configuration"},{"location":"reference/configuration/#configuration","text":"This page describes how to set different settings in immudb. Some of the most important settings that ones are: Parameter Default Description dir ./data System and user databases are stored here network tcp address 0.0.0.0 Listening address port 3322 Listing port mtls false Whether to enable Mutual TLS pkey If specified, the server can sign the state the clients use to verify immutability auth true If enabled, immudb will require user and password from the client clientcas Client certificate authority maintenance Maintenance mode. Override the authentication flag sync Runs in sync mode. Prevents data loss but affects performance token-expiry-time 1440 Client token expiry time, in minutes web-server true Embedded web console server web-server-port 8080 Embeded web console port server pgsql-server true pqsql protocol compatibility server (allows to connect from pgsql compatible clients) pgsql-server-port 5432 pqsql protocol compatibility server port Settings can be specified as command line options to immudb (see immudb -h ), in a configuration file, or as environment variables.","title":"Configuration"},{"location":"reference/configuration/#configuration-file","text":"Settings can be specified in a immudb.toml configuration file . Which configuration file to use is set with the --config option. By default, immudb looks into the configs subfolder in the current directory. When running immudb as a service, immudb service install allows to specify the configuration file to use with the --config option.","title":"Configuration file"},{"location":"reference/configuration/#environment-variables","text":"Settings specified via environment variables take override the configuration file. They are specified in the form of IMMUDB_ , for example IMMUDB_DIR specifies the dir variable.","title":"Environment variables"},{"location":"reference/sdk/","text":"SDK API Golang","title":"SDK API"},{"location":"reference/sdk/#sdk-api","text":"Golang","title":"SDK API"}]}